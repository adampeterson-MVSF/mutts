{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/utils/index.ts"],"sourcesContent":["// lib/utils/index.ts\n// Shared utility functions for the application\n\nimport { AppStatus, AppType } from \"@prisma/client\";\n\n/**\n * Humanize enum values by replacing underscores with spaces and capitalizing words\n */\nexport const humanizeEnum = (value: string): string => {\n  return value\n    .toLowerCase()\n    .replace(/_/g, ' ')\n    .replace(/\\b\\w/g, l => l.toUpperCase());\n};\n\n/**\n * Status variant functions for consistent badge styling\n */\nexport const getAppStatusVariant = (status: AppStatus) => {\n  switch (status) {\n    case \"APPROVED\": return \"default\";\n    case \"SUBMITTED\": case \"IN_REVIEW\": return \"secondary\";\n    case \"REJECTED\": return \"destructive\";\n    default: return \"outline\";\n  }\n};\n\n/**\n * Get allowed status transitions for applications\n */\nexport const getAllowedStatuses = (applicationType: AppType, currentStatus?: AppStatus): AppStatus[] => {\n  const allStatuses = Object.values(AppStatus);\n\n  // For foster applications, restrict some status transitions\n  if (applicationType === AppType.FOSTER) {\n    // Fosters can be approved (creates foster profile) or rejected\n    // Can't be marked as \"IN_REVIEW\" inappropriately\n    return allStatuses.filter(status =>\n      status !== AppStatus.IN_REVIEW || currentStatus === AppStatus.IN_REVIEW\n    );\n  }\n\n  // For adoption applications, all statuses are allowed\n  return allStatuses;\n};\n\n/**\n * Check if status change notes are required for a given status\n */\nexport const areStatusNotesRequired = (status: AppStatus): boolean => {\n  return status === AppStatus.APPROVED || status === AppStatus.REJECTED;\n};\n"],"names":[],"mappings":"AAAA,qBAAqB;AACrB,+CAA+C;;;;;;;;;;;AAE/C;;AAKO,MAAM,eAAe,CAAC;IAC3B,OAAO,MACJ,WAAW,GACX,OAAO,CAAC,MAAM,KACd,OAAO,CAAC,SAAS,CAAA,IAAK,EAAE,WAAW;AACxC;AAKO,MAAM,sBAAsB,CAAC;IAClC,OAAQ;QACN,KAAK;YAAY,OAAO;QACxB,KAAK;QAAa,KAAK;YAAa,OAAO;QAC3C,KAAK;YAAY,OAAO;QACxB;YAAS,OAAO;IAClB;AACF;AAKO,MAAM,qBAAqB,CAAC,iBAA0B;IAC3D,MAAM,cAAc,OAAO,MAAM,CAAC,sKAAS;IAE3C,4DAA4D;IAC5D,IAAI,oBAAoB,oKAAO,CAAC,MAAM,EAAE;QACtC,+DAA+D;QAC/D,iDAAiD;QACjD,OAAO,YAAY,MAAM,CAAC,CAAA,SACxB,WAAW,sKAAS,CAAC,SAAS,IAAI,kBAAkB,sKAAS,CAAC,SAAS;IAE3E;IAEA,sDAAsD;IACtD,OAAO;AACT;AAKO,MAAM,yBAAyB,CAAC;IACrC,OAAO,WAAW,sKAAS,CAAC,QAAQ,IAAI,WAAW,sKAAS,CAAC,QAAQ;AACvE","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { AppStatus, AppType, DogStatus } from \"@prisma/client\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\n\n// This check can be removed, it is just for tutorial purposes\nexport const hasEnvVars =\n  !!(process.env.NEXT_PUBLIC_SUPABASE_URL &&\n     process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);\n\n\nexport const getDogStatusVariant = (status: DogStatus) => {\n  switch (status) {\n    case \"ADOPTED\": return \"default\";\n    case \"AVAILABLE\": return \"secondary\";\n    case \"MEDICAL_HOLD\": return \"destructive\";\n    case \"PENDING\": case \"IN_FOSTER\": return \"outline\";\n    default: return \"secondary\";\n  }\n};\n\n// Date formatting utilities\nexport const formatDateTime = (date: Date) =>\n  new Intl.DateTimeFormat(\"en-US\", {\n    month: \"short\",\n    day: \"numeric\",\n    year: \"numeric\",\n    hour: \"numeric\",\n    minute: \"2-digit\",\n  }).format(date);\n\nexport const formatDateRange = (start: Date, end: Date) => {\n  const sameDay =\n    start.getFullYear() === end.getFullYear() &&\n    start.getMonth() === end.getMonth() &&\n    start.getDate() === end.getDate();\n\n  if (sameDay) {\n    return `${formatDateTime(start)} – ${new Intl.DateTimeFormat(\"en-US\", {\n      hour: \"numeric\",\n      minute: \"2-digit\",\n    }).format(end)}`;\n  }\n\n  return `${formatDateTime(start)} → ${formatDateTime(end)}`;\n};\n\nexport const formatShiftTime = (start: Date, end: Date): string => {\n  const startDate = start.toLocaleDateString();\n  const startTime = start.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });\n  const endTime = end.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });\n\n  if (startDate === end.toLocaleDateString()) {\n    return `${startDate}, ${startTime} - ${endTime}`;\n  }\n  return `${startDate}, ${startTime} - ${end.toLocaleDateString()}, ${endTime}`;\n};\n\nexport const formatAdoptionDate = (date: Date) =>\n  new Intl.DateTimeFormat(\"en-US\", {\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\",\n  }).format(date);\n\n// Re-export shared utilities\nexport { humanizeEnum, getAppStatusVariant, getAllowedStatuses, areStatusNotesRequired } from './utils/index';\n\n// Test endpoint validation - allow in test environment or with test secret header\nexport function validateTestEndpoint(request: Request): { isValid: boolean; response?: Response } {\n  const isTestEnv = process.env.NODE_ENV === 'test' && process.env.EXPOSE_TEST_API === '1';\n\n  const testSecret = request.headers.get('x-test-secret');\n  const expectedSecret = process.env.TEST_SECRET || 'test-secret-default';\n  const hasValidTestSecret = testSecret === expectedSecret;\n\n  if (!isTestEnv || !hasValidTestSecret) {\n    return {\n      isValid: false,\n      response: new Response(null, { status: 404 })\n    };\n  }\n\n  return { isValid: true };\n}\n\n// Route definitions have been moved to lib/routes.ts\n// Import route functions from @/lib/routes instead\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAYK;AAZL;AACA;AAqEA,6BAA6B;AAC7B;;;AAlEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,yKAAO,EAAC,IAAA,gJAAI,EAAC;AACtB;AAIO,MAAM,aACX,CAAC,CAAC,CAAC,kKACyC;AAGvC,MAAM,sBAAsB,CAAC;IAClC,OAAQ;QACN,KAAK;YAAW,OAAO;QACvB,KAAK;YAAa,OAAO;QACzB,KAAK;YAAgB,OAAO;QAC5B,KAAK;QAAW,KAAK;YAAa,OAAO;QACzC;YAAS,OAAO;IAClB;AACF;AAGO,MAAM,iBAAiB,CAAC,OAC7B,IAAI,KAAK,cAAc,CAAC,SAAS;QAC/B,OAAO;QACP,KAAK;QACL,MAAM;QACN,MAAM;QACN,QAAQ;IACV,GAAG,MAAM,CAAC;AAEL,MAAM,kBAAkB,CAAC,OAAa;IAC3C,MAAM,UACJ,MAAM,WAAW,OAAO,IAAI,WAAW,MACvC,MAAM,QAAQ,OAAO,IAAI,QAAQ,MACjC,MAAM,OAAO,OAAO,IAAI,OAAO;IAEjC,IAAI,SAAS;QACX,OAAO,GAAG,eAAe,OAAO,GAAG,EAAE,IAAI,KAAK,cAAc,CAAC,SAAS;YACpE,MAAM;YACN,QAAQ;QACV,GAAG,MAAM,CAAC,MAAM;IAClB;IAEA,OAAO,GAAG,eAAe,OAAO,GAAG,EAAE,eAAe,MAAM;AAC5D;AAEO,MAAM,kBAAkB,CAAC,OAAa;IAC3C,MAAM,YAAY,MAAM,kBAAkB;IAC1C,MAAM,YAAY,MAAM,kBAAkB,CAAC,EAAE,EAAE;QAAE,MAAM;QAAW,QAAQ;IAAU;IACpF,MAAM,UAAU,IAAI,kBAAkB,CAAC,EAAE,EAAE;QAAE,MAAM;QAAW,QAAQ;IAAU;IAEhF,IAAI,cAAc,IAAI,kBAAkB,IAAI;QAC1C,OAAO,GAAG,UAAU,EAAE,EAAE,UAAU,GAAG,EAAE,SAAS;IAClD;IACA,OAAO,GAAG,UAAU,EAAE,EAAE,UAAU,GAAG,EAAE,IAAI,kBAAkB,GAAG,EAAE,EAAE,SAAS;AAC/E;AAEO,MAAM,qBAAqB,CAAC,OACjC,IAAI,KAAK,cAAc,CAAC,SAAS;QAC/B,MAAM;QACN,OAAO;QACP,KAAK;IACP,GAAG,MAAM,CAAC;;AAML,SAAS,qBAAqB,OAAgB;IACnD,MAAM,YAAY,oDAAyB,UAAU,2KAAO,CAAC,GAAG,CAAC,eAAe,KAAK;IAErF,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,MAAM,iBAAiB,2KAAO,CAAC,GAAG,CAAC,WAAW,IAAI;IAClD,MAAM,qBAAqB,eAAe;IAE1C,wCAAuC;QACrC,OAAO;YACL,SAAS;YACT,UAAU,IAAI,SAAS,MAAM;gBAAE,QAAQ;YAAI;QAC7C;IACF;;;AAGF,EAEA,qDAAqD;CACrD,mDAAmD","debugId":null}},
    {"offset": {"line": 161, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n        \"icon-sm\": \"size-8\",\n        \"icon-lg\": \"size-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  type = \"button\",\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      type={Comp === \"button\" ? type : undefined}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;;;AACA;AACA;AAEA;;;;;AAEA,MAAM,iBAAiB,IAAA,0KAAG,EACxB,+bACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,SACE;YACF,WACE;YACF,OACE;YACF,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;YACN,WAAW;YACX,WAAW;QACb;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AAGF,SAAS,OAAO,EACd,SAAS,EACT,OAAO,EACP,IAAI,EACJ,UAAU,KAAK,EACf,OAAO,QAAQ,EACf,GAAG,OAIF;IACD,MAAM,OAAO,UAAU,2KAAI,GAAG;IAE9B,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,IAAA,qIAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QACxD,MAAM,SAAS,WAAW,OAAO;QAChC,GAAG,KAAK;;;;;;AAGf;KArBS","debugId":null}},
    {"offset": {"line": 227, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/select.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AANA;;;;;;AAQA,MAAM,SAAS,6KAAoB;AAEnC,MAAM,cAAc,8KAAqB;AAEzC,MAAM,cAAc,8KAAqB;AAEzC,MAAM,8BAAgB,2KAAgB,MAGpC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,6LAAC,gLAAuB;QACtB,KAAK;QACL,WAAW,IAAA,qIAAE,EACX,mTACA;QAED,GAAG,KAAK;;YAER;0BACD,6LAAC,6KAAoB;gBAAC,OAAO;0BAC3B,cAAA,6LAAC,sOAAW;oBAAC,WAAU;;;;;;;;;;;;;;;;;;AAI7B,cAAc,WAAW,GAAG,gLAAuB,CAAC,WAAW;AAE/D,MAAM,qCAAuB,2KAAgB,CAG3C,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,uLAA8B;QAC7B,KAAK;QACL,WAAW,IAAA,qIAAE,EACX,wDACA;QAED,GAAG,KAAK;kBAET,cAAA,6LAAC,gOAAS;YAAC,WAAU;;;;;;;;;;;MAZnB;AAeN,qBAAqB,WAAW,GAAG,uLAA8B,CAAC,WAAW;AAE7E,MAAM,uCAAyB,2KAAgB,CAG7C,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,yLAAgC;QAC/B,KAAK;QACL,WAAW,IAAA,qIAAE,EACX,wDACA;QAED,GAAG,KAAK;kBAET,cAAA,6LAAC,sOAAW;YAAC,WAAU;;;;;;;;;;;MAZrB;AAeN,uBAAuB,WAAW,GAChC,yLAAgC,CAAC,WAAW;AAE9C,MAAM,8BAAgB,2KAAgB,OAGpC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,WAAW,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACzD,6LAAC,+KAAsB;kBACrB,cAAA,6LAAC,gLAAuB;YACtB,KAAK;YACL,WAAW,IAAA,qIAAE,EACX,ucACA,aAAa,YACX,mIACF;YAEF,UAAU;YACT,GAAG,KAAK;;8BAET,6LAAC;;;;;8BACD,6LAAC,iLAAwB;oBACvB,WAAW,IAAA,qIAAE,EACX,OACA,aAAa,YACX;8BAGH;;;;;;8BAEH,6LAAC;;;;;;;;;;;;;;;;;AAIP,cAAc,WAAW,GAAG,gLAAuB,CAAC,WAAW;AAE/D,MAAM,4BAAc,2KAAgB,OAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,8KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,qIAAE,EAAC,0CAA0C;QACvD,GAAG,KAAK;;;;;;;AAGb,YAAY,WAAW,GAAG,8KAAqB,CAAC,WAAW;AAE3D,MAAM,2BAAa,2KAAgB,OAGjC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,6LAAC,6KAAoB;QACnB,KAAK;QACL,WAAW,IAAA,qIAAE,EACX,6NACA;QAED,GAAG,KAAK;;0BAET,6LAAC;gBAAK,WAAU;0BACd,cAAA,6LAAC,sLAA6B;8BAC5B,cAAA,6LAAC,gNAAK;wBAAC,WAAU;;;;;;;;;;;;;;;;0BAIrB,6LAAC,iLAAwB;0BAAE;;;;;;;;;;;;;AAG/B,WAAW,WAAW,GAAG,6KAAoB,CAAC,WAAW;AAEzD,MAAM,gCAAkB,2KAAgB,QAGtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,kLAAyB;QACxB,KAAK;QACL,WAAW,IAAA,qIAAE,EAAC,4BAA4B;QACzC,GAAG,KAAK;;;;;;;AAGb,gBAAgB,WAAW,GAAG,kLAAyB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 450, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/textarea.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Textarea({ className, ...props }: React.ComponentProps<\"textarea\">) {\n  return (\n    <textarea\n      data-slot=\"textarea\"\n      className={cn(\n        \"border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Textarea }\n"],"names":[],"mappings":";;;;;AAEA;;;AAEA,SAAS,SAAS,EAAE,SAAS,EAAE,GAAG,OAAyC;IACzE,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,IAAA,qIAAE,EACX,ucACA;QAED,GAAG,KAAK;;;;;;AAGf;KAXS","debugId":null}},
    {"offset": {"line": 480, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        \"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Label }\n"],"names":[],"mappings":";;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,MAAM,EACb,SAAS,EACT,GAAG,OAC8C;IACjD,qBACE,6LAAC,4KAAmB;QAClB,aAAU;QACV,WAAW,IAAA,qIAAE,EACX,uNACA;QAED,GAAG,KAAK;;;;;;AAGf;KAdS","debugId":null}},
    {"offset": {"line": 513, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/application.actions.ts"],"sourcesContent":["// lib/actions/application.actions.ts\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { notFound, redirect } from \"next/navigation\";\nimport { prisma } from \"@/lib/db\";\nimport { AppStatus, AppType, Prisma, AuditAction } from \"@prisma/client\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { applicationSchema, profileSchema } from \"@/lib/zod/applicationSchema\"; // Zod schema\nimport { applicationSchema as newApplicationSchema } from \"@/lib/schemas/application.schema\"; // New Zod schema\nimport { z } from \"zod\";\nimport { assertRole } from \"@/lib/actions/profile.actions\";\nimport { UserRole } from \"@prisma/client\";\nimport { ActionResult, ok, fail } from \"@/lib/types\";\nimport { getAllowedStatuses } from \"@/lib/utils\";\nimport { withAudit } from \"@/lib/audit/withAudit\";\nimport { getCurrentUserId } from \"./audit.actions\";\nimport { getSSRUser } from \"@/lib/auth/session.server\";\nimport { missing } from \"@/lib/format\";\nimport { toCsv } from \"@/lib/csv\";\nimport {\n  AdminApplicationDetail,\n  ApplicationListItem,\n  ApplicationHistoryEntry,\n} from \"@/lib/view-models/applications\";\nimport { parseApplicationSearchParams } from \"@/lib/url-pagination\";\n\nconst updateStatusSchema = z.object({\n  appId: z.coerce.number().int().positive({ message: \"Invalid application ID\" }),\n  status: z.nativeEnum(AppStatus, { message: \"Invalid status\" }),\n  statusNotes: z.string().optional(),\n});\n\nfunction parseApplicationIds(formData: FormData): number[] {\n  const raw = formData.get(\"applicationIds\");\n  if (!raw || typeof raw !== \"string\") return [];\n  return raw\n    .split(\",\")\n    .map(s => s.trim())\n    .filter(Boolean)\n    .map(Number)\n    .filter(Number.isFinite);\n}\n\n\nexport async function createApplication(\n  prevState: ActionResult<null>,\n  formData: FormData\n): Promise<ActionResult<null>> {\n\n  const user = await getSSRUser();\n  if (!user) {\n    // This should never happen if middleware is correct, but it's a good guard.\n    return fail(\"Authentication error. Please log in again.\");\n  }\n\n  // Fetch profile data for snapshot\n  const profile = await prisma.profile.findUnique({\n    where: { id: user.id }\n  });\n  if (!profile) {\n    return fail(\"Profile not found. Please contact support.\");\n  }\n\n  const rawData = Object.fromEntries(formData.entries());\n\n  // Coerce form data for validation\n  const coercedData = {\n    ...rawData,\n    formType: rawData.formType,\n    dogId: rawData.dogId ? Number(rawData.dogId) : undefined,\n    yardFenced: rawData.yardFenced ? rawData.yardFenced === 'on' : undefined,\n    // ... add any other coercions (e.g., references)\n  };\n\n  const result = newApplicationSchema.safeParse(coercedData);\n  if (!result.success) {\n    console.warn(\"Application validation failed:\", result.error.flatten().fieldErrors);\n    return fail(\"Validation failed. Please check your entries.\", result.error.flatten().fieldErrors);\n  }\n\n  const { data } = result;\n\n  try {\n    // Use a transaction. It's the only safe way.\n    await prisma.$transaction(async (tx) => {\n\n      await tx.application.create({\n        data: {\n          applicationType: data.formType,\n          status: 'SUBMITTED',\n          reason: data.reason,\n          dogId: data.dogId,\n          profileId: user.id, // <-- Correct\n          submittedAt: new Date(),\n\n          // --- SNAPSHOT COPY FROM PROFILE ---\n          applicantName: profile.name || 'Unknown',\n          applicantEmail: profile.email,\n          // --- FORM DATA (snapshot of what user provided at submission time) ---\n          applicantPhone: data.applicantPhone,\n          address: data.address,\n          housingType: data.housingType,\n          hasYard: data.hasYard,\n          yardFenced: data.yardFenced,\n          otherPets: data.otherPets,\n          vetName: data.vetName,\n          vetPhone: data.vetPhone,\n          homeEnvironmentDescription: data.homeEnvironmentDescription,\n        }\n      });\n\n      // Create references if provided\n      if (data.references && data.references.length > 0) {\n        // Get the application ID we just created - this is tricky in a transaction\n        // We need to create the application first to get the ID\n        // Let me restructure this...\n\n        // Actually, let me get the application ID after creation\n        // For now, let's create references after the transaction\n      }\n    });\n\n    // Handle references outside transaction for simplicity\n    if (data.references && data.references.length > 0) {\n      // Get the application we just created\n      const createdApplication = await prisma.application.findFirst({\n        where: {\n          profileId: user.id,\n          applicationType: data.formType,\n          status: 'SUBMITTED',\n        },\n        orderBy: { createdAt: 'desc' },\n        select: { id: true },\n      });\n\n      if (createdApplication) {\n        await prisma.reference.createMany({\n          data: data.references.map((ref) => ({\n            ...ref,\n            applicationId: createdApplication.id,\n          })),\n        });\n      }\n    }\n  } catch (error) {\n    console.error(\"Application submission error:\", error);\n    return fail(\"A database error occurred. Please try again.\");\n  }\n\n  // Revalidate admin path and redirect user\n  revalidatePath(\"/admin/applications\");\n  const successPath = data.formType === 'ADOPTER' ? '/apply/adopt/success' : '/apply/foster/success';\n  redirect(successPath);\n}\n\nexport async function submitApplication(formData: FormData): Promise<ActionResult<{ applicationId: number }>> {\n  console.log('submitApplication called with formData keys:', Array.from(formData.keys()));\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) {\n    console.log('submitApplication: user not authenticated');\n    return fail(\"Not authenticated\");\n  }\n  console.log('submitApplication: user authenticated, proceeding with submission');\n\n  try {\n    // Parse form data\n    const formType = formData.get('formType') as AppType;\n    const dogId = formData.get('dogId') ? parseInt(formData.get('dogId') as string) : undefined;\n\n    // Optional: applications can target a specific dog or be general interest applications\n    let validatedDogId: number | undefined;\n    if (dogId !== undefined && dogId !== null) {\n      if (isNaN(dogId) || dogId <= 0) {\n        return fail(\"Invalid dog ID provided.\", { dogId: [\"Must be a valid positive number\"] });\n      }\n      validatedDogId = dogId;\n    }\n\n    // Handle references - parse nested array format from form data\n    const parsedReferences: Array<{ name: string; phone: string; relationship: string }> = [];\n    let index = 0;\n    while (true) {\n      const name = formData.get(`references[${index}][name]`) as string;\n      const phone = formData.get(`references[${index}][phone]`) as string;\n      const relationship = formData.get(`references[${index}][relationship]`) as string;\n\n      if (!name) break; // No more references\n\n      parsedReferences.push({\n        name,\n        phone: phone || '',\n        relationship: relationship || '',\n      });\n      index++;\n    }\n\n    // Extract form fields - separate profile and application data\n    const profileData = {\n      firstName: formData.get('firstName') as string,\n      lastName: formData.get('lastName') as string,\n      email: formData.get('email') as string,\n    };\n\n    const applicantData = {\n      applicantPhone: formData.get('applicantPhone') as string || undefined,\n      address: formData.get('address') as string,\n      housingType: (formData.get('housingType') as 'OWN_HOME' | 'RENT_HOME' | 'OWN_APT_CONDO' | 'RENT_APT_CONDO' | 'OTHER') ?? 'OTHER',\n      hasYard: (formData.get('hasYard') as 'YES' | 'NO' | 'SHARED') ?? 'NO',\n      yardFenced: formData.get('yardFenced') === 'on',\n      otherPets: formData.get('otherPets') as string || undefined,\n      vetName: formData.get('vetName') as string || undefined,\n      vetPhone: formData.get('vetPhone') as string || undefined,\n      homeEnvironmentDescription: formData.get('homeEnvironmentDescription') as string,\n    };\n\n    const applicationData = {\n      reason: formData.get('reason') as string,\n      dogId: validatedDogId,\n      references: parsedReferences,\n      ...applicantData, // Include applicant fields in application data\n    };\n\n    // Validate profile data (only name and email)\n    const validatedProfileData = profileSchema.safeParse(profileData);\n    if (!validatedProfileData.success) {\n      const fieldErrors = validatedProfileData.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // Validate application data (includes applicant fields)\n    const validatedApplicationData = applicationSchema.safeParse(applicationData);\n    if (!validatedApplicationData.success) {\n      const fieldErrors = validatedApplicationData.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // 1. Separate references from the application data.\n    const { references: validatedReferences, ...applicationFields } = validatedApplicationData.data;\n\n    // 2. Use a transaction to ensure data integrity.\n    let app: { id: number } | undefined;\n    await prisma.$transaction(async (tx) => {\n      // 3. Upsert the user's profile with name and email\n      await tx.profile.upsert({\n        where: { id: user.id },\n        update: {\n          name: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n          email: validatedProfileData.data.email,\n        },\n        create: {\n          id: user.id,\n          name: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n          email: validatedProfileData.data.email,\n          role: UserRole.VOLUNTEER, // Default role for new profiles\n        },\n      });\n\n      // 4. Create the application with application-specific data only\n      const applicationData: Prisma.ApplicationCreateInput = {\n        applicationType: formType,\n        profileId: user.id,\n        status: AppStatus.SUBMITTED,\n        submittedAt: new Date(),\n        reason: applicationFields.reason,\n        applicantName: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n        applicantEmail: validatedProfileData.data.email,\n      };\n\n      // Add optional fields if they exist\n      if (applicationFields.dogId !== undefined) applicationData.dog = { connect: { id: applicationFields.dogId } };\n      if (applicationFields.applicantPhone !== undefined) applicationData.applicantPhone = applicationFields.applicantPhone;\n      if (applicationFields.address !== undefined) applicationData.address = applicationFields.address;\n      if (applicationFields.housingType !== undefined) applicationData.housingType = applicationFields.housingType;\n      if (applicationFields.hasYard !== undefined) applicationData.hasYard = applicationFields.hasYard;\n      if (applicationFields.yardFenced !== undefined) applicationData.yardFenced = applicationFields.yardFenced;\n      if (applicationFields.otherPets !== undefined) applicationData.otherPets = applicationFields.otherPets;\n      if (applicationFields.vetName !== undefined) applicationData.vetName = applicationFields.vetName;\n      if (applicationFields.vetPhone !== undefined) applicationData.vetPhone = applicationFields.vetPhone;\n      if (applicationFields.homeEnvironmentDescription !== undefined) applicationData.homeEnvironmentDescription = applicationFields.homeEnvironmentDescription;\n\n      app = await tx.application.create({\n        data: applicationData,\n      });\n\n      // 5. If references exist, create them and link them.\n      if (validatedReferences && validatedReferences.length > 0) {\n        await tx.reference.createMany({\n          data: validatedReferences.map((ref) => ({\n            ...ref,\n            applicationId: app!.id, // Link to the new application\n          })),\n        });\n      }\n    });\n\n    // 6. Revalidate paths\n    revalidatePath(\"/admin/applications\");\n\n    if (!app) {\n      throw new Error(\"Failed to create application\");\n    }\n\n    console.log('submitApplication: application created successfully with ID:', app.id);\n    return ok({ applicationId: app.id }, 'Application submitted successfully!');\n  } catch (error) {\n    console.error(\"Application submission failed:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to submit application.\");\n  }\n}\n\nexport async function updateApplicationStatus(prevState: ActionResult, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n    const userId = await getCurrentUserId();\n\n    const parsed = updateStatusSchema.safeParse(Object.fromEntries(formData.entries()));\n    if (!parsed.success) {\n      const fieldErrors = parsed.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    const { appId, status, statusNotes } = parsed.data;\n\n    // Get current application to validate status transition\n    const currentApplication = await prisma.application.findUnique({\n      where: { id: appId },\n      select: {\n        status: true,\n        applicationType: true,\n      },\n    });\n\n    if (!currentApplication) {\n      return fail(\"Application not found.\");\n    }\n\n    // Validate that the status transition is allowed (server-side enforcement)\n    const allowedStatuses = getAllowedStatuses(currentApplication.applicationType, currentApplication.status);\n    if (!allowedStatuses.includes(status)) {\n      return fail(\"Invalid status transition for this application type.\");\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED\n    if ((status === AppStatus.APPROVED || status === AppStatus.REJECTED) &&\n        (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required when moving to approved or rejected status.\", { statusNotes: [\"Required for terminal status changes\"] });\n    }\n\n    await withAudit(\n      async (tx) => {\n        const application = await tx.application.update({\n          where: { id: appId },\n          data: {\n            status,\n            statusNotes: statusNotes || null,\n          },\n          select: {\n            applicationType: true,\n            profileId: true,\n          },\n        });\n\n        // Write to append-only ApplicationAudit table\n        await tx.applicationAudit.create({\n          data: {\n            applicationId: appId,\n            actorId: userId,\n            oldStatus: currentApplication.status,\n            newStatus: status,\n            note: statusNotes || `Status changed from ${currentApplication.status} to ${status}`,\n          },\n        });\n\n        if (application.applicationType === AppType.FOSTER && status === AppStatus.APPROVED) {\n          await tx.fosterProfile.upsert({\n            where: { profileId: application.profileId },\n            update: {},\n            create: {\n              profileId: application.profileId,\n            },\n          });\n        }\n\n        return application;\n      },\n      {\n        actorId: userId,\n        action: AuditAction.APPLICATION_STATUS_CHANGE,\n        entityType: 'application',\n        entityId: appId,\n        note: `Status changed from ${currentApplication.status} to ${status}`,\n      },\n      prisma\n    );\n\n    revalidatePath(`/admin/applications/${appId}`);\n    revalidatePath(\"/admin/applications\");\n\n    return ok(null, \"Application status updated successfully!\");\n  } catch (error) {\n    return fail(error instanceof Error ? error.message : \"Failed to update status\");\n  }\n}\n\nexport async function getApplicationById(id: number): Promise<AdminApplicationDetail> {\n  const parsed = z.object({ id: z.coerce.number().int().positive() }).safeParse({ id });\n  if (!parsed.success) {\n    throw new Error(\"Invalid application ID\");\n  }\n\n  const application = await prisma.application.findUnique({\n    where: { id },\n    select: {\n      id: true,\n      createdAt: true,\n      updatedAt: true,\n      applicationType: true,\n      status: true,\n      statusNotes: true,\n      profileId: true,\n      applicantName: true,\n      applicantEmail: true,\n      applicantPhone: true,\n      address: true,\n      housingType: true,\n      hasYard: true,\n      yardFenced: true,\n      otherPets: true,\n      vetName: true,\n      vetPhone: true,\n      homeEnvironmentDescription: true,\n      reason: true,\n      references: true,\n      dog: {\n        select: {\n          id: true,\n          name: true,\n          status: true,\n          bioPublic: true,\n        },\n      },\n    },\n  });\n  if (!application) notFound();\n\n  // 2. DELETE ALL JSON.parse logic. It's not needed.\n  // const formData = JSON.parse(application.formDataJson);\n  // return { ...application, formData };\n\n  // Decrypt PII fields from profile before returning\n\n  return {\n    ...application,\n    housingTypeLabel: application.housingType || \"Not specified\",\n    hasYardLabel:\n      application.hasYard === \"YES\"\n        ? \"Yes\"\n        : application.hasYard === \"NO\"\n        ? \"No\"\n        : application.hasYard === \"SHARED\"\n        ? \"Shared\"\n        : \"Not specified\",\n    yardFencedLabel:\n      application.yardFenced === true\n        ? \"Yes\"\n        : application.yardFenced === false\n        ? \"No\"\n        : \"Not specified\",\n    otherPetsLabel: application.otherPets || \"Not specified\",\n    homeEnvironmentDescriptionLabel: application.homeEnvironmentDescription || \"Not specified\",\n  };\n}\n\nexport async function getAllApplications(searchParams?: { [key: string]: string | undefined }): Promise<{\n    applications: ApplicationListItem[];\n    pagination: {\n        currentPage: number;\n        totalPages: number;\n        totalCount: number;\n        hasNextPage: boolean;\n        hasPreviousPage: boolean;\n    };\n}> {\n    await assertRole(UserRole.STAFF);\n\n    // Parse and validate search parameters using shared helper\n    const validatedParams = parseApplicationSearchParams(searchParams || {});\n\n    // Validate status filter\n    if (validatedParams.status && validatedParams.status !== \"all\") {\n        if (!Object.values(AppStatus).includes(validatedParams.status as AppStatus)) {\n            throw new Error(`Invalid status filter: ${validatedParams.status}`);\n        }\n    }\n\n    // Validate type filter\n    if (validatedParams.type && validatedParams.type !== \"all\") {\n        if (!Object.values(AppType).includes(validatedParams.type as AppType)) {\n            throw new Error(`Invalid type filter: ${validatedParams.type}`);\n        }\n    }\n\n    const offset = (validatedParams.page - 1) * validatedParams.limit;\n\n    // Build where clause for filtering\n    const where: Prisma.ApplicationWhereInput = {};\n\n    if (validatedParams.status && validatedParams.status !== \"all\") {\n        where.status = validatedParams.status as AppStatus;\n    }\n\n    if (validatedParams.type && validatedParams.type !== \"all\") {\n        where.applicationType = validatedParams.type as AppType;\n    }\n\n    if (validatedParams.search) {\n        where.OR = [\n            {\n                applicantName: {\n                    contains: validatedParams.search,\n                    mode: \"insensitive\"\n                }\n            },\n            {\n                applicantEmail: {\n                    contains: validatedParams.search,\n                    mode: \"insensitive\"\n                }\n            }\n        ];\n    }\n\n    const [applications, totalCount] = await Promise.all([\n        prisma.application.findMany({\n            where,\n            select: {\n                id: true,\n                createdAt: true,\n                updatedAt: true,\n                applicationType: true,\n                status: true,\n                applicantName: true,\n                applicantEmail: true,\n                reason: true,\n                dog: {\n                    select: {\n                        id: true,\n                        name: true,\n                        status: true,\n                    },\n                },\n            },\n            orderBy: { [validatedParams.sortBy]: validatedParams.sortOrder },\n            skip: offset,\n            take: validatedParams.limit,\n        }),\n        prisma.application.count({ where }),\n    ]);\n\n    const totalPages = Math.ceil(totalCount / validatedParams.limit);\n\n    return {\n        applications: applications as ApplicationListItem[],\n        pagination: {\n            currentPage: validatedParams.page,\n            totalPages,\n            totalCount,\n            hasNextPage: validatedParams.page < totalPages,\n            hasPreviousPage: validatedParams.page > 1,\n        },\n    };\n}\n\nexport async function getUserApplications(profileId: string) {\n    const parsed = z.object({ profileId: z.string().uuid() }).safeParse({ profileId });\n    if (!parsed.success) {\n        throw new Error(\"Invalid profile ID\");\n    }\n\n    const applications = await prisma.application.findMany({\n        where: { profileId },\n        include: {\n            references: true,\n        },\n        orderBy: { createdAt: 'desc' }\n    });\n\n    return applications;\n}\n\n// Form action wrapper for updateApplicationStatus\nexport async function updateApplicationStatusForm(formData: FormData) {\n  return updateApplicationStatus(ok(null), formData);\n}\n\nconst bulkUpdateSchema = z.object({\n  appIds: z.array(z.coerce.number().int().positive({ message: \"Invalid application ID\" })),\n  status: z.nativeEnum(AppStatus, { message: \"Invalid status\" }),\n  statusNotes: z.string().optional(),\n});\n\nexport async function bulkUpdateApplicationStatus(\n  appIds: number[],\n  status: AppStatus,\n  statusNotes?: string\n): Promise<ActionResult<{ ok: number[]; failed: { id: number; reason: string }[] }>> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = bulkUpdateSchema.safeParse({ appIds, status, statusNotes });\n    if (!parsed.success) {\n      const fieldErrors = parsed.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED/WITHDRAWN\n    const requiresNotes: AppStatus[] = [AppStatus.APPROVED, AppStatus.REJECTED, AppStatus.WITHDRAWN]\n    if (requiresNotes.includes(status) && (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required when moving to approved, rejected, or withdrawn status.\", { statusNotes: [\"Required for terminal status changes\"] });\n    }\n\n    // Get current user for authentication\n    const supabase = await createClient();\n    const { data: { user: updater } } = await supabase.auth.getUser();\n    if (!updater) {\n      return fail(\"Authentication required.\");\n    }\n\n    // Get updater's role from database\n    const updaterProfile = await prisma.profile.findUnique({\n      where: { id: updater.id },\n      select: { role: true },\n    });\n\n    if (!updaterProfile || (updaterProfile.role !== UserRole.ADMIN && updaterProfile.role !== UserRole.STAFF)) {\n      return fail(\"Insufficient permissions.\");\n    }\n\n    // Get current applications to validate status transitions\n    const currentApplications = await prisma.application.findMany({\n      where: { id: { in: appIds } },\n      select: {\n        id: true,\n        status: true,\n        applicationType: true,\n      },\n    });\n\n    const appMap = new Map(currentApplications.map(app => [app.id, app]));\n    const successfulIds: number[] = [];\n    const failed: { id: number; reason: string }[] = [];\n\n    // Validate each transition and collect failures\n    for (const appId of appIds) {\n      const currentApp = appMap.get(appId);\n      if (!currentApp) {\n        failed.push({ id: appId, reason: \"Application not found\" });\n        continue;\n      }\n\n      // Validate that the status transition is allowed\n      const allowedStatuses = getAllowedStatuses(currentApp.applicationType, currentApp.status);\n      if (!allowedStatuses.includes(status)) {\n        failed.push({\n          id: appId,\n          reason: `Invalid status transition from ${currentApp.status} for ${currentApp.applicationType} application`\n        });\n        continue;\n      }\n\n      successfulIds.push(appId);\n    }\n\n    // Update successful applications and write audit records\n    if (successfulIds.length > 0) {\n      await prisma.$transaction(async (tx) => {\n        // Update applications\n        await tx.application.updateMany({\n          where: { id: { in: successfulIds } },\n          data: {\n            status,\n            statusNotes: statusNotes || null,\n          },\n        });\n\n        // Write to append-only ApplicationAudit table for each updated application\n        await tx.applicationAudit.createMany({\n          data: successfulIds.map(appId => {\n            const currentApp = appMap.get(appId)!;\n            return {\n              applicationId: appId,\n              actorId: updater.id,\n              oldStatus: currentApp.status,\n              newStatus: status,\n              note: statusNotes || `Bulk status change from ${currentApp.status} to ${status}`,\n            };\n          }),\n        });\n      });\n\n      // Revalidate on success\n      revalidatePath(\"/admin/applications\");\n    }\n\n    return ok({ ok: successfulIds, failed }, `Updated ${successfulIds.length} application${successfulIds.length !== 1 ? 's' : ''} successfully${failed.length > 0 ? `, ${failed.length} failed` : ''}.`);\n  } catch (error) {\n    return fail(error instanceof Error ? error.message : \"An unexpected error occurred.\");\n  }\n}\n\nexport async function getApplicationHistory(applicationId: number): Promise<ApplicationHistoryEntry[]> {\n  await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n  const history = await prisma.applicationAudit.findMany({\n    where: { applicationId },\n    select: {\n      id: true,\n      applicationId: true,\n      oldStatus: true,\n      newStatus: true,\n      note: true,\n      createdAt: true,\n      actor: {\n        select: {\n          name: true,\n          email: true,\n        },\n      },\n    },\n    orderBy: { createdAt: \"desc\" },\n  });\n\n  return history as ApplicationHistoryEntry[];\n}\n\n// Server actions for useActionState (form-based)\nexport async function bulkAssignApplications(\n  prevState: ActionResult,\n  formData: FormData\n): Promise<ActionResult> {\n  try {\n    await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n    const applicationIds = formData.getAll(\"applicationIds\").map(id => parseInt(id as string));\n    const staffId = formData.get(\"staffId\") as string;\n\n    if (!staffId || applicationIds.length === 0) {\n      return fail(\"Staff member and applications are required\");\n    }\n\n    // Verify staff user exists\n    const staffUser = await prisma.profile.findUnique({\n      where: { id: staffId },\n      select: { id: true, role: true },\n    });\n\n    if (!staffUser || (staffUser.role !== UserRole.STAFF && staffUser.role !== UserRole.ADMIN)) {\n      return fail(\"Invalid staff member selected\");\n    }\n\n    // Perform bulk update\n    const updateResult = await prisma.application.updateMany({\n      where: {\n        id: { in: applicationIds },\n      },\n      data: {\n        assignedToUserId: staffId,\n        updatedAt: new Date(),\n      },\n    });\n\n    revalidatePath(\"/admin/applications\");\n\n    return ok(null, `Successfully assigned ${updateResult.count} application(s)`);\n\n  } catch (error) {\n    console.error(\"Bulk assign error:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to assign applications\");\n  }\n}\n\nexport async function bulkUpdateApplications(\n  prevState: ActionResult<{ failed?: { id: number; reason: string }[] }>,\n  formData: FormData\n): Promise<ActionResult<{ failed?: { id: number; reason: string }[] }>> {\n  try {\n    await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n    const applicationIds = parseApplicationIds(formData);\n    const status = formData.get(\"status\") as AppStatus;\n    const statusNotes = formData.get(\"statusNotes\") as string;\n\n    if (applicationIds.length === 0) {\n      return fail(\"No applications selected\");\n    }\n\n    if (!status) {\n      return fail(\"Status is required\");\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED/WITHDRAWN\n    const requiresNotes: AppStatus[] = [AppStatus.APPROVED, AppStatus.REJECTED, AppStatus.WITHDRAWN];\n    if (requiresNotes.includes(status) && (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required for terminal status changes\");\n    }\n\n    const result = await bulkUpdateApplicationStatus(\n      applicationIds,\n      status,\n      statusNotes?.trim() || undefined\n    );\n\n    if (result.success) {\n      const successCount = result.data?.ok.length || 0;\n\n      revalidatePath(\"/admin/applications\");\n\n      return ok({ failed: result.data?.failed }, `Successfully updated ${successCount} application(s)`);\n    } else {\n      return fail(result.message || \"Bulk update failed\");\n    }\n\n  } catch (error) {\n    console.error(\"Bulk update error:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to update applications\");\n  }\n}\n\nexport async function exportApplicationsCSV(\n  searchParams: { [key: string]: string | undefined },\n  minimal: boolean\n): Promise<{ success: true; csvData: string; filename: string } | { success: false; message: string }> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const filters = { ...searchParams };\n    delete filters.minimal; // Remove minimal param from filters\n\n    const appData = await getAllApplications(filters);\n    const applications: ApplicationListItem[] = appData.applications;\n\n    // Guard against exporting insane data sets\n    const MAX_EXPORT_ROWS = 10000;\n    if (applications.length > MAX_EXPORT_ROWS) {\n      return {\n        success: false,\n        message: `Export too large: ${applications.length} applications found, maximum allowed is ${MAX_EXPORT_ROWS}. Please apply filters to reduce the dataset size.`\n      };\n    }\n\n    // Generate CSV data\n    let csvData: Record<string, unknown>[];\n    let csvHeaders: string[];\n\n    if (minimal) {\n      // Minimal export: no PII (phone/address)\n      csvData = applications.map(app => ({\n        id: app.id,\n        submitted_date: app.createdAt.toISOString().split('T')[0],\n        name: missing(app.applicantName, 'Unknown'),\n        email: missing(app.applicantEmail, 'Unknown'),\n        type: app.applicationType,\n        status: app.status,\n        dog_name: app.dog?.name || '',\n        reason: app.reason,\n      }));\n      csvHeaders = [\n        'ID', 'Submitted Date', 'Name', 'Email', 'Type', 'Status',\n        'Dog Name', 'Reason'\n      ];\n    } else {\n      // Full export with available fields\n      csvData = applications.map(app => ({\n        id: app.id,\n        submitted_date: app.createdAt.toISOString().split('T')[0],\n        name: missing(app.applicantName, 'Unknown'),\n        email: missing(app.applicantEmail, 'Unknown'),\n        type: app.applicationType,\n        status: app.status,\n        dog_name: app.dog?.name || '',\n        reason: app.reason,\n      }));\n      csvHeaders = [\n        'ID', 'Submitted Date', 'Name', 'Email', 'Type', 'Status',\n        'Dog Name', 'Reason'\n      ];\n    }\n\n    const csvWithBOM = toCsv(csvData, csvHeaders);\n    const filename = `applications-${new Date().toISOString().split('T')[0]}${minimal ? '-minimal' : ''}.csv`;\n\n    return {\n      success: true,\n      csvData: csvWithBOM,\n      filename\n    };\n  } catch (error) {\n    console.error('CSV export error:', error);\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : 'Failed to generate export'\n    };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IAwTsB,0BAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 528, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/types.ts"],"sourcesContent":["// lib/types.ts\n\n/**\n * Result type for server actions - follows Railway-oriented programming pattern\n */\nexport type Result<T, E = Error> = { success: true; data: T } | { success: false; error: E };\n\n/**\n * Canonical action result type for server actions\n */\nexport type ActionResult<T = null> = {\n  data: T | null;\n  success: boolean;\n  message: string | null;\n  fieldErrors?: Record<string, string[]>;\n};\n\n/**\n * Helper constructor for successful ActionResult\n */\nexport function ok<T = null>(data: T, message: string | null = null): ActionResult<T> {\n  return {\n    success: true,\n    message,\n    data,\n    fieldErrors: undefined,\n  };\n}\n\n/**\n * Helper constructor for failed ActionResult\n */\nexport function fail<T = null>(message: string, fieldErrors?: Record<string, string[]>): ActionResult<T> {\n  return {\n    success: false,\n    message,\n    data: null,\n    fieldErrors,\n  } as ActionResult<T>;\n}\n\n/**\n * Helper constructor for ActionResult with default values\n */\nexport function makeActionResult<T>(overrides?: Partial<ActionResult<T>>): ActionResult<T> {\n  return {\n    success: false,\n    message: null,\n    data: null,\n    fieldErrors: undefined,\n    ...overrides,\n  };\n}\n\n/**\n * Canonical dog list item for admin tables and listings\n */\nexport interface DogListItem {\n  id: number;\n  mutt_id: string | null;\n  name: string;\n  breed: string | null;\n  dateOfBirth: Date | null;\n  gender: import(\"@prisma/client\").Gender | null;\n  size: import(\"@prisma/client\").DogSize | null;\n  weight_lbs: number | null;\n  primaryPhotoUrl: string | null;\n  specialNeeds: boolean;\n  bioPublic: string | null;\n  status: import(\"@prisma/client\").DogStatus;\n  fosterProfile?: {\n    name: string | null;\n    email: string;\n  } | null;\n}\n\n/**\n * Public dog list item for adopt page with derived fields\n */\nexport interface PublicDogListItem extends Omit<DogListItem, 'gender' | 'mutt_id'> {\n  gender: import(\"@prisma/client\").Gender;\n  mutt_id: string | null;\n  isSenior: boolean;\n  hasPhotos: boolean;\n}\n\n/**\n * Canonical pagination metadata\n */\nexport interface PaginationMeta {\n  currentPage: number;\n  totalPages: number;\n  totalCount: number;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n}\n"],"names":[],"mappings":"AAAA,eAAe;AAEf;;CAEC;;;;;;;;AAgBM,SAAS,GAAa,IAAO,EAAE,UAAyB,IAAI;IACjE,OAAO;QACL,SAAS;QACT;QACA;QACA,aAAa;IACf;AACF;AAKO,SAAS,KAAe,OAAe,EAAE,WAAsC;IACpF,OAAO;QACL,SAAS;QACT;QACA,MAAM;QACN;IACF;AACF;AAKO,SAAS,iBAAoB,SAAoC;IACtE,OAAO;QACL,SAAS;QACT,SAAS;QACT,MAAM;QACN,aAAa;QACb,GAAG,SAAS;IACd;AACF","debugId":null}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/applications/%5Bid%5D/ApplicationStatusEditor.tsx"],"sourcesContent":["\"use client\";\n\nimport { useActionState, useState } from \"react\";\nimport { AppStatus } from \"@prisma/client\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Label } from \"@/components/ui/label\";\nimport { updateApplicationStatus } from \"@/lib/actions/application.actions\";\nimport { humanizeEnum, getAllowedStatuses, areStatusNotesRequired } from \"@/lib/utils\";\nimport { makeActionResult } from \"@/lib/types\";\nimport type { AdminApplicationDetail } from \"@/lib/view-models/applications\";\n\ninterface ApplicationStatusEditorProps {\n  application: Pick<AdminApplicationDetail, \"id\" | \"status\" | \"applicationType\" | \"statusNotes\">;\n}\n\nexport default function ApplicationStatusEditor({ application }: ApplicationStatusEditorProps) {\n  const [state, formAction] = useActionState(updateApplicationStatus, makeActionResult());\n  const [selectedStatus, setSelectedStatus] = useState<AppStatus>(application.status);\n\n  // Get available status options based on application type\n  const availableStatuses = getAllowedStatuses(application.applicationType, application.status);\n\n  // Check if notes are required for the selected status\n  const requiresNotes = areStatusNotesRequired(selectedStatus);\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <form action={formAction} className=\"space-y-4\">\n        <input type=\"hidden\" name=\"appId\" value={application.id} />\n\n        <div className=\"space-y-2\">\n          <Label htmlFor=\"status\">Status</Label>\n          <Select\n            name=\"status\"\n            defaultValue={application.status}\n            onValueChange={(value) => setSelectedStatus(value as AppStatus)}\n            data-testid=\"select-status\"\n          >\n            <SelectTrigger className=\"w-[180px]\">\n              <SelectValue />\n            </SelectTrigger>\n            <SelectContent>\n              {availableStatuses.map(s => (\n                <SelectItem key={s} value={s}>\n                  {humanizeEnum(s)}\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n        </div>\n\n        <div className=\"space-y-2\">\n          <Label htmlFor=\"statusNotes\">\n            Status Change Notes {requiresNotes ? \"(Required)\" : \"(Optional)\"}\n          </Label>\n          <Textarea\n            id=\"statusNotes\"\n            name=\"statusNotes\"\n            placeholder=\"Add notes about this status change for audit purposes...\"\n            defaultValue={application.statusNotes || \"\"}\n            rows={3}\n            required={requiresNotes}\n            data-testid=\"textarea-notes\"\n          />\n        </div>\n\n        <Button type=\"submit\" disabled={state.success} data-testid=\"btn-change-status\">\n          {state.success ? \"Status Updated\" : \"Update Status\"}\n        </Button>\n      </form>\n\n      {/* Show messages */}\n      {state.message && (\n        <p className={state.success ? \"text-green-600\" : \"text-red-500\"}>\n          {state.message}\n        </p>\n      )}\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AAEA;AACA;AAOA;AACA;AACA;AACA;AAAA;AACA;;;AAhBA;;;;;;;;;AAuBe,SAAS,wBAAwB,EAAE,WAAW,EAAgC;;IAC3F,MAAM,CAAC,OAAO,WAAW,GAAG,IAAA,+KAAc,EAAC,oLAAuB,EAAE,IAAA,mIAAgB;IACpF,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,yKAAQ,EAAY,YAAY,MAAM;IAElF,yDAAyD;IACzD,MAAM,oBAAoB,IAAA,8IAAkB,EAAC,YAAY,eAAe,EAAE,YAAY,MAAM;IAE5F,sDAAsD;IACtD,MAAM,gBAAgB,IAAA,kJAAsB,EAAC;IAE7C,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC;gBAAK,QAAQ;gBAAY,WAAU;;kCAClC,6LAAC;wBAAM,MAAK;wBAAS,MAAK;wBAAQ,OAAO,YAAY,EAAE;;;;;;kCAEvD,6LAAC;wBAAI,WAAU;;0CACb,6LAAC,sIAAK;gCAAC,SAAQ;0CAAS;;;;;;0CACxB,6LAAC,wIAAM;gCACL,MAAK;gCACL,cAAc,YAAY,MAAM;gCAChC,eAAe,CAAC,QAAU,kBAAkB;gCAC5C,eAAY;;kDAEZ,6LAAC,+IAAa;wCAAC,WAAU;kDACvB,cAAA,6LAAC,6IAAW;;;;;;;;;;kDAEd,6LAAC,+IAAa;kDACX,kBAAkB,GAAG,CAAC,CAAA,kBACrB,6LAAC,4IAAU;gDAAS,OAAO;0DACxB,IAAA,wIAAY,EAAC;+CADC;;;;;;;;;;;;;;;;;;;;;;kCAQzB,6LAAC;wBAAI,WAAU;;0CACb,6LAAC,sIAAK;gCAAC,SAAQ;;oCAAc;oCACN,gBAAgB,eAAe;;;;;;;0CAEtD,6LAAC,4IAAQ;gCACP,IAAG;gCACH,MAAK;gCACL,aAAY;gCACZ,cAAc,YAAY,WAAW,IAAI;gCACzC,MAAM;gCACN,UAAU;gCACV,eAAY;;;;;;;;;;;;kCAIhB,6LAAC,wIAAM;wBAAC,MAAK;wBAAS,UAAU,MAAM,OAAO;wBAAE,eAAY;kCACxD,MAAM,OAAO,GAAG,mBAAmB;;;;;;;;;;;;YAKvC,MAAM,OAAO,kBACZ,6LAAC;gBAAE,WAAW,MAAM,OAAO,GAAG,mBAAmB;0BAC9C,MAAM,OAAO;;;;;;;;;;;;AAKxB;GAhEwB;;QACM,+KAAc;;;KADpB","debugId":null}},
    {"offset": {"line": 754, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ClientTimestamp.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState } from \"react\";\n\ninterface ClientTimestampProps {\n  date: string; // ISO date string\n  options?: Intl.DateTimeFormatOptions;\n}\n\nexport function ClientTimestamp({ date, options }: ClientTimestampProps) {\n  const [formatted, setFormatted] = useState<string>(\"\");\n\n  useEffect(() => {\n    const dateObj = new Date(date);\n    setFormatted(dateObj.toLocaleDateString(undefined, options));\n  }, [date, options]);\n\n  return <span>{formatted}</span>;\n}\n"],"names":[],"mappings":";;;;;AAEA;;;AAFA;;AASO,SAAS,gBAAgB,EAAE,IAAI,EAAE,OAAO,EAAwB;;IACrE,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAS;IAEnD,IAAA,0KAAS;qCAAC;YACR,MAAM,UAAU,IAAI,KAAK;YACzB,aAAa,QAAQ,kBAAkB,CAAC,WAAW;QACrD;oCAAG;QAAC;QAAM;KAAQ;IAElB,qBAAO,6LAAC;kBAAM;;;;;;AAChB;GATgB;KAAA","debugId":null}}]
}