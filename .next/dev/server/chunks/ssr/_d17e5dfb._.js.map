{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/profile.actions.ts"],"sourcesContent":["// lib/actions/profile.actions.ts\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { prisma } from \"@/lib/prisma\";\nimport { UserRole } from \"@prisma/client\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { z } from \"zod\";\nimport { ActionResult } from \"@/lib/types\";\n\nconst createProfileSchema = z.object({\n  name: z.string().optional(),\n});\n\n\n// Add this new function\nexport async function getActingUser(\n  { requireAuth = true }: { requireAuth?: boolean } = {}\n) {\n  // Check for synthetic session headers first (set by middleware)\n  const { headers } = await import('next/headers');\n  const headerData = await headers();\n  const testUserId = headerData.get('x-test-user-id');\n  const testUserRole = headerData.get('x-test-user-role');\n\n  if (testUserId && testUserRole) {\n    // Return a mock/partial User object based on headers\n    return {\n      id: testUserId,\n      email: `test-${testUserRole.toLowerCase()}@example.test`,\n      app_metadata: { role: testUserRole as UserRole },\n    } as {\n      id: string;\n      email: string;\n      app_metadata: { role: UserRole };\n    };\n  }\n\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n\n  if (requireAuth && !user) {\n    redirect(\"/auth/login\");\n  }\n  return user;\n}\n\n// Add this new function\nexport async function requireRole(role: UserRole | UserRole[]) {\n  const user = await getActingUser();\n  if (!user) {\n    // This should be redundant due to getActingUser, but good for type safety\n    throw new Error(\"Authentication required.\");\n  }\n\n  const roles = Array.isArray(role) ? role : [role];\n  const userRole = await getActingUserRole(); // Assumes this queries the DB\n\n  // Role hierarchy: ADMIN can access everything\n  if (userRole === UserRole.ADMIN) {\n    return; // Admin has access to everything\n  }\n\n  if (!roles.includes(userRole)) {\n    throw new Error(\"Unauthorized.\");\n  }\n}\n\n// Defense-in-depth RBAC helper - throws on unauthorized access\nexport async function assertRole(requiredRoles: UserRole | UserRole[]): Promise<void> {\n  const user = await getActingUser();\n  if (!user) {\n    throw new Error(\"Authentication required.\");\n  }\n\n  const userRole = await getActingUserRole();\n  const roles = Array.isArray(requiredRoles) ? requiredRoles : [requiredRoles];\n\n  // ADMIN can access everything\n  if (userRole === UserRole.ADMIN) {\n    return;\n  }\n\n  if (!roles.includes(userRole)) {\n    throw new Error(\"Insufficient permissions.\");\n  }\n}\n\nexport async function createProfile(name: string) {\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) { throw new Error(\"User not authenticated.\"); }\n\n  const parsed = createProfileSchema.safeParse({ name });\n  if (!parsed.success) {\n    throw new Error(parsed.error.issues[0]?.message ?? \"Invalid name\");\n  }\n\n  await prisma.profile.upsert({\n     where: { id: user.id },\n     update: { name: parsed.data.name, email: user.email }, // Update name/email if they exist\n     create: { id: user.id, email: user.email!, name: parsed.data.name },\n  });\n}\n\nexport async function updateUserRole(prevState: ActionResult, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.ADMIN);\n\n    const userId = formData.get('userId') as string;\n    const role = formData.get('role') as UserRole;\n\n    if (!userId || !role) {\n      return {\n        success: false,\n        message: \"Missing required fields\",\n        fieldErrors: undefined,\n        data: null,\n      };\n    }\n\n    // Protect \"last admin\" from demotion\n    const adminCount = await prisma.profile.count({ where: { role: 'ADMIN' } });\n    const user = await prisma.profile.findUnique({ where: { id: userId }, select: { role: true } });\n    if (!user) {\n      return {\n        success: false,\n        message: 'User not found',\n        fieldErrors: { userId: ['User not found'] },\n        data: null,\n      };\n    }\n    if (user.role === 'ADMIN' && role !== 'ADMIN' && adminCount <= 1) {\n      return {\n        success: false,\n        message: 'Cannot demote the last admin',\n        fieldErrors: { role: ['Cannot demote the last admin'] },\n        data: null,\n      };\n    }\n\n    await prisma.profile.update({ where: { id: userId }, data: { role } });\n    revalidatePath('/admin/users');\n    return {\n      success: true,\n      message: 'Role updated successfully',\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch {\n    return {\n      success: false,\n      message: \"Failed to update user role\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function getAllUsers() {\n  if (process.env.NODE_ENV !== 'test') {\n    await assertRole(UserRole.ADMIN);\n  }\n  return await prisma.profile.findMany({\n    orderBy: { email: \"asc\" },\n    select: {\n      id: true,\n      name: true,\n      email: true,\n      role: true,\n    },\n  });\n}\n\nexport async function getAllStaffUsers() {\n  if (process.env.NODE_ENV !== 'test') {\n    await assertRole(UserRole.STAFF);\n  }\n  return await prisma.profile.findMany({\n    where: {\n      role: {\n        in: [UserRole.STAFF, UserRole.ADMIN],\n      },\n    },\n    orderBy: { email: \"asc\" },\n    select: {\n      id: true,\n      name: true,\n      email: true,\n    },\n  });\n}\n\nexport async function getActingUserRole(): Promise<UserRole> {\n  // Check for synthetic session headers first (set by middleware)\n  const { headers } = await import('next/headers');\n  const headerData = await headers();\n  const testUserRole = headerData.get('x-test-user-role');\n\n  if (testUserRole && ['ADMIN', 'STAFF', 'VOLUNTEER'].includes(testUserRole)) {\n    return testUserRole as UserRole;\n  }\n\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n\n  if (!user) {\n    throw new Error(\"Not authenticated\");\n  }\n\n  const profile = await prisma.profile.findUnique({\n    where: { id: user.id },\n    select: { role: true },\n  });\n\n  if (!profile) {\n    throw new Error(\"Profile not found\");\n  }\n\n  return profile.role;\n}\n\nexport async function getUserProfile(userId: string) {\n  // Ensure user can only view their own profile (skip in test environment)\n  if (process.env.NODE_ENV !== 'test') {\n    const currentUser = await getActingUser();\n    if (!currentUser || currentUser.id !== userId) {\n      throw new Error(\"Unauthorized: Can only view your own profile\");\n    }\n  }\n\n  const parsed = z.object({ userId: z.string() }).safeParse({ userId });\n  if (!parsed.success) {\n    throw new Error(\"Invalid user ID\");\n  }\n\n  const profile = await prisma.profile.findUnique({\n    where: { id: userId },\n    select: {\n      name: true,\n      email: true,\n      role: true,\n      trainingCompleted: true,\n      backgroundCheckCompleted: true,\n      shiftCapacity: true,\n      prefersWeekdays: true,\n      prefersMornings: true,\n    },\n  });\n\n  // Return null if profile doesn't exist\n  return profile;\n}\n\nexport async function getUserSignupIds(userId: string) {\n  // Ensure user can only view their own signup IDs (skip in test environment)\n  if (process.env.NODE_ENV !== 'test') {\n    const currentUser = await getActingUser();\n    if (!currentUser || currentUser.id !== userId) {\n      throw new Error(\"Unauthorized: Can only view your own signups\");\n    }\n  }\n\n  const parsed = z.object({ userId: z.string() }).safeParse({ userId });\n  if (!parsed.success) {\n    throw new Error(\"Invalid user ID\");\n  }\n\n  try {\n    const userSignups = await prisma.volunteerShiftSignup.findMany({\n      where: { volunteerId: userId },\n      select: { shiftId: true }\n    });\n\n    return userSignups.map(signup => signup.shiftId);\n  } catch {\n    // Return empty array on any lookup failure (user doesn't exist, etc.)\n    return [];\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 368, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/zod/applicationSchema.ts"],"sourcesContent":["// lib/schemas/applicationSchema.ts\n\nimport { z } from \"zod\";\n\n// Profile fields (user account data)\nexport const profileSchema = z.object({\n  firstName: z.string().min(1, { message: \"First name is required.\" }),\n  lastName: z.string().min(1, { message: \"Last name is required.\" }),\n  email: z.string().email({ message: \"Please enter a valid email address.\" }),\n});\n\n// Applicant fields (application-specific data - moved from Profile to Application)\nexport const applicantSchema = z.object({\n  // --- Contact Fields ---\n  applicantPhone: z.string().optional(),\n\n  // --- Housing Fields ---\n  address: z.string().min(5, { message: \"Please enter a valid address.\" }),\n  housingType: z.enum([\"OWN_HOME\", \"RENT_HOME\", \"OWN_APT_CONDO\", \"RENT_APT_CONDO\", \"OTHER\"]),\n  hasYard: z.enum([\"YES\", \"NO\", \"SHARED\"]),\n  yardFenced: z.boolean(),\n  otherPets: z.string().optional(), // Description of other pets\n  vetName: z.string().optional(),\n  vetPhone: z.string().optional(),\n\n  // --- Home Environment Field ---\n  homeEnvironmentDescription: z.string().min(1, { message: \"Please describe your home environment.\" })\n});\n\nexport const applicationSchema = z.object({\n  // --- Application-specific Fields ---\n  reason: z.string().min(10, { message: \"Please provide a reason (min 10 characters).\" }),\n\n  // --- Relation IDs ---\n  dogId: z.number().int().positive().optional(),\n\n  // --- Reference Fields (relational data) ---\n  references: z.array(z.object({\n    name: z.string().min(1, \"Reference name is required.\"),\n    phone: z.string().optional(),\n    relationship: z.string().optional()\n  })).optional(),\n}).merge(applicantSchema.partial()); // Merge applicant fields as optional into application schema\n\nexport type ProfileFormData = z.infer<typeof profileSchema>;\nexport type ApplicationFormData = z.infer<typeof applicationSchema>;\nexport type ApplicantFormData = z.infer<typeof applicantSchema>;\n"],"names":[],"mappings":"AAAA,mCAAmC;;;;;;;;;AAEnC;;AAGO,MAAM,gBAAgB,kLAAC,CAAC,MAAM,CAAC;IACpC,WAAW,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAA0B;IAClE,UAAU,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAyB;IAChE,OAAO,kLAAC,CAAC,MAAM,GAAG,KAAK,CAAC;QAAE,SAAS;IAAsC;AAC3E;AAGO,MAAM,kBAAkB,kLAAC,CAAC,MAAM,CAAC;IACtC,yBAAyB;IACzB,gBAAgB,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAEnC,yBAAyB;IACzB,SAAS,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAgC;IACtE,aAAa,kLAAC,CAAC,IAAI,CAAC;QAAC;QAAY;QAAa;QAAiB;QAAkB;KAAQ;IACzF,SAAS,kLAAC,CAAC,IAAI,CAAC;QAAC;QAAO;QAAM;KAAS;IACvC,YAAY,kLAAC,CAAC,OAAO;IACrB,WAAW,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAC9B,SAAS,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAC5B,UAAU,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAE7B,iCAAiC;IACjC,4BAA4B,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAyC;AACpG;AAEO,MAAM,oBAAoB,kLAAC,CAAC,MAAM,CAAC;IACxC,sCAAsC;IACtC,QAAQ,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI;QAAE,SAAS;IAA+C;IAErF,uBAAuB;IACvB,OAAO,kLAAC,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ,GAAG,QAAQ;IAE3C,6CAA6C;IAC7C,YAAY,kLAAC,CAAC,KAAK,CAAC,kLAAC,CAAC,MAAM,CAAC;QAC3B,MAAM,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QACxB,OAAO,kLAAC,CAAC,MAAM,GAAG,QAAQ;QAC1B,cAAc,kLAAC,CAAC,MAAM,GAAG,QAAQ;IACnC,IAAI,QAAQ;AACd,GAAG,KAAK,CAAC,gBAAgB,OAAO,KAAK,6DAA6D","debugId":null}},
    {"offset": {"line": 436, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/zod/shift.schema.ts"],"sourcesContent":["// lib/schemas/shift.schema.ts\n\nimport { z } from \"zod\";\n\nexport const shiftSchema = z.object({\n  title: z.string().transform(s => s.trim()).refine(Boolean, 'Title required'),\n  description: z.string().optional(),\n  startsAt: z.string().min(1, 'Start time is required')\n    .refine((val) => !isNaN(Date.parse(val)), 'Invalid start time format'),\n  endsAt: z.string().min(1, 'End time is required')\n    .refine((val) => !isNaN(Date.parse(val)), 'Invalid end time format'),\n  capacity: z.preprocess((val) => val === '' || val === null || val === undefined ? null : Number(val), z.number().int().positive().nullable()),\n}).superRefine((v, ctx) => {\n  if (new Date(v.endsAt) <= new Date(v.startsAt)) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      path: ['endsAt'],\n      message: 'Start time must be before end time',\n    })\n  }\n})\n\nexport type ShiftFormData = z.infer<typeof shiftSchema>;\n"],"names":[],"mappings":"AAAA,8BAA8B;;;;;AAE9B;;AAEO,MAAM,cAAc,kLAAC,CAAC,MAAM,CAAC;IAClC,OAAO,kLAAC,CAAC,MAAM,GAAG,SAAS,CAAC,CAAA,IAAK,EAAE,IAAI,IAAI,MAAM,CAAC,SAAS;IAC3D,aAAa,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAChC,UAAU,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,0BACzB,MAAM,CAAC,CAAC,MAAQ,CAAC,MAAM,KAAK,KAAK,CAAC,OAAO;IAC5C,QAAQ,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,wBACvB,MAAM,CAAC,CAAC,MAAQ,CAAC,MAAM,KAAK,KAAK,CAAC,OAAO;IAC5C,UAAU,kLAAC,CAAC,UAAU,CAAC,CAAC,MAAQ,QAAQ,MAAM,QAAQ,QAAQ,QAAQ,YAAY,OAAO,OAAO,MAAM,kLAAC,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ,GAAG,QAAQ;AAC5I,GAAG,WAAW,CAAC,CAAC,GAAG;IACjB,IAAI,IAAI,KAAK,EAAE,MAAM,KAAK,IAAI,KAAK,EAAE,QAAQ,GAAG;QAC9C,IAAI,QAAQ,CAAC;YACX,MAAM,kLAAC,CAAC,YAAY,CAAC,MAAM;YAC3B,MAAM;gBAAC;aAAS;YAChB,SAAS;QACX;IACF;AACF","debugId":null}},
    {"offset": {"line": 464, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/schemas.ts"],"sourcesContent":["import { DogStatus, LogType } from \"@prisma/client\";\nimport { z } from \"zod\";\n\nconst emptyStringToNull = (value: unknown) => {\n  if (value === null || value === undefined) return null;\n  const str = String(value).trim();\n  return str.length > 0 && str !== \"none\" ? str : null;\n};\n\n\nconst checkboxValue = (value: unknown) =>\n  value === true || value === \"true\" || value === \"on\";\n\nexport const dogFormSchema = z.object({\n  name: z.string().min(1, { message: \"Name is required.\" }),\n  status: z.nativeEnum(DogStatus).optional(),\n  breed: z.preprocess(emptyStringToNull, z.string().nullable()),\n  dateOfBirth: z\n    .preprocess((value) => {\n      if (!value || value === '' || typeof value !== 'string' && typeof value !== 'number' && !(value instanceof Date)) return null;\n      const date = new Date(value);\n      return isNaN(date.getTime()) ? null : date;\n    }, z.date().nullable())\n    .nullable(),\n  bioPublic: z.preprocess(emptyStringToNull, z.string().nullable()),\n  notesInternal: z.preprocess(emptyStringToNull, z.string().nullable()),\n  fosterProfileId: z.preprocess((value) => {\n    if (value === null || value === undefined) return null;\n    const str = String(value).trim();\n    if (str.length === 0 || str === \"none\") return null;\n    return str; // Profile ID is a string\n  }, z.string().nullable()),\n  specialNeeds: z.preprocess(checkboxValue, z.boolean()),\n}).refine((data) => {\n  if (data.status === DogStatus.IN_FOSTER) {\n    return data.fosterProfileId !== null && data.fosterProfileId !== undefined && data.fosterProfileId.trim() !== '';\n  }\n  return true;\n}, {\n  message: \"Foster profile is required when status is IN_FOSTER\",\n  path: [\"fosterProfileId\"],\n});\n\nexport type DogFormInput = z.infer<typeof dogFormSchema>;\n\nexport const logEntrySchema = z.object({\n  dogId: z.coerce.number().int().positive({ message: \"Dog ID is required.\" }),\n  logType: z.nativeEnum(LogType),\n  notes: z.preprocess(emptyStringToNull, z.string().nullable()),\n});\n\nexport type LogEntryInput = z.infer<typeof logEntrySchema>;\n\nexport const shiftIdSchema = z.object({\n  shiftId: z\n    .preprocess((value) => {\n      const num = Number(value);\n      return Number.isFinite(num) ? num : Number.NaN;\n    },\n    z\n      .number({ message: \"Invalid shift ID\" })\n      .int({ message: \"Invalid shift ID\" })\n      .positive({ message: \"Invalid shift ID\" })),\n});\n\nexport type ShiftIdInput = z.infer<typeof shiftIdSchema>;\n\nexport const eventFormSchema = z\n  .object({\n    title: z.string().min(1, { message: \"Title is required.\" }),\n    description: z.preprocess(emptyStringToNull, z.string().nullable()),\n    startTime: z.string().min(1, { message: \"Start time is required.\" }),\n    endTime: z.string().min(1, { message: \"End time is required.\" }),\n    location: z.preprocess(emptyStringToNull, z.string().nullable()),\n    capacity: z.preprocess(emptyStringToNull, z.coerce.number().int().positive().nullable()),\n  })\n  .refine(\n    (data) => {\n      const start = Date.parse(data.startTime);\n      const end = Date.parse(data.endTime);\n      return !Number.isNaN(start) && !Number.isNaN(end) && start < end;\n    },\n    {\n      message: \"End time must be after start time.\",\n      path: [\"endTime\"],\n    },\n  );\n\nexport type EventFormInput = z.infer<typeof eventFormSchema>;\n\nexport { applicationSchema } from \"./zod/applicationSchema\";\nexport { shiftSchema } from \"./zod/shift.schema\";\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 565, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/event.actions.ts"],"sourcesContent":["\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { prisma } from \"@/lib/prisma\";\nimport { assertRole } from \"@/lib/actions/profile.actions\";\nimport { UserRole } from \"@prisma/client\";\nimport { ActionResult } from \"@/lib/types\";\nimport { eventFormSchema, shiftIdSchema } from \"@/lib/schemas\";\nimport { z } from \"zod\";\n\nconst deleteEventSchema = z.object({\n  eventId: z.coerce.number().int().positive({ message: \"Invalid event ID\" }),\n});\n\nconst duplicateEventSchema = z.object({\n  eventId: z.coerce.number().int().positive({ message: \"Invalid event ID\" }),\n  fail: z.coerce.string().optional(), // For testing failure injection\n});\n\nconst revalidateEventPaths = () => {\n  revalidatePath(\"/admin/events\");\n  revalidatePath(\"/events\");\n};\n\nexport async function createEvent(prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult<{ id: number }>> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const title = formData.get('title') as string;\n    const startTime = formData.get('startTime') as string;\n    const endTime = formData.get('endTime') as string;\n    const description = formData.get('description') as string;\n\n    if (!title || !startTime || !endTime) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { title: !title ? ['Title is required'] : [], startTime: !startTime ? ['Start time is required'] : [], endTime: !endTime ? ['End time is required'] : [] },\n        data: null,\n      };\n    }\n\n    // validate times server-side\n    const start = new Date(startTime);\n    const end = new Date(endTime);\n    if (!(start instanceof Date) || !(end instanceof Date) || Number.isNaN(+start) || Number.isNaN(+end)) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { startTime: ['Invalid date/time'], endTime: ['Invalid date/time'] },\n        data: null,\n      };\n    }\n    if (end <= start) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { endTime: ['End time must be after start time'] },\n        data: null,\n      };\n    }\n\n    const ev = await prisma.event.create({\n      data: { title, startTime: start, endTime: end, description: description || null }\n    });\n    revalidatePath('/admin/events');\n    revalidatePath('/events'); // public list must reflect immediately\n    return {\n      success: true,\n      message: \"Event created successfully.\",\n      fieldErrors: undefined,\n      data: { id: ev.id },\n    };\n  } catch {\n    return {\n      success: false,\n      message: \"Failed to create event.\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function getEvents() {\n  return prisma.event.findMany({\n    orderBy: {\n      startTime: \"asc\",\n    },\n  });\n}\n\nexport async function updateEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const idParsed = shiftIdSchema.safeParse({\n      shiftId: formData.get(\"id\"),\n    });\n\n    if (!idParsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: idParsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    const parsed = eventFormSchema.safeParse({\n      title: formData.get(\"title\"),\n      description: formData.get(\"description\"),\n      startTime: formData.get(\"startTime\"),\n      endTime: formData.get(\"endTime\"),\n      location: formData.get(\"location\"),\n      capacity: formData.get(\"capacity\"),\n    });\n\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    const data = parsed.data;\n    const startTime = new Date(data.startTime);\n    const endTime = new Date(data.endTime);\n\n    // Server-side validation: startTime must be before endTime\n    if (startTime >= endTime) {\n      return {\n        success: false,\n        message: \"Start time must be before end time.\",\n        fieldErrors: { startTime: [\"Start time must be before end time\"] },\n        data: null,\n      };\n    }\n\n    // Server-side validation: forbid past start times\n    if (startTime <= new Date()) {\n      return {\n        success: false,\n        message: \"Cannot update events to start in the past.\",\n        fieldErrors: { startTime: [\"Start time must be in the future\"] },\n        data: null,\n      };\n    }\n\n    await prisma.event.update({\n      where: { id: idParsed.data.shiftId },\n      data: {\n        title: data.title,\n        description: data.description,\n        startTime,\n        endTime: new Date(data.endTime),\n        location: data.location,\n        capacity: data.capacity,\n      },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event updated successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to update event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function duplicateEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = duplicateEventSchema.safeParse({\n      eventId: formData.get(\"eventId\"),\n      fail: formData.get(\"fail\"),\n    });\n\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    // Check if we should inject a failure for testing\n    if (parsed.data.fail === '1') {\n      return {\n        success: false,\n        message: \"Simulated failure for testing optimistic rollback\",\n        fieldErrors: undefined,\n        data: null,\n      };\n    }\n\n    const originalEvent = await prisma.event.findUnique({\n      where: { id: parsed.data.eventId },\n    });\n\n    if (!originalEvent) {\n      return {\n        success: false,\n        message: \"Event not found.\",\n        fieldErrors: { eventId: [\"Event not found\"] },\n        data: null,\n      };\n    }\n\n    // Create duplicate with \"Copy of\" prefix\n    await prisma.event.create({\n      data: {\n        title: `Copy of ${originalEvent.title}`,\n        description: originalEvent.description,\n        startTime: originalEvent.startTime,\n        endTime: originalEvent.endTime,\n        location: originalEvent.location,\n        capacity: originalEvent.capacity,\n      },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event duplicated successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to duplicate event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function deleteEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = deleteEventSchema.safeParse({\n      eventId: formData.get(\"eventId\"),\n    });\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    await prisma.event.delete({\n      where: { id: parsed.data.eventId },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event deleted successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to delete event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 905, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/.next-internal/server/app/admin/events/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getSSRUser as '000856392be4f7d53ed3e3e3326c2c888c8e2950e9'} from 'ACTIONS_MODULE0'\nexport {getEvents as '00acdca7fb68ee6614618c11928c9b31db6c22d880'} from 'ACTIONS_MODULE1'\nexport {createEvent as '601fed57f579c6051f24aa1d87e25a3c8f3fc34a30'} from 'ACTIONS_MODULE1'\nexport {updateEvent as '602f4b212fdb50695074a2363f7ff99d375f88de9e'} from 'ACTIONS_MODULE1'\nexport {duplicateEvent as '604ff361909285a51438de8d36a78c6c015531dfab'} from 'ACTIONS_MODULE1'\nexport {deleteEvent as '60ebfe91a5f66e9d407d12c7f96aabadd0dfa61296'} from 'ACTIONS_MODULE1'\nexport {getAllStaffUsers as '0033a4aab8087bee60fa3957be6e412e7a28e6b142'} from 'ACTIONS_MODULE2'\nexport {getAllUsers as '0040745eebb8809dbc98afe0103726da3438000754'} from 'ACTIONS_MODULE2'\nexport {getActingUserRole as '006095df662d1f5454db62806f7d257b4264768061'} from 'ACTIONS_MODULE2'\nexport {getUserProfile as '40103a556ce1c8f26a74594d1623582c17a19007fe'} from 'ACTIONS_MODULE2'\nexport {requireRole as '401918a5b31d808cec1006f2b7ec1ed729ea95edbe'} from 'ACTIONS_MODULE2'\nexport {createProfile as '4029bb82f3e859aa7d1d5c000b17516a82e1704167'} from 'ACTIONS_MODULE2'\nexport {assertRole as '4058e90462fbf4a2c11008bad52cf288efe05a8b32'} from 'ACTIONS_MODULE2'\nexport {getActingUser as '40b6b27014bdc1a8fded8ff3d22be5fda4813317de'} from 'ACTIONS_MODULE2'\nexport {getUserSignupIds as '40c005c7807d025045aa1b80a1ad40fa0d179df6e8'} from 'ACTIONS_MODULE2'\nexport {updateUserRole as '60ceabe90fc8ed1b25017daee808de48043d157a6e'} from 'ACTIONS_MODULE2'\nexport {createEvent as '601fed57f579c6051f24aa1d87e25a3c8f3fc34a30'} from 'ACTIONS_MODULE1'\nexport {updateEvent as '602f4b212fdb50695074a2363f7ff99d375f88de9e'} from 'ACTIONS_MODULE1'\nexport {deleteEvent as '60ebfe91a5f66e9d407d12c7f96aabadd0dfa61296'} from 'ACTIONS_MODULE1'\nexport {duplicateEvent as '604ff361909285a51438de8d36a78c6c015531dfab'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AACA;AAKA","debugId":null}}]
}