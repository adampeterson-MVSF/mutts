{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/profile.actions.ts"],"sourcesContent":["// lib/actions/profile.actions.ts\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { prisma } from \"@/lib/prisma\";\nimport { UserRole } from \"@prisma/client\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { z } from \"zod\";\nimport { ActionResult } from \"@/lib/types\";\n\nconst createProfileSchema = z.object({\n  name: z.string().optional(),\n});\n\n\n// Add this new function\nexport async function getActingUser(\n  { requireAuth = true }: { requireAuth?: boolean } = {}\n) {\n  // Check for synthetic session headers first (set by middleware)\n  const { headers } = await import('next/headers');\n  const headerData = await headers();\n  const testUserId = headerData.get('x-test-user-id');\n  const testUserRole = headerData.get('x-test-user-role');\n\n  if (testUserId && testUserRole) {\n    // Return a mock/partial User object based on headers\n    return {\n      id: testUserId,\n      email: `test-${testUserRole.toLowerCase()}@example.test`,\n      app_metadata: { role: testUserRole as UserRole },\n    } as {\n      id: string;\n      email: string;\n      app_metadata: { role: UserRole };\n    };\n  }\n\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n\n  if (requireAuth && !user) {\n    redirect(\"/auth/login\");\n  }\n  return user;\n}\n\n// Add this new function\nexport async function requireRole(role: UserRole | UserRole[]) {\n  const user = await getActingUser();\n  if (!user) {\n    // This should be redundant due to getActingUser, but good for type safety\n    throw new Error(\"Authentication required.\");\n  }\n\n  const roles = Array.isArray(role) ? role : [role];\n  const userRole = await getActingUserRole(); // Assumes this queries the DB\n\n  // Role hierarchy: ADMIN can access everything\n  if (userRole === UserRole.ADMIN) {\n    return; // Admin has access to everything\n  }\n\n  if (!roles.includes(userRole)) {\n    throw new Error(\"Unauthorized.\");\n  }\n}\n\n// Defense-in-depth RBAC helper - throws on unauthorized access\nexport async function assertRole(requiredRoles: UserRole | UserRole[]): Promise<void> {\n  const user = await getActingUser();\n  if (!user) {\n    throw new Error(\"Authentication required.\");\n  }\n\n  const userRole = await getActingUserRole();\n  const roles = Array.isArray(requiredRoles) ? requiredRoles : [requiredRoles];\n\n  // ADMIN can access everything\n  if (userRole === UserRole.ADMIN) {\n    return;\n  }\n\n  if (!roles.includes(userRole)) {\n    throw new Error(\"Insufficient permissions.\");\n  }\n}\n\nexport async function createProfile(name: string) {\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) { throw new Error(\"User not authenticated.\"); }\n\n  const parsed = createProfileSchema.safeParse({ name });\n  if (!parsed.success) {\n    throw new Error(parsed.error.issues[0]?.message ?? \"Invalid name\");\n  }\n\n  await prisma.profile.upsert({\n     where: { id: user.id },\n     update: { name: parsed.data.name, email: user.email }, // Update name/email if they exist\n     create: { id: user.id, email: user.email!, name: parsed.data.name },\n  });\n}\n\nexport async function updateUserRole(prevState: ActionResult, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.ADMIN);\n\n    const userId = formData.get('userId') as string;\n    const role = formData.get('role') as UserRole;\n\n    if (!userId || !role) {\n      return {\n        success: false,\n        message: \"Missing required fields\",\n        fieldErrors: undefined,\n        data: null,\n      };\n    }\n\n    // Protect \"last admin\" from demotion\n    const adminCount = await prisma.profile.count({ where: { role: 'ADMIN' } });\n    const user = await prisma.profile.findUnique({ where: { id: userId }, select: { role: true } });\n    if (!user) {\n      return {\n        success: false,\n        message: 'User not found',\n        fieldErrors: { userId: ['User not found'] },\n        data: null,\n      };\n    }\n    if (user.role === 'ADMIN' && role !== 'ADMIN' && adminCount <= 1) {\n      return {\n        success: false,\n        message: 'Cannot demote the last admin',\n        fieldErrors: { role: ['Cannot demote the last admin'] },\n        data: null,\n      };\n    }\n\n    await prisma.profile.update({ where: { id: userId }, data: { role } });\n    revalidatePath('/admin/users');\n    return {\n      success: true,\n      message: 'Role updated successfully',\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch {\n    return {\n      success: false,\n      message: \"Failed to update user role\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function getAllUsers() {\n  if (process.env.NODE_ENV !== 'test') {\n    await assertRole(UserRole.ADMIN);\n  }\n  return await prisma.profile.findMany({\n    orderBy: { email: \"asc\" },\n    select: {\n      id: true,\n      name: true,\n      email: true,\n      role: true,\n    },\n  });\n}\n\nexport async function getAllStaffUsers() {\n  if (process.env.NODE_ENV !== 'test') {\n    await assertRole(UserRole.STAFF);\n  }\n  return await prisma.profile.findMany({\n    where: {\n      role: {\n        in: [UserRole.STAFF, UserRole.ADMIN],\n      },\n    },\n    orderBy: { email: \"asc\" },\n    select: {\n      id: true,\n      name: true,\n      email: true,\n    },\n  });\n}\n\nexport async function getActingUserRole(): Promise<UserRole> {\n  // Check for synthetic session headers first (set by middleware)\n  const { headers } = await import('next/headers');\n  const headerData = await headers();\n  const testUserRole = headerData.get('x-test-user-role');\n\n  if (testUserRole && ['ADMIN', 'STAFF', 'VOLUNTEER'].includes(testUserRole)) {\n    return testUserRole as UserRole;\n  }\n\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n\n  if (!user) {\n    throw new Error(\"Not authenticated\");\n  }\n\n  const profile = await prisma.profile.findUnique({\n    where: { id: user.id },\n    select: { role: true },\n  });\n\n  if (!profile) {\n    throw new Error(\"Profile not found\");\n  }\n\n  return profile.role;\n}\n\nexport async function getUserProfile(userId: string) {\n  // Ensure user can only view their own profile (skip in test environment)\n  if (process.env.NODE_ENV !== 'test') {\n    const currentUser = await getActingUser();\n    if (!currentUser || currentUser.id !== userId) {\n      throw new Error(\"Unauthorized: Can only view your own profile\");\n    }\n  }\n\n  const parsed = z.object({ userId: z.string() }).safeParse({ userId });\n  if (!parsed.success) {\n    throw new Error(\"Invalid user ID\");\n  }\n\n  const profile = await prisma.profile.findUnique({\n    where: { id: userId },\n    select: {\n      name: true,\n      email: true,\n      role: true,\n      trainingCompleted: true,\n      backgroundCheckCompleted: true,\n      shiftCapacity: true,\n      prefersWeekdays: true,\n      prefersMornings: true,\n    },\n  });\n\n  // Return null if profile doesn't exist\n  return profile;\n}\n\nexport async function getUserSignupIds(userId: string) {\n  // Ensure user can only view their own signup IDs (skip in test environment)\n  if (process.env.NODE_ENV !== 'test') {\n    const currentUser = await getActingUser();\n    if (!currentUser || currentUser.id !== userId) {\n      throw new Error(\"Unauthorized: Can only view your own signups\");\n    }\n  }\n\n  const parsed = z.object({ userId: z.string() }).safeParse({ userId });\n  if (!parsed.success) {\n    throw new Error(\"Invalid user ID\");\n  }\n\n  try {\n    const userSignups = await prisma.volunteerShiftSignup.findMany({\n      where: { volunteerId: userId },\n      select: { shiftId: true }\n    });\n\n    return userSignups.map(signup => signup.shiftId);\n  } catch {\n    // Return empty array on any lookup failure (user doesn't exist, etc.)\n    return [];\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 368, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/notifications.actions.ts"],"sourcesContent":["// lib/actions/notifications.actions.ts\n\"use server\";\n\nimport { assertRole } from \"@/lib/actions/profile.actions\";\nimport { UserRole } from \"@prisma/client\";\nimport { ActionResult } from \"@/lib/types\";\nimport { prisma } from \"@/lib/prisma\";\n\n/**\n * Sends a foster invitation email to the specified profile.\n * Currently a stub implementation that logs the invitation.\n * In production, this would integrate with an email service provider.\n */\nexport async function sendFosterInvite(profileId: string): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n    if (!profileId || typeof profileId !== 'string') {\n      return { success: false, message: 'Profile not found', fieldErrors: undefined, data: null };\n    }\n\n    const profile = await prisma.profile.findUnique({ where: { id: profileId } });\n    if (!profile) {\n      return { success: false, message: 'Profile not found', fieldErrors: undefined, data: null };\n    }\n\n    // Stub \"send invite\"\n    console.log('Foster invite sent', { profileId });\n\n    return { success: true, message: `Foster invitation sent to ${profile.email}`, fieldErrors: undefined, data: null };\n  } catch (err: unknown) {\n    return { success: false, message: err instanceof Error ? err.message : 'Database connection failed', fieldErrors: undefined, data: null };\n  }\n}\n"],"names":[],"mappings":"AAAA,uCAAuC;;;;;;AAGvC;AACA;AAEA;AAAA;;;;;;AAOO,eAAe,iBAAiB,SAAiB;IACtD,IAAI;QACF,MAAM,IAAA,kJAAU,EAAC,yIAAQ,CAAC,KAAK;QAC/B,IAAI,CAAC,aAAa,OAAO,cAAc,UAAU;YAC/C,OAAO;gBAAE,SAAS;gBAAO,SAAS;gBAAqB,aAAa;gBAAW,MAAM;YAAK;QAC5F;QAEA,MAAM,UAAU,MAAM,mHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE,IAAI;YAAU;QAAE;QAC3E,IAAI,CAAC,SAAS;YACZ,OAAO;gBAAE,SAAS;gBAAO,SAAS;gBAAqB,aAAa;gBAAW,MAAM;YAAK;QAC5F;QAEA,qBAAqB;QACrB,QAAQ,GAAG,CAAC,sBAAsB;YAAE;QAAU;QAE9C,OAAO;YAAE,SAAS;YAAM,SAAS,CAAC,0BAA0B,EAAE,QAAQ,KAAK,EAAE;YAAE,aAAa;YAAW,MAAM;QAAK;IACpH,EAAE,OAAO,KAAc;QACrB,OAAO;YAAE,SAAS;YAAO,SAAS,eAAe,QAAQ,IAAI,OAAO,GAAG;YAA8B,aAAa;YAAW,MAAM;QAAK;IAC1I;AACF;;;IAnBsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 435, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/csv.ts"],"sourcesContent":["// lib/csv.ts\n\n/**\n * Sanitizes a value for CSV export, preventing Excel formula injection attacks\n * and handling null/undefined values safely.\n */\nexport const sanitizeCell = (value: unknown): string => {\n  let s = value == null ? '' : String(value);\n  // Prefix with single quote if starts with formula characters to prevent Excel injection\n  if (/^[=+\\-@]/.test(s)) s = `'${s}`;\n  // Escape quotes by doubling them and wrap in quotes\n  return `\"${s.replace(/\"/g, '\"\"')}\"`;\n};\n\n/**\n * Converts an array of objects to CSV format with headers.\n * @param data Array of objects to convert\n * @param headers Optional custom headers. If not provided, uses object keys from first item\n * @returns CSV string with BOM for Excel UTF-8 compatibility\n */\nexport const toCsv = <T extends Record<string, unknown>>(\n  data: T[],\n  headers?: string[]\n): string => {\n  const headerRow = headers || (data.length > 0 ? Object.keys(data[0]) : []);\n  const csvRows = [\n    headerRow.map(sanitizeCell).join(','),\n    ...data.map(row =>\n      headerRow.map(key => sanitizeCell(row[key])).join(',')\n    )\n  ];\n\n  // Prepend BOM for Excel UTF-8 compatibility\n  return '\\uFEFF' + csvRows.join('\\n') + (csvRows.length > 0 ? '\\n' : '');\n};\n\n/**\n * Downloads CSV data as a file with the given filename.\n * @param filename The name of the file to download (without extension)\n * @param data The CSV data as a string\n */\nexport const downloadCsv = (filename: string, data: string): void => {\n  const blob = new Blob([data], { type: 'text/csv;charset=utf-8;' });\n  const url = URL.createObjectURL(blob);\n\n  // Create a temporary link and trigger download\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename.endsWith('.csv') ? filename : `${filename}.csv`;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n\n  // Clean up the URL object\n  URL.revokeObjectURL(url);\n};\n"],"names":[],"mappings":"AAAA,aAAa;AAEb;;;CAGC;;;;;;;;AACM,MAAM,eAAe,CAAC;IAC3B,IAAI,IAAI,SAAS,OAAO,KAAK,OAAO;IACpC,wFAAwF;IACxF,IAAI,WAAW,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,EAAE,GAAG;IACnC,oDAAoD;IACpD,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,MAAM,MAAM,CAAC,CAAC;AACrC;AAQO,MAAM,QAAQ,CACnB,MACA;IAEA,MAAM,YAAY,WAAW,CAAC,KAAK,MAAM,GAAG,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE;IACzE,MAAM,UAAU;QACd,UAAU,GAAG,CAAC,cAAc,IAAI,CAAC;WAC9B,KAAK,GAAG,CAAC,CAAA,MACV,UAAU,GAAG,CAAC,CAAA,MAAO,aAAa,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC;KAErD;IAED,4CAA4C;IAC5C,OAAO,WAAW,QAAQ,IAAI,CAAC,QAAQ,CAAC,QAAQ,MAAM,GAAG,IAAI,OAAO,EAAE;AACxE;AAOO,MAAM,cAAc,CAAC,UAAkB;IAC5C,MAAM,OAAO,IAAI,KAAK;QAAC;KAAK,EAAE;QAAE,MAAM;IAA0B;IAChE,MAAM,MAAM,IAAI,eAAe,CAAC;IAEhC,+CAA+C;IAC/C,MAAM,OAAO,SAAS,aAAa,CAAC;IACpC,KAAK,IAAI,GAAG;IACZ,KAAK,QAAQ,GAAG,SAAS,QAAQ,CAAC,UAAU,WAAW,GAAG,SAAS,IAAI,CAAC;IACxE,SAAS,IAAI,CAAC,WAAW,CAAC;IAC1B,KAAK,KAAK;IACV,SAAS,IAAI,CAAC,WAAW,CAAC;IAE1B,0BAA0B;IAC1B,IAAI,eAAe,CAAC;AACtB","debugId":null}},
    {"offset": {"line": 484, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/foster.actions.ts"],"sourcesContent":["\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { prisma } from \"@/lib/prisma\";\nimport { assertRole } from \"@/lib/actions/profile.actions\";\nimport { UserRole } from \"@prisma/client\";\nimport { ActionResult } from \"@/lib/types\";\nimport { z } from \"zod\";\nimport { sendFosterInvite } from \"@/lib/actions/notifications.actions\";\nimport { sanitizeCell } from \"@/lib/csv\";\n\n// Allow any non-empty string to support seed data IDs like 'volunteer-46'\nconst idParamSchema = z.string().min(1);\n\nconst fosterProfileSchema = z.object({\n  profileId: z.string().min(1, { message: \"Invalid profile ID\" }),\n  hasCats: z.boolean(),\n  hasDogs: z.boolean(),\n  canAdministerMeds: z.boolean(),\n  notes: z.string().optional(),\n});\n\nconst toBoolean = (value: FormDataEntryValue | null) => {\n  if (value === null) return false;\n  const stringValue = String(value).toLowerCase();\n  return stringValue === \"true\" || stringValue === \"on\" || stringValue === \"1\";\n};\n\nexport async function ensureFosterProfile(profileId: string) {\n  // Allow any non-empty string to support seed data IDs like 'volunteer-46'\n  const parsed = z.object({ profileId: z.string().min(1) }).safeParse({ profileId });\n  if (!parsed.success) {\n    throw new Error(\"Invalid profile ID\");\n  }\n\n  // Try to find existing foster profile\n  let fosterProfile = await prisma.fosterProfile.findUnique({\n    where: { profileId: parsed.data.profileId },\n    include: { profile: true },\n  });\n\n  // If it doesn't exist, create one with defaults\n  if (!fosterProfile) {\n    fosterProfile = await prisma.fosterProfile.create({\n      data: {\n        profileId: parsed.data.profileId,\n        hasCats: false,\n        hasDogs: false,\n        canAdministerMeds: false,\n        notes: null,\n      },\n      include: { profile: true },\n    });\n  }\n\n  return fosterProfile;\n}\n\ninterface FosterProfileWithDogs {\n  id: number;\n  profileId: string;\n  hasCats: boolean;\n  hasDogs: boolean;\n  canAdministerMeds: boolean;\n  notes: string | null;\n  profile: {\n    name: string;\n    email: string;\n  };\n  dogs: {\n    name: string;\n  }[];\n}\n\nexport async function getFosterProfiles(searchParams?: {\n  page?: number;\n  limit?: number;\n  hasCats?: boolean;\n  hasDogs?: boolean;\n  canAdministerMeds?: boolean;\n}): Promise<{ fosterProfiles: FosterProfileWithDogs[]; pagination: { currentPage: number; totalPages: number; totalCount: number; hasNextPage: boolean; hasPreviousPage: boolean; } }> {\n  await assertRole(UserRole.STAFF);\n\n  const page = searchParams?.page ?? 1;\n  const limit = searchParams?.limit ?? 50;\n  const skip = (page - 1) * limit;\n\n  const where = {\n    ...(searchParams?.hasCats !== undefined && { hasCats: searchParams.hasCats }),\n    ...(searchParams?.hasDogs !== undefined && { hasDogs: searchParams.hasDogs }),\n    ...(searchParams?.canAdministerMeds !== undefined && { canAdministerMeds: searchParams.canAdministerMeds }),\n  };\n\n  const [fosterProfilesRaw, totalCount] = await Promise.all([\n    prisma.fosterProfile.findMany({\n      where,\n      select: {\n        profileId: true,\n        hasCats: true,\n        hasDogs: true,\n        canAdministerMeds: true,\n        notes: true,\n        profile: {\n          select: {\n            name: true,\n            email: true,\n          }\n        },\n        dogs: {\n          select: {\n            name: true,\n          }\n        }\n      },\n      orderBy: [\n        {\n          profile: {\n            name: \"asc\",\n          },\n        },\n        {\n          profile: {\n            email: \"asc\",\n          },\n        },\n      ],\n      skip,\n      take: limit,\n    }),\n    prisma.fosterProfile.count({ where }),\n  ]);\n\n  const totalPages = Math.ceil(totalCount / limit);\n  const fosterProfiles = fosterProfilesRaw as unknown as FosterProfileWithDogs[];\n\n  return {\n    fosterProfiles,\n    pagination: {\n      currentPage: page,\n      totalPages,\n      totalCount,\n      hasNextPage: page < totalPages,\n      hasPreviousPage: page > 1,\n    },\n  };\n}\n\nexport async function getFosterProfileById(profileId: string) {\n  await assertRole(UserRole.STAFF);\n\n  // Allow any non-empty string to support seed data IDs like 'volunteer-46'\n  const parsed = z.object({ profileId: z.string().min(1) }).safeParse({ profileId });\n  if (!parsed.success) {\n    throw new Error(\"Invalid profile ID\");\n  }\n\n  return prisma.fosterProfile.findUnique({\n    where: { profileId },\n    include: {\n      profile: true,\n    },\n  });\n}\n\nexport async function getFosterProfileByParam(param: string) {\n  await assertRole(UserRole.STAFF);\n\n  const parsed = idParamSchema.safeParse(param);\n  if (!parsed.success) {\n    throw new Error('Invalid profile identifier');\n  }\n\n  return prisma.fosterProfile.findUnique({\n    where: { profileId: parsed.data },\n    include: { profile: true },\n  });\n}\n\nexport async function updateFosterProfile(\n  _prevState: ActionResult | undefined,\n  formData: FormData,\n): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const intent = formData.get(\"intent\") as string;\n    const shouldSendInvite = intent === \"invite\";\n\n    const data = {\n      profileId: formData.get(\"profileId\"),\n      hasCats: toBoolean(formData.get(\"hasCats\")),\n      hasDogs: toBoolean(formData.get(\"hasDogs\")),\n      canAdministerMeds: toBoolean(formData.get(\"canAdministerMeds\")),\n      notes: (() => {\n        const value = formData.get(\"notes\");\n        if (typeof value !== \"string\") return undefined;\n        return value.trim() === \"\" ? undefined : value.trim();\n      })(),\n    };\n\n    const parsed = fosterProfileSchema.safeParse(data);\n    if (!parsed.success) {\n      const fieldErrors = parsed.error.flatten().fieldErrors;\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors,\n        data: null,\n      };\n    }\n\n    await prisma.fosterProfile.upsert({\n      where: { profileId: parsed.data.profileId },\n      create: parsed.data,\n      update: {\n        hasCats: parsed.data.hasCats,\n        hasDogs: parsed.data.hasDogs,\n        canAdministerMeds: parsed.data.canAdministerMeds,\n        notes: parsed.data.notes,\n      },\n    });\n\n    // Send invitation if requested\n    if (shouldSendInvite) {\n      try {\n        await sendFosterInvite(parsed.data.profileId);\n      } catch (inviteError) {\n        console.error(\"Failed to send foster invite:\", inviteError);\n        // Don't fail the entire operation if invite fails\n      }\n    }\n\n    revalidatePath(\"/admin/fosters\");\n    revalidatePath(`/admin/fosters/${parsed.data.profileId}`);\n\n    return {\n      success: true,\n      message: shouldSendInvite\n        ? \"Foster profile updated and invitation sent successfully!\"\n        : \"Foster profile updated successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to update foster profile\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function getFosterProfilesForExport(searchParams?: {\n  hasCats?: boolean;\n  hasDogs?: boolean;\n  canAdministerMeds?: boolean;\n}) {\n  await assertRole(UserRole.STAFF);\n\n  const where = {\n    ...(searchParams?.hasCats !== undefined && { hasCats: searchParams.hasCats }),\n    ...(searchParams?.hasDogs !== undefined && { hasDogs: searchParams.hasDogs }),\n    ...(searchParams?.canAdministerMeds !== undefined && { canAdministerMeds: searchParams.canAdministerMeds }),\n  };\n\n  const fosterProfiles = await prisma.fosterProfile.findMany({\n    where,\n    include: {\n      profile: {\n        select: {\n          name: true,\n          email: true,\n        },\n      },\n    },\n    orderBy: [\n      {\n        profile: {\n          name: \"asc\",\n        },\n      },\n      {\n        profile: {\n          email: \"asc\",\n        },\n      },\n    ],\n  });\n\n  return fosterProfiles;\n}\n\nexport async function generateFosterProfilesCSV(searchParams?: {\n  hasCats?: boolean;\n  hasDogs?: boolean;\n  canAdministerMeds?: boolean;\n}): Promise<string> {\n  const fosterProfiles = await getFosterProfilesForExport(searchParams);\n\n  const headers = [\n    \"Name\",\n    \"Email\",\n    \"Capabilities\",\n    \"Notes\",\n  ];\n\n  const rows = fosterProfiles.map(fp => {\n    const capabilities = [\n      fp.hasCats ? \"Cats\" : null,\n      fp.hasDogs ? \"Dogs\" : null,\n      fp.canAdministerMeds ? \"Medications\" : null,\n    ].filter(Boolean).join(\", \") || \"None\";\n\n    return [\n      fp.profile?.name || \"\",\n      fp.profile?.email || \"\",\n      capabilities,\n      fp.notes || \"\",\n    ];\n  });\n\n  // Create CSV content with BOM for Excel compatibility\n  const BOM = \"\\uFEFF\";\n  const csvContent = [\n    headers.map(header => sanitizeCell(header)).join(\",\"),\n    ...rows.map(row => row.map(field => sanitizeCell(field)).join(\",\")),\n  ].join(\"\\n\");\n\n  return BOM + csvContent;\n}\n\nexport type FosterProfileWithProfile = Awaited<\n  ReturnType<typeof getFosterProfileById>\n>;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 826, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/.next-internal/server/app/admin/fosters/%5Bid%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getSSRUser as '000856392be4f7d53ed3e3e3326c2c888c8e2950e9'} from 'ACTIONS_MODULE0'\nexport {getFosterProfiles as '4035570e5679320445377da16246a27a53551dd0b1'} from 'ACTIONS_MODULE1'\nexport {generateFosterProfilesCSV as '40402a26ac850fb873b11c4895e204e5c10bb11c09'} from 'ACTIONS_MODULE1'\nexport {getFosterProfileByParam as '406d547189351031f45e884fd434861d3bfa7ada06'} from 'ACTIONS_MODULE1'\nexport {getFosterProfilesForExport as '409ae881e273fd3e2c334deef86652fe45c73d3ea6'} from 'ACTIONS_MODULE1'\nexport {ensureFosterProfile as '40c2f3cea9192a48f43a32f3014e4094dc5a0b2caa'} from 'ACTIONS_MODULE1'\nexport {getFosterProfileById as '40ff4ecdf817b0928d9f4eaccf0ac50db40feda9f4'} from 'ACTIONS_MODULE1'\nexport {updateFosterProfile as '60256a71922245d33c482eda3c7ac55eb19a32b83b'} from 'ACTIONS_MODULE1'\nexport {getAllStaffUsers as '0033a4aab8087bee60fa3957be6e412e7a28e6b142'} from 'ACTIONS_MODULE2'\nexport {getAllUsers as '0040745eebb8809dbc98afe0103726da3438000754'} from 'ACTIONS_MODULE2'\nexport {getActingUserRole as '006095df662d1f5454db62806f7d257b4264768061'} from 'ACTIONS_MODULE2'\nexport {getUserProfile as '40103a556ce1c8f26a74594d1623582c17a19007fe'} from 'ACTIONS_MODULE2'\nexport {requireRole as '401918a5b31d808cec1006f2b7ec1ed729ea95edbe'} from 'ACTIONS_MODULE2'\nexport {createProfile as '4029bb82f3e859aa7d1d5c000b17516a82e1704167'} from 'ACTIONS_MODULE2'\nexport {assertRole as '4058e90462fbf4a2c11008bad52cf288efe05a8b32'} from 'ACTIONS_MODULE2'\nexport {getActingUser as '40b6b27014bdc1a8fded8ff3d22be5fda4813317de'} from 'ACTIONS_MODULE2'\nexport {getUserSignupIds as '40c005c7807d025045aa1b80a1ad40fa0d179df6e8'} from 'ACTIONS_MODULE2'\nexport {updateUserRole as '60ceabe90fc8ed1b25017daee808de48043d157a6e'} from 'ACTIONS_MODULE2'\nexport {sendFosterInvite as '40fe62832175461942e43387cc929cb9c8857cd351'} from 'ACTIONS_MODULE3'\nexport {updateFosterProfile as '60256a71922245d33c482eda3c7ac55eb19a32b83b'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AACA;AAOA;AAUA","debugId":null}}]
}