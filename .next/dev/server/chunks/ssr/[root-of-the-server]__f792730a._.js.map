{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/utils/index.ts"],"sourcesContent":["// lib/utils/index.ts\n// Shared utility functions for the application\n\nimport { AppStatus, AppType } from \"@prisma/client\";\n\n/**\n * Humanize enum values by replacing underscores with spaces and capitalizing words\n */\nexport const humanizeEnum = (value: string): string => {\n  return value\n    .toLowerCase()\n    .replace(/_/g, ' ')\n    .replace(/\\b\\w/g, l => l.toUpperCase());\n};\n\n/**\n * Status variant functions for consistent badge styling\n */\nexport const getAppStatusVariant = (status: AppStatus) => {\n  switch (status) {\n    case \"APPROVED\": return \"default\";\n    case \"SUBMITTED\": case \"IN_REVIEW\": return \"secondary\";\n    case \"REJECTED\": return \"destructive\";\n    default: return \"outline\";\n  }\n};\n\n/**\n * Get allowed status transitions for applications\n */\nexport const getAllowedStatuses = (applicationType: AppType, currentStatus?: AppStatus): AppStatus[] => {\n  const allStatuses = Object.values(AppStatus);\n\n  // For foster applications, restrict some status transitions\n  if (applicationType === AppType.FOSTER) {\n    // Fosters can be approved (creates foster profile) or rejected\n    // Can't be marked as \"IN_REVIEW\" inappropriately\n    return allStatuses.filter(status =>\n      status !== AppStatus.IN_REVIEW || currentStatus === AppStatus.IN_REVIEW\n    );\n  }\n\n  // For adoption applications, all statuses are allowed\n  return allStatuses;\n};\n\n/**\n * Check if status change notes are required for a given status\n */\nexport const areStatusNotesRequired = (status: AppStatus): boolean => {\n  return status === AppStatus.APPROVED || status === AppStatus.REJECTED;\n};\n"],"names":[],"mappings":"AAAA,qBAAqB;AACrB,+CAA+C;;;;;;;;;;;AAE/C;;AAKO,MAAM,eAAe,CAAC;IAC3B,OAAO,MACJ,WAAW,GACX,OAAO,CAAC,MAAM,KACd,OAAO,CAAC,SAAS,CAAA,IAAK,EAAE,WAAW;AACxC;AAKO,MAAM,sBAAsB,CAAC;IAClC,OAAQ;QACN,KAAK;YAAY,OAAO;QACxB,KAAK;QAAa,KAAK;YAAa,OAAO;QAC3C,KAAK;YAAY,OAAO;QACxB;YAAS,OAAO;IAClB;AACF;AAKO,MAAM,qBAAqB,CAAC,iBAA0B;IAC3D,MAAM,cAAc,OAAO,MAAM,CAAC,0IAAS;IAE3C,4DAA4D;IAC5D,IAAI,oBAAoB,wIAAO,CAAC,MAAM,EAAE;QACtC,+DAA+D;QAC/D,iDAAiD;QACjD,OAAO,YAAY,MAAM,CAAC,CAAA,SACxB,WAAW,0IAAS,CAAC,SAAS,IAAI,kBAAkB,0IAAS,CAAC,SAAS;IAE3E;IAEA,sDAAsD;IACtD,OAAO;AACT;AAKO,MAAM,yBAAyB,CAAC;IACrC,OAAO,WAAW,0IAAS,CAAC,QAAQ,IAAI,WAAW,0IAAS,CAAC,QAAQ;AACvE","debugId":null}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { AppStatus, AppType, DogStatus } from \"@prisma/client\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\n\n// This check can be removed, it is just for tutorial purposes\nexport const hasEnvVars =\n  !!(process.env.NEXT_PUBLIC_SUPABASE_URL &&\n     process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);\n\n\nexport const getDogStatusVariant = (status: DogStatus) => {\n  switch (status) {\n    case \"ADOPTED\": return \"default\";\n    case \"AVAILABLE\": return \"secondary\";\n    case \"MEDICAL_HOLD\": return \"destructive\";\n    case \"PENDING\": case \"IN_FOSTER\": return \"outline\";\n    default: return \"secondary\";\n  }\n};\n\n// Date formatting utilities\nexport const formatDateTime = (date: Date) =>\n  new Intl.DateTimeFormat(\"en-US\", {\n    month: \"short\",\n    day: \"numeric\",\n    year: \"numeric\",\n    hour: \"numeric\",\n    minute: \"2-digit\",\n  }).format(date);\n\nexport const formatDateRange = (start: Date, end: Date) => {\n  const sameDay =\n    start.getFullYear() === end.getFullYear() &&\n    start.getMonth() === end.getMonth() &&\n    start.getDate() === end.getDate();\n\n  if (sameDay) {\n    return `${formatDateTime(start)} – ${new Intl.DateTimeFormat(\"en-US\", {\n      hour: \"numeric\",\n      minute: \"2-digit\",\n    }).format(end)}`;\n  }\n\n  return `${formatDateTime(start)} → ${formatDateTime(end)}`;\n};\n\nexport const formatShiftTime = (start: Date, end: Date): string => {\n  const startDate = start.toLocaleDateString();\n  const startTime = start.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });\n  const endTime = end.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });\n\n  if (startDate === end.toLocaleDateString()) {\n    return `${startDate}, ${startTime} - ${endTime}`;\n  }\n  return `${startDate}, ${startTime} - ${end.toLocaleDateString()}, ${endTime}`;\n};\n\nexport const formatAdoptionDate = (date: Date) =>\n  new Intl.DateTimeFormat(\"en-US\", {\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\",\n  }).format(date);\n\n// Re-export shared utilities\nexport { humanizeEnum, getAppStatusVariant, getAllowedStatuses, areStatusNotesRequired } from './utils/index';\n\n// Test endpoint validation - allow in test environment or with test secret header\nexport function validateTestEndpoint(request: Request): { isValid: boolean; response?: Response } {\n  const isTestEnv = process.env.NODE_ENV === 'test' && process.env.EXPOSE_TEST_API === '1';\n\n  const testSecret = request.headers.get('x-test-secret');\n  const expectedSecret = process.env.TEST_SECRET || 'test-secret-default';\n  const hasValidTestSecret = testSecret === expectedSecret;\n\n  if (!isTestEnv || !hasValidTestSecret) {\n    return {\n      isValid: false,\n      response: new Response(null, { status: 404 })\n    };\n  }\n\n  return { isValid: true };\n}\n\n// Route definitions have been moved to lib/routes.ts\n// Import route functions from @/lib/routes instead\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AAqEA,6BAA6B;AAC7B;;;AAlEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,sKAAO,EAAC,IAAA,6IAAI,EAAC;AACtB;AAIO,MAAM,aACX,CAAC,CAAC,CAAC,kKACyC;AAGvC,MAAM,sBAAsB,CAAC;IAClC,OAAQ;QACN,KAAK;YAAW,OAAO;QACvB,KAAK;YAAa,OAAO;QACzB,KAAK;YAAgB,OAAO;QAC5B,KAAK;QAAW,KAAK;YAAa,OAAO;QACzC;YAAS,OAAO;IAClB;AACF;AAGO,MAAM,iBAAiB,CAAC,OAC7B,IAAI,KAAK,cAAc,CAAC,SAAS;QAC/B,OAAO;QACP,KAAK;QACL,MAAM;QACN,MAAM;QACN,QAAQ;IACV,GAAG,MAAM,CAAC;AAEL,MAAM,kBAAkB,CAAC,OAAa;IAC3C,MAAM,UACJ,MAAM,WAAW,OAAO,IAAI,WAAW,MACvC,MAAM,QAAQ,OAAO,IAAI,QAAQ,MACjC,MAAM,OAAO,OAAO,IAAI,OAAO;IAEjC,IAAI,SAAS;QACX,OAAO,GAAG,eAAe,OAAO,GAAG,EAAE,IAAI,KAAK,cAAc,CAAC,SAAS;YACpE,MAAM;YACN,QAAQ;QACV,GAAG,MAAM,CAAC,MAAM;IAClB;IAEA,OAAO,GAAG,eAAe,OAAO,GAAG,EAAE,eAAe,MAAM;AAC5D;AAEO,MAAM,kBAAkB,CAAC,OAAa;IAC3C,MAAM,YAAY,MAAM,kBAAkB;IAC1C,MAAM,YAAY,MAAM,kBAAkB,CAAC,EAAE,EAAE;QAAE,MAAM;QAAW,QAAQ;IAAU;IACpF,MAAM,UAAU,IAAI,kBAAkB,CAAC,EAAE,EAAE;QAAE,MAAM;QAAW,QAAQ;IAAU;IAEhF,IAAI,cAAc,IAAI,kBAAkB,IAAI;QAC1C,OAAO,GAAG,UAAU,EAAE,EAAE,UAAU,GAAG,EAAE,SAAS;IAClD;IACA,OAAO,GAAG,UAAU,EAAE,EAAE,UAAU,GAAG,EAAE,IAAI,kBAAkB,GAAG,EAAE,EAAE,SAAS;AAC/E;AAEO,MAAM,qBAAqB,CAAC,OACjC,IAAI,KAAK,cAAc,CAAC,SAAS;QAC/B,MAAM;QACN,OAAO;QACP,KAAK;IACP,GAAG,MAAM,CAAC;;AAML,SAAS,qBAAqB,OAAgB;IACnD,MAAM,YAAY,oDAAyB,UAAU,QAAQ,GAAG,CAAC,eAAe,KAAK;IAErF,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,MAAM,iBAAiB,QAAQ,GAAG,CAAC,WAAW,IAAI;IAClD,MAAM,qBAAqB,eAAe;IAE1C,wCAAuC;QACrC,OAAO;YACL,SAAS;YACT,UAAU,IAAI,SAAS,MAAM;gBAAE,QAAQ;YAAI;QAC7C;IACF;;;AAGF,EAEA,qDAAqD;CACrD,mDAAmD","debugId":null}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n        \"icon-sm\": \"size-8\",\n        \"icon-lg\": \"size-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  type = \"button\",\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      type={Comp === \"button\" ? type : undefined}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;;;AACA;AACA;AAEA;;;;;AAEA,MAAM,iBAAiB,IAAA,uKAAG,EACxB,+bACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,SACE;YACF,WACE;YACF,OACE;YACF,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;YACN,WAAW;YACX,WAAW;QACb;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AAGF,SAAS,OAAO,EACd,SAAS,EACT,OAAO,EACP,IAAI,EACJ,UAAU,KAAK,EACf,OAAO,QAAQ,EACf,GAAG,OAIF;IACD,MAAM,OAAO,UAAU,wKAAI,GAAG;IAE9B,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QACxD,MAAM,SAAS,WAAW,OAAO;QAChC,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 238, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/url-pagination-client.ts"],"sourcesContent":["\"use client\";\n\n/**\n * Client-side URL pagination utilities\n */\n\nimport { useRouter, usePathname, useSearchParams } from \"next/navigation\";\nimport { useTransition } from \"react\";\n\nexport const PAGINATION_PARAMS = {\n  PAGE: \"page\",\n} as const;\n\n/**\n * Hook for managing URL-based pagination\n * Provides consistent pagination behavior across the application\n */\nexport function useUrlPagination() {\n  const router = useRouter();\n  const pathname = usePathname();\n  const searchParams = useSearchParams();\n  const [isPending, startTransition] = useTransition();\n\n  const handlePageChange = (page: number) => {\n    const params = new URLSearchParams(searchParams.toString());\n\n    if (page === 1) {\n      params.delete(PAGINATION_PARAMS.PAGE);\n    } else {\n      params.set(PAGINATION_PARAMS.PAGE, page.toString());\n    }\n\n    const query = params.toString();\n    startTransition(() => {\n      router.push(query.length > 0 ? `${pathname}?${query}` : pathname);\n    });\n  };\n\n  return {\n    handlePageChange,\n    isPending,\n  };\n}\n"],"names":[],"mappings":";;;;;;AAEA;;CAEC,GAED;AACA;AAPA;;;AASO,MAAM,oBAAoB;IAC/B,MAAM;AACR;AAMO,SAAS;IACd,MAAM,SAAS,IAAA,+IAAS;IACxB,MAAM,WAAW,IAAA,iJAAW;IAC5B,MAAM,eAAe,IAAA,qJAAe;IACpC,MAAM,CAAC,WAAW,gBAAgB,GAAG,IAAA,sNAAa;IAElD,MAAM,mBAAmB,CAAC;QACxB,MAAM,SAAS,IAAI,gBAAgB,aAAa,QAAQ;QAExD,IAAI,SAAS,GAAG;YACd,OAAO,MAAM,CAAC,kBAAkB,IAAI;QACtC,OAAO;YACL,OAAO,GAAG,CAAC,kBAAkB,IAAI,EAAE,KAAK,QAAQ;QAClD;QAEA,MAAM,QAAQ,OAAO,QAAQ;QAC7B,gBAAgB;YACd,OAAO,IAAI,CAAC,MAAM,MAAM,GAAG,IAAI,GAAG,SAAS,CAAC,EAAE,OAAO,GAAG;QAC1D;IACF;IAEA,OAAO;QACL;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 280, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/adopt/_components/AdoptPagination.tsx"],"sourcesContent":["\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { ChevronLeft, ChevronRight } from \"lucide-react\";\nimport { useUrlPagination } from \"@/lib/url-pagination-client\";\n\ninterface AdoptPaginationProps {\n  currentPage: number;\n  totalPages: number;\n  hasNextPage: boolean;\n  hasPrevPage: boolean;\n}\n\nexport default function AdoptPagination({\n  currentPage,\n  totalPages,\n  hasNextPage,\n  hasPrevPage,\n}: AdoptPaginationProps) {\n  const { handlePageChange, isPending } = useUrlPagination();\n\n  return (\n    <div className=\"flex items-center justify-center gap-4 mt-8\" data-testid=\"pagination\">\n      <Button\n        variant=\"outline\"\n        onClick={() => handlePageChange(currentPage - 1)}\n        disabled={!hasPrevPage || isPending}\n        aria-label=\"Previous page\"\n      >\n        <ChevronLeft className=\"h-4 w-4 mr-1\" />\n        Previous\n      </Button>\n\n      <span className=\"text-sm text-muted-foreground\">\n        Page {currentPage} of {totalPages}\n      </span>\n\n      <Button\n        variant=\"outline\"\n        onClick={() => handlePageChange(currentPage + 1)}\n        disabled={!hasNextPage || isPending}\n        aria-label=\"Next page\"\n      >\n        Next\n        <ChevronRight className=\"h-4 w-4 ml-1\" />\n      </Button>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAAA;AACA;AAJA;;;;;AAae,SAAS,gBAAgB,EACtC,WAAW,EACX,UAAU,EACV,WAAW,EACX,WAAW,EACU;IACrB,MAAM,EAAE,gBAAgB,EAAE,SAAS,EAAE,GAAG,IAAA,sJAAgB;IAExD,qBACE,8OAAC;QAAI,WAAU;QAA8C,eAAY;;0BACvE,8OAAC,qIAAM;gBACL,SAAQ;gBACR,SAAS,IAAM,iBAAiB,cAAc;gBAC9C,UAAU,CAAC,eAAe;gBAC1B,cAAW;;kCAEX,8OAAC,mOAAW;wBAAC,WAAU;;;;;;oBAAiB;;;;;;;0BAI1C,8OAAC;gBAAK,WAAU;;oBAAgC;oBACxC;oBAAY;oBAAK;;;;;;;0BAGzB,8OAAC,qIAAM;gBACL,SAAQ;gBACR,SAAS,IAAM,iBAAiB,cAAc;gBAC9C,UAAU,CAAC,eAAe;gBAC1B,cAAW;;oBACZ;kCAEC,8OAAC,sOAAY;wBAAC,WAAU;;;;;;;;;;;;;;;;;;AAIhC","debugId":null}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/hooks/useApplicationsFilters.ts"],"sourcesContent":["import { useSearchParams, useRouter } from \"next/navigation\";\n\nexport function useApplicationsFilters() {\n  const searchParams = useSearchParams();\n  const router = useRouter();\n\n  // Get filter values from URL\n  const statusFilter = searchParams.get(\"status\") || \"all\";\n  const typeFilter = searchParams.get(\"type\") || \"all\";\n  const searchFilter = searchParams.get(\"search\") || \"\";\n  const sortOrder = searchParams.get(\"sortOrder\") || \"desc\";\n\n  const updateSearchParams = (updates: Record<string, string>) => {\n    const params = new URLSearchParams(searchParams);\n    Object.entries(updates).forEach(([key, value]) => {\n      if (value === \"all\" || value === \"\") {\n        params.delete(key);\n      } else {\n        params.set(key, value);\n      }\n    });\n    params.set(\"page\", \"1\"); // Reset to first page when filtering\n    router.push(`?${params.toString()}`);\n  };\n\n  return {\n    filters: {\n      status: statusFilter,\n      type: typeFilter,\n      search: searchFilter,\n      sortOrder,\n    },\n    updateSearchParams,\n  };\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS;IACd,MAAM,eAAe,IAAA,qJAAe;IACpC,MAAM,SAAS,IAAA,+IAAS;IAExB,6BAA6B;IAC7B,MAAM,eAAe,aAAa,GAAG,CAAC,aAAa;IACnD,MAAM,aAAa,aAAa,GAAG,CAAC,WAAW;IAC/C,MAAM,eAAe,aAAa,GAAG,CAAC,aAAa;IACnD,MAAM,YAAY,aAAa,GAAG,CAAC,gBAAgB;IAEnD,MAAM,qBAAqB,CAAC;QAC1B,MAAM,SAAS,IAAI,gBAAgB;QACnC,OAAO,OAAO,CAAC,SAAS,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM;YAC3C,IAAI,UAAU,SAAS,UAAU,IAAI;gBACnC,OAAO,MAAM,CAAC;YAChB,OAAO;gBACL,OAAO,GAAG,CAAC,KAAK;YAClB;QACF;QACA,OAAO,GAAG,CAAC,QAAQ,MAAM,qCAAqC;QAC9D,OAAO,IAAI,CAAC,CAAC,CAAC,EAAE,OAAO,QAAQ,IAAI;IACrC;IAEA,OAAO;QACL,SAAS;YACP,QAAQ;YACR,MAAM;YACN,QAAQ;YACR;QACF;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 404, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/hooks/useApplicationsSelection.ts"],"sourcesContent":["import { useState } from \"react\";\n\nexport function useApplicationsSelection() {\n  const [selectedApplicationIds, setSelectedApplicationIds] = useState<number[]>([]);\n\n  const handleSelectAll = (checked: boolean, applications: { id: number }[]) => {\n    if (checked) {\n      setSelectedApplicationIds(applications.map(app => app.id));\n    } else {\n      setSelectedApplicationIds([]);\n    }\n  };\n\n  const handleSelectApplication = (applicationId: number, checked: boolean) => {\n    if (checked) {\n      setSelectedApplicationIds(prev => [...prev, applicationId]);\n    } else {\n      setSelectedApplicationIds(prev => prev.filter(id => id !== applicationId));\n    }\n  };\n\n  const isAllSelected = (totalApplications: number) =>\n    totalApplications > 0 && selectedApplicationIds.length === totalApplications;\n\n  const isIndeterminate = (totalApplications: number) =>\n    selectedApplicationIds.length > 0 && selectedApplicationIds.length < totalApplications;\n\n  const clearSelection = () => setSelectedApplicationIds([]);\n\n  return {\n    selectedApplicationIds,\n    handleSelectAll,\n    handleSelectApplication,\n    isAllSelected,\n    isIndeterminate,\n    clearSelection,\n  };\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS;IACd,MAAM,CAAC,wBAAwB,0BAA0B,GAAG,IAAA,iNAAQ,EAAW,EAAE;IAEjF,MAAM,kBAAkB,CAAC,SAAkB;QACzC,IAAI,SAAS;YACX,0BAA0B,aAAa,GAAG,CAAC,CAAA,MAAO,IAAI,EAAE;QAC1D,OAAO;YACL,0BAA0B,EAAE;QAC9B;IACF;IAEA,MAAM,0BAA0B,CAAC,eAAuB;QACtD,IAAI,SAAS;YACX,0BAA0B,CAAA,OAAQ;uBAAI;oBAAM;iBAAc;QAC5D,OAAO;YACL,0BAA0B,CAAA,OAAQ,KAAK,MAAM,CAAC,CAAA,KAAM,OAAO;QAC7D;IACF;IAEA,MAAM,gBAAgB,CAAC,oBACrB,oBAAoB,KAAK,uBAAuB,MAAM,KAAK;IAE7D,MAAM,kBAAkB,CAAC,oBACvB,uBAAuB,MAAM,GAAG,KAAK,uBAAuB,MAAM,GAAG;IAEvE,MAAM,iBAAiB,IAAM,0BAA0B,EAAE;IAEzD,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 445, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n          className,\n        )}\n        ref={ref}\n        {...props}\n      />\n    );\n  },\n);\nInput.displayName = \"Input\";\n\nexport { Input };\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,mNAAgB,CAC5B,CAAC,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAO,EAAE;IAC9B,qBACE,8OAAC;QACC,MAAM;QACN,WAAW,IAAA,kIAAE,EACX,2WACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;AAEF,MAAM,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 473, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        \"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Label }\n"],"names":[],"mappings":";;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,MAAM,EACb,SAAS,EACT,GAAG,OAC8C;IACjD,qBACE,8OAAC,yKAAmB;QAClB,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,uNACA;QAED,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 500, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/select.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AANA;;;;;;AAQA,MAAM,SAAS,0KAAoB;AAEnC,MAAM,cAAc,2KAAqB;AAEzC,MAAM,cAAc,2KAAqB;AAEzC,MAAM,8BAAgB,mNAAgB,CAGpC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,8OAAC,6KAAuB;QACtB,KAAK;QACL,WAAW,IAAA,kIAAE,EACX,mTACA;QAED,GAAG,KAAK;;YAER;0BACD,8OAAC,0KAAoB;gBAAC,OAAO;0BAC3B,cAAA,8OAAC,mOAAW;oBAAC,WAAU;;;;;;;;;;;;;;;;;AAI7B,cAAc,WAAW,GAAG,6KAAuB,CAAC,WAAW;AAE/D,MAAM,qCAAuB,mNAAgB,CAG3C,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,oLAA8B;QAC7B,KAAK;QACL,WAAW,IAAA,kIAAE,EACX,wDACA;QAED,GAAG,KAAK;kBAET,cAAA,8OAAC,6NAAS;YAAC,WAAU;;;;;;;;;;;AAGzB,qBAAqB,WAAW,GAAG,oLAA8B,CAAC,WAAW;AAE7E,MAAM,uCAAyB,mNAAgB,CAG7C,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,sLAAgC;QAC/B,KAAK;QACL,WAAW,IAAA,kIAAE,EACX,wDACA;QAED,GAAG,KAAK;kBAET,cAAA,8OAAC,mOAAW;YAAC,WAAU;;;;;;;;;;;AAG3B,uBAAuB,WAAW,GAChC,sLAAgC,CAAC,WAAW;AAE9C,MAAM,8BAAgB,mNAAgB,CAGpC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,WAAW,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACzD,8OAAC,4KAAsB;kBACrB,cAAA,8OAAC,6KAAuB;YACtB,KAAK;YACL,WAAW,IAAA,kIAAE,EACX,ucACA,aAAa,YACX,mIACF;YAEF,UAAU;YACT,GAAG,KAAK;;8BAET,8OAAC;;;;;8BACD,8OAAC,8KAAwB;oBACvB,WAAW,IAAA,kIAAE,EACX,OACA,aAAa,YACX;8BAGH;;;;;;8BAEH,8OAAC;;;;;;;;;;;;;;;;AAIP,cAAc,WAAW,GAAG,6KAAuB,CAAC,WAAW;AAE/D,MAAM,4BAAc,mNAAgB,CAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,2KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,kIAAE,EAAC,0CAA0C;QACvD,GAAG,KAAK;;;;;;AAGb,YAAY,WAAW,GAAG,2KAAqB,CAAC,WAAW;AAE3D,MAAM,2BAAa,mNAAgB,CAGjC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,8OAAC,0KAAoB;QACnB,KAAK;QACL,WAAW,IAAA,kIAAE,EACX,6NACA;QAED,GAAG,KAAK;;0BAET,8OAAC;gBAAK,WAAU;0BACd,cAAA,8OAAC,mLAA6B;8BAC5B,cAAA,8OAAC,6MAAK;wBAAC,WAAU;;;;;;;;;;;;;;;;0BAIrB,8OAAC,8KAAwB;0BAAE;;;;;;;;;;;;AAG/B,WAAW,WAAW,GAAG,0KAAoB,CAAC,WAAW;AAEzD,MAAM,gCAAkB,mNAAgB,CAGtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,+KAAyB;QACxB,KAAK;QACL,WAAW,IAAA,kIAAE,EAAC,4BAA4B;QACzC,GAAG,KAAK;;;;;;AAGb,gBAAgB,WAAW,GAAG,+KAAyB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 700, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/applications/_components/ApplicationsFilters.tsx"],"sourcesContent":["import { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\n\ninterface ApplicationsFiltersProps {\n  filters: {\n    status: string;\n    type: string;\n    search: string;\n    sortOrder: string;\n  };\n  onFilterChange: (updates: Record<string, string>) => void;\n}\n\nexport default function ApplicationsFilters({ filters, onFilterChange }: ApplicationsFiltersProps) {\n  return (\n    <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-4\">\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"status-filter\">Status</Label>\n        <Select value={filters.status} onValueChange={(value) => onFilterChange({ status: value })} data-testid=\"filter-status\">\n          <SelectTrigger>\n            <SelectValue placeholder=\"Any\" />\n          </SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"all\">Any</SelectItem>\n            <SelectItem value=\"SUBMITTED\">Submitted</SelectItem>\n            <SelectItem value=\"IN_REVIEW\">In Review</SelectItem>\n            <SelectItem value=\"APPROVED\">Approved</SelectItem>\n            <SelectItem value=\"REJECTED\">Rejected</SelectItem>\n          </SelectContent>\n        </Select>\n      </div>\n\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"type-filter\">Type</Label>\n        <Select value={filters.type} onValueChange={(value) => onFilterChange({ type: value })} data-testid=\"filter-type\">\n          <SelectTrigger>\n            <SelectValue placeholder=\"All types\" />\n          </SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"all\">All Types</SelectItem>\n            <SelectItem value=\"ADOPTER\">Adopter</SelectItem>\n            <SelectItem value=\"FOSTER\">Foster</SelectItem>\n          </SelectContent>\n        </Select>\n      </div>\n\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"search-filter\">Search</Label>\n        <Input\n          id=\"search-filter\"\n          placeholder=\"Search by name or email...\"\n          value={filters.search}\n          onChange={(e) => onFilterChange({ search: e.target.value })}\n          onBlur={(e) => onFilterChange({ search: e.target.value })}\n          onKeyDown={(e) => {\n            if (e.key === \"Enter\") {\n              onFilterChange({ search: e.currentTarget.value });\n            }\n          }}\n          data-testid=\"filter-search\"\n        />\n      </div>\n\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"sort-filter\">Sort By</Label>\n        <Select\n          value={filters.sortOrder}\n          onValueChange={(value) => {\n            onFilterChange({ sortOrder: value });\n          }}\n          data-testid=\"sort-submittedAt\"\n        >\n          <SelectTrigger>\n            <SelectValue placeholder=\"Sort by...\" />\n          </SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"desc\">Newest First</SelectItem>\n            <SelectItem value=\"asc\">Oldest First</SelectItem>\n          </SelectContent>\n        </Select>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;;;;;AAkBe,SAAS,oBAAoB,EAAE,OAAO,EAAE,cAAc,EAA4B;IAC/F,qBACE,8OAAC;QAAI,WAAU;;0BACb,8OAAC;gBAAI,WAAU;;kCACb,8OAAC,mIAAK;wBAAC,SAAQ;kCAAgB;;;;;;kCAC/B,8OAAC,qIAAM;wBAAC,OAAO,QAAQ,MAAM;wBAAE,eAAe,CAAC,QAAU,eAAe;gCAAE,QAAQ;4BAAM;wBAAI,eAAY;;0CACtG,8OAAC,4IAAa;0CACZ,cAAA,8OAAC,0IAAW;oCAAC,aAAY;;;;;;;;;;;0CAE3B,8OAAC,4IAAa;;kDACZ,8OAAC,yIAAU;wCAAC,OAAM;kDAAM;;;;;;kDACxB,8OAAC,yIAAU;wCAAC,OAAM;kDAAY;;;;;;kDAC9B,8OAAC,yIAAU;wCAAC,OAAM;kDAAY;;;;;;kDAC9B,8OAAC,yIAAU;wCAAC,OAAM;kDAAW;;;;;;kDAC7B,8OAAC,yIAAU;wCAAC,OAAM;kDAAW;;;;;;;;;;;;;;;;;;;;;;;;0BAKnC,8OAAC;gBAAI,WAAU;;kCACb,8OAAC,mIAAK;wBAAC,SAAQ;kCAAc;;;;;;kCAC7B,8OAAC,qIAAM;wBAAC,OAAO,QAAQ,IAAI;wBAAE,eAAe,CAAC,QAAU,eAAe;gCAAE,MAAM;4BAAM;wBAAI,eAAY;;0CAClG,8OAAC,4IAAa;0CACZ,cAAA,8OAAC,0IAAW;oCAAC,aAAY;;;;;;;;;;;0CAE3B,8OAAC,4IAAa;;kDACZ,8OAAC,yIAAU;wCAAC,OAAM;kDAAM;;;;;;kDACxB,8OAAC,yIAAU;wCAAC,OAAM;kDAAU;;;;;;kDAC5B,8OAAC,yIAAU;wCAAC,OAAM;kDAAS;;;;;;;;;;;;;;;;;;;;;;;;0BAKjC,8OAAC;gBAAI,WAAU;;kCACb,8OAAC,mIAAK;wBAAC,SAAQ;kCAAgB;;;;;;kCAC/B,8OAAC,mIAAK;wBACJ,IAAG;wBACH,aAAY;wBACZ,OAAO,QAAQ,MAAM;wBACrB,UAAU,CAAC,IAAM,eAAe;gCAAE,QAAQ,EAAE,MAAM,CAAC,KAAK;4BAAC;wBACzD,QAAQ,CAAC,IAAM,eAAe;gCAAE,QAAQ,EAAE,MAAM,CAAC,KAAK;4BAAC;wBACvD,WAAW,CAAC;4BACV,IAAI,EAAE,GAAG,KAAK,SAAS;gCACrB,eAAe;oCAAE,QAAQ,EAAE,aAAa,CAAC,KAAK;gCAAC;4BACjD;wBACF;wBACA,eAAY;;;;;;;;;;;;0BAIhB,8OAAC;gBAAI,WAAU;;kCACb,8OAAC,mIAAK;wBAAC,SAAQ;kCAAc;;;;;;kCAC7B,8OAAC,qIAAM;wBACL,OAAO,QAAQ,SAAS;wBACxB,eAAe,CAAC;4BACd,eAAe;gCAAE,WAAW;4BAAM;wBACpC;wBACA,eAAY;;0CAEZ,8OAAC,4IAAa;0CACZ,cAAA,8OAAC,0IAAW;oCAAC,aAAY;;;;;;;;;;;0CAE3B,8OAAC,4IAAa;;kDACZ,8OAAC,yIAAU;wCAAC,OAAM;kDAAO;;;;;;kDACzB,8OAAC,yIAAU;wCAAC,OAAM;kDAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMpC","debugId":null}},
    {"offset": {"line": 1002, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/table.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Table({ className, ...props }: React.ComponentProps<\"table\">) {\n  return (\n    <div\n      data-slot=\"table-container\"\n      className=\"relative w-full overflow-x-auto\"\n    >\n      <table\n        data-slot=\"table\"\n        className={cn(\"w-full caption-bottom text-sm\", className)}\n        {...props}\n      />\n    </div>\n  )\n}\n\nfunction TableHeader({ className, ...props }: React.ComponentProps<\"thead\">) {\n  return (\n    <thead\n      data-slot=\"table-header\"\n      className={cn(\"[&_tr]:border-b\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction TableBody({ className, ...props }: React.ComponentProps<\"tbody\">) {\n  return (\n    <tbody\n      data-slot=\"table-body\"\n      className={cn(\"[&_tr:last-child]:border-0\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction TableFooter({ className, ...props }: React.ComponentProps<\"tfoot\">) {\n  return (\n    <tfoot\n      data-slot=\"table-footer\"\n      className={cn(\n        \"bg-muted/50 border-t font-medium [&>tr]:last:border-b-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TableRow({ className, ...props }: React.ComponentProps<\"tr\">) {\n  return (\n    <tr\n      data-slot=\"table-row\"\n      className={cn(\n        \"hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TableHead({ className, ...props }: React.ComponentProps<\"th\">) {\n  return (\n    <th\n      data-slot=\"table-head\"\n      className={cn(\n        \"text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TableCell({ className, ...props }: React.ComponentProps<\"td\">) {\n  return (\n    <td\n      data-slot=\"table-cell\"\n      className={cn(\n        \"p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TableCaption({\n  className,\n  ...props\n}: React.ComponentProps<\"caption\">) {\n  return (\n    <caption\n      data-slot=\"table-caption\"\n      className={cn(\"text-muted-foreground mt-4 text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAIA;AAJA;;;AAMA,SAAS,MAAM,EAAE,SAAS,EAAE,GAAG,OAAsC;IACnE,qBACE,8OAAC;QACC,aAAU;QACV,WAAU;kBAEV,cAAA,8OAAC;YACC,aAAU;YACV,WAAW,IAAA,kIAAE,EAAC,iCAAiC;YAC9C,GAAG,KAAK;;;;;;;;;;;AAIjB;AAEA,SAAS,YAAY,EAAE,SAAS,EAAE,GAAG,OAAsC;IACzE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,mBAAmB;QAChC,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,UAAU,EAAE,SAAS,EAAE,GAAG,OAAsC;IACvE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EAAE,SAAS,EAAE,GAAG,OAAsC;IACzE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,2DACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,SAAS,EAAE,SAAS,EAAE,GAAG,OAAmC;IACnE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,+EACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,UAAU,EAAE,SAAS,EAAE,GAAG,OAAmC;IACpE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,sJACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,UAAU,EAAE,SAAS,EAAE,GAAG,OAAmC;IACpE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,0GACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,aAAa,EACpB,SAAS,EACT,GAAG,OAC6B;IAChC,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,sCAAsC;QACnD,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 1126, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/badge.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  },\n);\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  );\n}\n\nexport { Badge, badgeVariants };\n"],"names":[],"mappings":";;;;;;;AACA;AAEA;;;;AAEA,MAAM,gBAAgB,IAAA,uKAAG,EACvB,wKACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,WACE;YACF,aACE;YACF,SAAS;QACX;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAOF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBACE,8OAAC;QAAI,WAAW,IAAA,kIAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAExE","debugId":null}},
    {"offset": {"line": 1168, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/checkbox.tsx"],"sourcesContent":["\"use client\";\n\nimport * as React from \"react\";\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\";\nimport { Check } from \"lucide-react\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst Checkbox = React.forwardRef<\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <CheckboxPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n      className,\n    )}\n    {...props}\n  >\n    <CheckboxPrimitive.Indicator\n      className={cn(\"flex items-center justify-center text-current\")}\n    >\n      <Check className=\"h-4 w-4\" />\n    </CheckboxPrimitive.Indicator>\n  </CheckboxPrimitive.Root>\n));\nCheckbox.displayName = CheckboxPrimitive.Root.displayName;\n\nexport { Checkbox };\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,yBAAW,mNAAgB,CAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,4KAAsB;QACrB,KAAK;QACL,WAAW,IAAA,kIAAE,EACX,sQACA;QAED,GAAG,KAAK;kBAET,cAAA,8OAAC,iLAA2B;YAC1B,WAAW,IAAA,kIAAE,EAAC;sBAEd,cAAA,8OAAC,6MAAK;gBAAC,WAAU;;;;;;;;;;;;;;;;AAIvB,SAAS,WAAW,GAAG,4KAAsB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 1212, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/utils/dog-utils.ts"],"sourcesContent":["import { DogSize } from \"@prisma/client\";\n\nexport function calculateAge(dob: Date | null | undefined): number | null {\n  if (!dob) return null;\n\n  const diff = Date.now() - new Date(dob).getTime();\n  const ageDate = new Date(diff);\n\n  return Math.abs(ageDate.getUTCFullYear() - 1970);\n}\n\nexport function isSenior(dob: Date | null | undefined): boolean {\n  const age = calculateAge(dob);\n  // Default to 'true' for seniors if age is unknown, as this is a senior dog rescue.\n  return (age || 8) >= 8;\n}\n\nexport function getSizeFromWeight(weight: number | null | undefined): DogSize {\n  if (!weight) return DogSize.UNKNOWN;\n\n  if (weight < 8) return DogSize.TOY;\n  if (weight < 20) return DogSize.SMALL;\n  if (weight < 45) return DogSize.MEDIUM;\n\n  return DogSize.LARGE;\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEO,SAAS,aAAa,GAA4B;IACvD,IAAI,CAAC,KAAK,OAAO;IAEjB,MAAM,OAAO,KAAK,GAAG,KAAK,IAAI,KAAK,KAAK,OAAO;IAC/C,MAAM,UAAU,IAAI,KAAK;IAEzB,OAAO,KAAK,GAAG,CAAC,QAAQ,cAAc,KAAK;AAC7C;AAEO,SAAS,SAAS,GAA4B;IACnD,MAAM,MAAM,aAAa;IACzB,mFAAmF;IACnF,OAAO,CAAC,OAAO,CAAC,KAAK;AACvB;AAEO,SAAS,kBAAkB,MAAiC;IACjE,IAAI,CAAC,QAAQ,OAAO,wIAAO,CAAC,OAAO;IAEnC,IAAI,SAAS,GAAG,OAAO,wIAAO,CAAC,GAAG;IAClC,IAAI,SAAS,IAAI,OAAO,wIAAO,CAAC,KAAK;IACrC,IAAI,SAAS,IAAI,OAAO,wIAAO,CAAC,MAAM;IAEtC,OAAO,wIAAO,CAAC,KAAK;AACtB","debugId":null}},
    {"offset": {"line": 1244, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/format.ts"],"sourcesContent":["/**\n * Formatting utilities for consistent display of missing/null values and dog data formatting\n */\n\nimport { calculateAge } from \"./utils/dog-utils\";\nimport { humanizeEnum } from \"./utils\";\nimport { Gender, DogSize } from \"@prisma/client\";\n\n/**\n * Returns the value if it's truthy and non-empty, otherwise returns the fallback\n */\nexport const missing = (value: string | null | undefined, fallback = 'N/A'): string =>\n  value && value.trim() !== '' ? value : fallback;\n\n/**\n * Format dog age for display\n */\nexport const formatDogAge = (dateOfBirth: Date | null): string => {\n  if (!dateOfBirth) return missing(null);\n  const age = calculateAge(dateOfBirth);\n  return age ? `${age} years` : missing(null);\n};\n\n/**\n * Format dog gender for display\n */\nexport const formatDogGender = (gender: Gender | null): string => {\n  return gender ? humanizeEnum(gender) : missing(null);\n};\n\n/**\n * Format dog size for display\n */\nexport const formatDogSize = (size: DogSize | null): string => {\n  return size ? humanizeEnum(size) : missing(null);\n};\n\n/**\n * Format dog weight for display\n */\nexport const formatDogWeight = (weightLbs: number | null): string => {\n  return weightLbs ? `${weightLbs} lbs` : missing(null);\n};\n\n/**\n * Format date for display (e.g., \"Jan 15, 2024\")\n */\nexport const formatDisplayDate = (date: Date): string => {\n  return new Date(date).toLocaleDateString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric'\n  });\n};\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;;;;;AAED;AACA;AAAA;;;AAMO,MAAM,UAAU,CAAC,OAAkC,WAAW,KAAK,GACxE,SAAS,MAAM,IAAI,OAAO,KAAK,QAAQ;AAKlC,MAAM,eAAe,CAAC;IAC3B,IAAI,CAAC,aAAa,OAAO,QAAQ;IACjC,MAAM,MAAM,IAAA,4IAAY,EAAC;IACzB,OAAO,MAAM,GAAG,IAAI,MAAM,CAAC,GAAG,QAAQ;AACxC;AAKO,MAAM,kBAAkB,CAAC;IAC9B,OAAO,SAAS,IAAA,qIAAY,EAAC,UAAU,QAAQ;AACjD;AAKO,MAAM,gBAAgB,CAAC;IAC5B,OAAO,OAAO,IAAA,qIAAY,EAAC,QAAQ,QAAQ;AAC7C;AAKO,MAAM,kBAAkB,CAAC;IAC9B,OAAO,YAAY,GAAG,UAAU,IAAI,CAAC,GAAG,QAAQ;AAClD;AAKO,MAAM,oBAAoB,CAAC;IAChC,OAAO,IAAI,KAAK,MAAM,kBAAkB,CAAC,SAAS;QAChD,MAAM;QACN,OAAO;QACP,KAAK;IACP;AACF","debugId":null}},
    {"offset": {"line": 1291, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/applications/_components/ApplicationsTable.tsx"],"sourcesContent":["import {\n  Table,\n  TableBody,\n  TableCaption,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from \"@/components/ui/table\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Button } from \"@/components/ui/button\";\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport Link from \"next/link\";\nimport { getAppStatusVariant } from \"@/lib/utils\";\nimport { formatDisplayDate } from \"@/lib/format\";\nimport { ApplicationListItem } from \"@/lib/view-models/applications\";\nimport { missing } from \"@/lib/format\";\n\ninterface ApplicationsTableProps {\n  applications: ApplicationListItem[];\n  selectedApplicationIds: number[];\n  allSelected: boolean;\n  indeterminate: boolean;\n  onSelectAll: (checked: boolean) => void;\n  onSelectApplication: (applicationId: number, checked: boolean) => void;\n  totalCount: number;\n}\n\nexport function ApplicationsTable({\n  applications,\n  selectedApplicationIds,\n  allSelected,\n  indeterminate,\n  onSelectAll,\n  onSelectApplication,\n  totalCount,\n}: ApplicationsTableProps) {\n  return (\n    <Table role=\"table\" aria-label=\"Applications management table\" data-testid=\"admin-applications-table\">\n      <TableCaption>\n        A list of all submitted applications. Showing {applications.length} of {totalCount} applications.\n      </TableCaption>\n      <TableHeader>\n        <TableRow role=\"row\">\n          <TableHead className=\"w-[50px]\" role=\"columnheader\" aria-sort=\"none\">\n            <Checkbox\n              checked={allSelected ? true : indeterminate ? \"indeterminate\" : false}\n              onCheckedChange={(checked) => onSelectAll(checked as boolean)}\n              aria-label=\"Select all applications\"\n            />\n          </TableHead>\n          <TableHead role=\"columnheader\" aria-sort=\"none\">Submitted</TableHead>\n          <TableHead role=\"columnheader\" aria-sort=\"none\">Name</TableHead>\n          <TableHead role=\"columnheader\" aria-sort=\"none\">Email</TableHead>\n          <TableHead role=\"columnheader\" aria-sort=\"none\">Type</TableHead>\n          <TableHead role=\"columnheader\" aria-sort=\"none\">Status</TableHead>\n          <TableHead className=\"text-right\" role=\"columnheader\" aria-sort=\"none\">Actions</TableHead>\n        </TableRow>\n      </TableHeader>\n      <TableBody>\n        {applications.map((app) => (\n          <TableRow key={app.id} data-testid=\"admin-application-row\">\n            <TableCell>\n              <Checkbox\n                checked={selectedApplicationIds.includes(app.id)}\n                onCheckedChange={(checked) => onSelectApplication(app.id, checked as boolean)}\n                aria-label={`Select application from ${missing(app.applicantName, 'Unknown')}`}\n              />\n            </TableCell>\n            <TableCell>\n{formatDisplayDate(app.createdAt)}\n            </TableCell>\n            <TableCell className=\"font-medium\">\n              {missing(app.applicantName, 'Unknown')}\n            </TableCell>\n            <TableCell>{missing(app.applicantEmail, 'Unknown')}</TableCell>\n            <TableCell>{app.applicationType}</TableCell>\n            <TableCell>\n              <Badge variant={getAppStatusVariant(app.status)}>\n                {app.status}\n              </Badge>\n            </TableCell>\n            <TableCell className=\"text-right\">\n              <Button variant=\"outline\" size=\"sm\" asChild>\n                <Link href={`/admin/applications/${app.id}`}>\n                  View/Edit\n                </Link>\n              </Button>\n            </TableCell>\n          </TableRow>\n        ))}\n      </TableBody>\n    </Table>\n  );\n}\n"],"names":[],"mappings":";;;;;AAAA;AASA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;AAcO,SAAS,kBAAkB,EAChC,YAAY,EACZ,sBAAsB,EACtB,WAAW,EACX,aAAa,EACb,WAAW,EACX,mBAAmB,EACnB,UAAU,EACa;IACvB,qBACE,8OAAC,mIAAK;QAAC,MAAK;QAAQ,cAAW;QAAgC,eAAY;;0BACzE,8OAAC,0IAAY;;oBAAC;oBACmC,aAAa,MAAM;oBAAC;oBAAK;oBAAW;;;;;;;0BAErF,8OAAC,yIAAW;0BACV,cAAA,8OAAC,sIAAQ;oBAAC,MAAK;;sCACb,8OAAC,uIAAS;4BAAC,WAAU;4BAAW,MAAK;4BAAe,aAAU;sCAC5D,cAAA,8OAAC,yIAAQ;gCACP,SAAS,cAAc,OAAO,gBAAgB,kBAAkB;gCAChE,iBAAiB,CAAC,UAAY,YAAY;gCAC1C,cAAW;;;;;;;;;;;sCAGf,8OAAC,uIAAS;4BAAC,MAAK;4BAAe,aAAU;sCAAO;;;;;;sCAChD,8OAAC,uIAAS;4BAAC,MAAK;4BAAe,aAAU;sCAAO;;;;;;sCAChD,8OAAC,uIAAS;4BAAC,MAAK;4BAAe,aAAU;sCAAO;;;;;;sCAChD,8OAAC,uIAAS;4BAAC,MAAK;4BAAe,aAAU;sCAAO;;;;;;sCAChD,8OAAC,uIAAS;4BAAC,MAAK;4BAAe,aAAU;sCAAO;;;;;;sCAChD,8OAAC,uIAAS;4BAAC,WAAU;4BAAa,MAAK;4BAAe,aAAU;sCAAO;;;;;;;;;;;;;;;;;0BAG3E,8OAAC,uIAAS;0BACP,aAAa,GAAG,CAAC,CAAC,oBACjB,8OAAC,sIAAQ;wBAAc,eAAY;;0CACjC,8OAAC,uIAAS;0CACR,cAAA,8OAAC,yIAAQ;oCACP,SAAS,uBAAuB,QAAQ,CAAC,IAAI,EAAE;oCAC/C,iBAAiB,CAAC,UAAY,oBAAoB,IAAI,EAAE,EAAE;oCAC1D,cAAY,CAAC,wBAAwB,EAAE,IAAA,wHAAO,EAAC,IAAI,aAAa,EAAE,YAAY;;;;;;;;;;;0CAGlF,8OAAC,uIAAS;0CACrB,IAAA,kIAAiB,EAAC,IAAI,SAAS;;;;;;0CAEpB,8OAAC,uIAAS;gCAAC,WAAU;0CAClB,IAAA,wHAAO,EAAC,IAAI,aAAa,EAAE;;;;;;0CAE9B,8OAAC,uIAAS;0CAAE,IAAA,wHAAO,EAAC,IAAI,cAAc,EAAE;;;;;;0CACxC,8OAAC,uIAAS;0CAAE,IAAI,eAAe;;;;;;0CAC/B,8OAAC,uIAAS;0CACR,cAAA,8OAAC,mIAAK;oCAAC,SAAS,IAAA,4IAAmB,EAAC,IAAI,MAAM;8CAC3C,IAAI,MAAM;;;;;;;;;;;0CAGf,8OAAC,uIAAS;gCAAC,WAAU;0CACnB,cAAA,8OAAC,qIAAM;oCAAC,SAAQ;oCAAU,MAAK;oCAAK,OAAO;8CACzC,cAAA,8OAAC,uKAAI;wCAAC,MAAM,CAAC,oBAAoB,EAAE,IAAI,EAAE,EAAE;kDAAE;;;;;;;;;;;;;;;;;uBAvBpC,IAAI,EAAE;;;;;;;;;;;;;;;;AAiC/B","debugId":null}},
    {"offset": {"line": 1528, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/textarea.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Textarea({ className, ...props }: React.ComponentProps<\"textarea\">) {\n  return (\n    <textarea\n      data-slot=\"textarea\"\n      className={cn(\n        \"border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Textarea }\n"],"names":[],"mappings":";;;;;AAEA;;;AAEA,SAAS,SAAS,EAAE,SAAS,EAAE,GAAG,OAAyC;IACzE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,ucACA;QAED,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 1552, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/dialog.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { XIcon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Dialog({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Root>) {\n  return <DialogPrimitive.Root data-slot=\"dialog\" {...props} />\n}\n\nfunction DialogTrigger({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {\n  return <DialogPrimitive.Trigger data-slot=\"dialog-trigger\" {...props} />\n}\n\nfunction DialogPortal({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Portal>) {\n  return <DialogPrimitive.Portal data-slot=\"dialog-portal\" {...props} />\n}\n\nfunction DialogClose({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Close>) {\n  return <DialogPrimitive.Close data-slot=\"dialog-close\" {...props} />\n}\n\nfunction DialogOverlay({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {\n  return (\n    <DialogPrimitive.Overlay\n      data-slot=\"dialog-overlay\"\n      className={cn(\n        \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DialogContent({\n  className,\n  children,\n  showCloseButton = true,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Content> & {\n  showCloseButton?: boolean\n}) {\n  return (\n    <DialogPortal data-slot=\"dialog-portal\">\n      <DialogOverlay />\n      <DialogPrimitive.Content\n        data-slot=\"dialog-content\"\n        className={cn(\n          \"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n        {showCloseButton && (\n          <DialogPrimitive.Close\n            data-slot=\"dialog-close\"\n            className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\"\n          >\n            <XIcon />\n            <span className=\"sr-only\">Close</span>\n          </DialogPrimitive.Close>\n        )}\n      </DialogPrimitive.Content>\n    </DialogPortal>\n  )\n}\n\nfunction DialogHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"dialog-header\"\n      className={cn(\"flex flex-col gap-2 text-center sm:text-left\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction DialogFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"dialog-footer\"\n      className={cn(\n        \"flex flex-col-reverse gap-2 sm:flex-row sm:justify-end\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DialogTitle({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Title>) {\n  return (\n    <DialogPrimitive.Title\n      data-slot=\"dialog-title\"\n      className={cn(\"text-lg leading-none font-semibold\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction DialogDescription({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Description>) {\n  return (\n    <DialogPrimitive.Description\n      data-slot=\"dialog-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogOverlay,\n  DialogPortal,\n  DialogTitle,\n  DialogTrigger,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AAEA;AANA;;;;;AAQA,SAAS,OAAO,EACd,GAAG,OAC+C;IAClD,qBAAO,8OAAC,0KAAoB;QAAC,aAAU;QAAU,GAAG,KAAK;;;;;;AAC3D;AAEA,SAAS,cAAc,EACrB,GAAG,OACkD;IACrD,qBAAO,8OAAC,6KAAuB;QAAC,aAAU;QAAkB,GAAG,KAAK;;;;;;AACtE;AAEA,SAAS,aAAa,EACpB,GAAG,OACiD;IACpD,qBAAO,8OAAC,4KAAsB;QAAC,aAAU;QAAiB,GAAG,KAAK;;;;;;AACpE;AAEA,SAAS,YAAY,EACnB,GAAG,OACgD;IACnD,qBAAO,8OAAC,2KAAqB;QAAC,aAAU;QAAgB,GAAG,KAAK;;;;;;AAClE;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,GAAG,OACkD;IACrD,qBACE,8OAAC,6KAAuB;QACtB,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,0JACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,QAAQ,EACR,kBAAkB,IAAI,EACtB,GAAG,OAGJ;IACC,qBACE,8OAAC;QAAa,aAAU;;0BACtB,8OAAC;;;;;0BACD,8OAAC,6KAAuB;gBACtB,aAAU;gBACV,WAAW,IAAA,kIAAE,EACX,+WACA;gBAED,GAAG,KAAK;;oBAER;oBACA,iCACC,8OAAC,2KAAqB;wBACpB,aAAU;wBACV,WAAU;;0CAEV,8OAAC,yMAAK;;;;;0CACN,8OAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;AAMtC;AAEA,SAAS,aAAa,EAAE,SAAS,EAAE,GAAG,OAAoC;IACxE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,gDAAgD;QAC7D,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,aAAa,EAAE,SAAS,EAAE,GAAG,OAAoC;IACxE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,0DACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACgD;IACnD,qBACE,8OAAC,2KAAqB;QACpB,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,sCAAsC;QACnD,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,kBAAkB,EACzB,SAAS,EACT,GAAG,OACsD;IACzD,qBACE,8OAAC,iLAA2B;QAC1B,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 1734, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/application.actions.ts"],"sourcesContent":["// lib/actions/application.actions.ts\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { notFound, redirect } from \"next/navigation\";\nimport { prisma } from \"@/lib/db\";\nimport { AppStatus, AppType, Prisma, AuditAction } from \"@prisma/client\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { applicationSchema, profileSchema } from \"@/lib/zod/applicationSchema\"; // Zod schema\nimport { applicationSchema as newApplicationSchema } from \"@/lib/schemas/application.schema\"; // New Zod schema\nimport { z } from \"zod\";\nimport { assertRole } from \"@/lib/actions/profile.actions\";\nimport { UserRole } from \"@prisma/client\";\nimport { ActionResult, ok, fail } from \"@/lib/types\";\nimport { getAllowedStatuses } from \"@/lib/utils\";\nimport { withAudit } from \"@/lib/audit/withAudit\";\nimport { getCurrentUserId } from \"./audit.actions\";\nimport { getSSRUser } from \"@/lib/auth/session.server\";\nimport { missing } from \"@/lib/format\";\nimport { toCsv } from \"@/lib/csv\";\nimport {\n  AdminApplicationDetail,\n  ApplicationListItem,\n  ApplicationHistoryEntry,\n} from \"@/lib/view-models/applications\";\nimport { parseApplicationSearchParams } from \"@/lib/url-pagination\";\n\nconst updateStatusSchema = z.object({\n  appId: z.coerce.number().int().positive({ message: \"Invalid application ID\" }),\n  status: z.nativeEnum(AppStatus, { message: \"Invalid status\" }),\n  statusNotes: z.string().optional(),\n});\n\nfunction parseApplicationIds(formData: FormData): number[] {\n  const raw = formData.get(\"applicationIds\");\n  if (!raw || typeof raw !== \"string\") return [];\n  return raw\n    .split(\",\")\n    .map(s => s.trim())\n    .filter(Boolean)\n    .map(Number)\n    .filter(Number.isFinite);\n}\n\n\nexport async function createApplication(\n  prevState: ActionResult<null>,\n  formData: FormData\n): Promise<ActionResult<null>> {\n\n  const user = await getSSRUser();\n  if (!user) {\n    // This should never happen if middleware is correct, but it's a good guard.\n    return fail(\"Authentication error. Please log in again.\");\n  }\n\n  // Fetch profile data for snapshot\n  const profile = await prisma.profile.findUnique({\n    where: { id: user.id }\n  });\n  if (!profile) {\n    return fail(\"Profile not found. Please contact support.\");\n  }\n\n  const rawData = Object.fromEntries(formData.entries());\n\n  // Coerce form data for validation\n  const coercedData = {\n    ...rawData,\n    formType: rawData.formType,\n    dogId: rawData.dogId ? Number(rawData.dogId) : undefined,\n    yardFenced: rawData.yardFenced ? rawData.yardFenced === 'on' : undefined,\n    // ... add any other coercions (e.g., references)\n  };\n\n  const result = newApplicationSchema.safeParse(coercedData);\n  if (!result.success) {\n    console.warn(\"Application validation failed:\", result.error.flatten().fieldErrors);\n    return fail(\"Validation failed. Please check your entries.\", result.error.flatten().fieldErrors);\n  }\n\n  const { data } = result;\n\n  try {\n    // Use a transaction. It's the only safe way.\n    await prisma.$transaction(async (tx) => {\n\n      await tx.application.create({\n        data: {\n          applicationType: data.formType,\n          status: 'SUBMITTED',\n          reason: data.reason,\n          dogId: data.dogId,\n          profileId: user.id, // <-- Correct\n          submittedAt: new Date(),\n\n          // --- SNAPSHOT COPY FROM PROFILE ---\n          applicantName: profile.name || 'Unknown',\n          applicantEmail: profile.email,\n          // --- FORM DATA (snapshot of what user provided at submission time) ---\n          applicantPhone: data.applicantPhone,\n          address: data.address,\n          housingType: data.housingType,\n          hasYard: data.hasYard,\n          yardFenced: data.yardFenced,\n          otherPets: data.otherPets,\n          vetName: data.vetName,\n          vetPhone: data.vetPhone,\n          homeEnvironmentDescription: data.homeEnvironmentDescription,\n        }\n      });\n\n      // Create references if provided\n      if (data.references && data.references.length > 0) {\n        // Get the application ID we just created - this is tricky in a transaction\n        // We need to create the application first to get the ID\n        // Let me restructure this...\n\n        // Actually, let me get the application ID after creation\n        // For now, let's create references after the transaction\n      }\n    });\n\n    // Handle references outside transaction for simplicity\n    if (data.references && data.references.length > 0) {\n      // Get the application we just created\n      const createdApplication = await prisma.application.findFirst({\n        where: {\n          profileId: user.id,\n          applicationType: data.formType,\n          status: 'SUBMITTED',\n        },\n        orderBy: { createdAt: 'desc' },\n        select: { id: true },\n      });\n\n      if (createdApplication) {\n        await prisma.reference.createMany({\n          data: data.references.map((ref) => ({\n            ...ref,\n            applicationId: createdApplication.id,\n          })),\n        });\n      }\n    }\n  } catch (error) {\n    console.error(\"Application submission error:\", error);\n    return fail(\"A database error occurred. Please try again.\");\n  }\n\n  // Revalidate admin path and redirect user\n  revalidatePath(\"/admin/applications\");\n  const successPath = data.formType === 'ADOPTER' ? '/apply/adopt/success' : '/apply/foster/success';\n  redirect(successPath);\n}\n\nexport async function submitApplication(formData: FormData): Promise<ActionResult<{ applicationId: number }>> {\n  console.log('submitApplication called with formData keys:', Array.from(formData.keys()));\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) {\n    console.log('submitApplication: user not authenticated');\n    return fail(\"Not authenticated\");\n  }\n  console.log('submitApplication: user authenticated, proceeding with submission');\n\n  try {\n    // Parse form data\n    const formType = formData.get('formType') as AppType;\n    const dogId = formData.get('dogId') ? parseInt(formData.get('dogId') as string) : undefined;\n\n    // Optional: applications can target a specific dog or be general interest applications\n    let validatedDogId: number | undefined;\n    if (dogId !== undefined && dogId !== null) {\n      if (isNaN(dogId) || dogId <= 0) {\n        return fail(\"Invalid dog ID provided.\", { dogId: [\"Must be a valid positive number\"] });\n      }\n      validatedDogId = dogId;\n    }\n\n    // Handle references - parse nested array format from form data\n    const parsedReferences: Array<{ name: string; phone: string; relationship: string }> = [];\n    let index = 0;\n    while (true) {\n      const name = formData.get(`references[${index}][name]`) as string;\n      const phone = formData.get(`references[${index}][phone]`) as string;\n      const relationship = formData.get(`references[${index}][relationship]`) as string;\n\n      if (!name) break; // No more references\n\n      parsedReferences.push({\n        name,\n        phone: phone || '',\n        relationship: relationship || '',\n      });\n      index++;\n    }\n\n    // Extract form fields - separate profile and application data\n    const profileData = {\n      firstName: formData.get('firstName') as string,\n      lastName: formData.get('lastName') as string,\n      email: formData.get('email') as string,\n    };\n\n    const applicantData = {\n      applicantPhone: formData.get('applicantPhone') as string || undefined,\n      address: formData.get('address') as string,\n      housingType: (formData.get('housingType') as 'OWN_HOME' | 'RENT_HOME' | 'OWN_APT_CONDO' | 'RENT_APT_CONDO' | 'OTHER') ?? 'OTHER',\n      hasYard: (formData.get('hasYard') as 'YES' | 'NO' | 'SHARED') ?? 'NO',\n      yardFenced: formData.get('yardFenced') === 'on',\n      otherPets: formData.get('otherPets') as string || undefined,\n      vetName: formData.get('vetName') as string || undefined,\n      vetPhone: formData.get('vetPhone') as string || undefined,\n      homeEnvironmentDescription: formData.get('homeEnvironmentDescription') as string,\n    };\n\n    const applicationData = {\n      reason: formData.get('reason') as string,\n      dogId: validatedDogId,\n      references: parsedReferences,\n      ...applicantData, // Include applicant fields in application data\n    };\n\n    // Validate profile data (only name and email)\n    const validatedProfileData = profileSchema.safeParse(profileData);\n    if (!validatedProfileData.success) {\n      const fieldErrors = validatedProfileData.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // Validate application data (includes applicant fields)\n    const validatedApplicationData = applicationSchema.safeParse(applicationData);\n    if (!validatedApplicationData.success) {\n      const fieldErrors = validatedApplicationData.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // 1. Separate references from the application data.\n    const { references: validatedReferences, ...applicationFields } = validatedApplicationData.data;\n\n    // 2. Use a transaction to ensure data integrity.\n    let app: { id: number } | undefined;\n    await prisma.$transaction(async (tx) => {\n      // 3. Upsert the user's profile with name and email\n      await tx.profile.upsert({\n        where: { id: user.id },\n        update: {\n          name: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n          email: validatedProfileData.data.email,\n        },\n        create: {\n          id: user.id,\n          name: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n          email: validatedProfileData.data.email,\n          role: UserRole.VOLUNTEER, // Default role for new profiles\n        },\n      });\n\n      // 4. Create the application with application-specific data only\n      const applicationData: Prisma.ApplicationCreateInput = {\n        applicationType: formType,\n        profileId: user.id,\n        status: AppStatus.SUBMITTED,\n        submittedAt: new Date(),\n        reason: applicationFields.reason,\n        applicantName: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n        applicantEmail: validatedProfileData.data.email,\n      };\n\n      // Add optional fields if they exist\n      if (applicationFields.dogId !== undefined) applicationData.dog = { connect: { id: applicationFields.dogId } };\n      if (applicationFields.applicantPhone !== undefined) applicationData.applicantPhone = applicationFields.applicantPhone;\n      if (applicationFields.address !== undefined) applicationData.address = applicationFields.address;\n      if (applicationFields.housingType !== undefined) applicationData.housingType = applicationFields.housingType;\n      if (applicationFields.hasYard !== undefined) applicationData.hasYard = applicationFields.hasYard;\n      if (applicationFields.yardFenced !== undefined) applicationData.yardFenced = applicationFields.yardFenced;\n      if (applicationFields.otherPets !== undefined) applicationData.otherPets = applicationFields.otherPets;\n      if (applicationFields.vetName !== undefined) applicationData.vetName = applicationFields.vetName;\n      if (applicationFields.vetPhone !== undefined) applicationData.vetPhone = applicationFields.vetPhone;\n      if (applicationFields.homeEnvironmentDescription !== undefined) applicationData.homeEnvironmentDescription = applicationFields.homeEnvironmentDescription;\n\n      app = await tx.application.create({\n        data: applicationData,\n      });\n\n      // 5. If references exist, create them and link them.\n      if (validatedReferences && validatedReferences.length > 0) {\n        await tx.reference.createMany({\n          data: validatedReferences.map((ref) => ({\n            ...ref,\n            applicationId: app!.id, // Link to the new application\n          })),\n        });\n      }\n    });\n\n    // 6. Revalidate paths\n    revalidatePath(\"/admin/applications\");\n\n    if (!app) {\n      throw new Error(\"Failed to create application\");\n    }\n\n    console.log('submitApplication: application created successfully with ID:', app.id);\n    return ok({ applicationId: app.id }, 'Application submitted successfully!');\n  } catch (error) {\n    console.error(\"Application submission failed:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to submit application.\");\n  }\n}\n\nexport async function updateApplicationStatus(prevState: ActionResult, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n    const userId = await getCurrentUserId();\n\n    const parsed = updateStatusSchema.safeParse(Object.fromEntries(formData.entries()));\n    if (!parsed.success) {\n      const fieldErrors = parsed.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    const { appId, status, statusNotes } = parsed.data;\n\n    // Get current application to validate status transition\n    const currentApplication = await prisma.application.findUnique({\n      where: { id: appId },\n      select: {\n        status: true,\n        applicationType: true,\n      },\n    });\n\n    if (!currentApplication) {\n      return fail(\"Application not found.\");\n    }\n\n    // Validate that the status transition is allowed (server-side enforcement)\n    const allowedStatuses = getAllowedStatuses(currentApplication.applicationType, currentApplication.status);\n    if (!allowedStatuses.includes(status)) {\n      return fail(\"Invalid status transition for this application type.\");\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED\n    if ((status === AppStatus.APPROVED || status === AppStatus.REJECTED) &&\n        (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required when moving to approved or rejected status.\", { statusNotes: [\"Required for terminal status changes\"] });\n    }\n\n    await withAudit(\n      async (tx) => {\n        const application = await tx.application.update({\n          where: { id: appId },\n          data: {\n            status,\n            statusNotes: statusNotes || null,\n          },\n          select: {\n            applicationType: true,\n            profileId: true,\n          },\n        });\n\n        // Write to append-only ApplicationAudit table\n        await tx.applicationAudit.create({\n          data: {\n            applicationId: appId,\n            actorId: userId,\n            oldStatus: currentApplication.status,\n            newStatus: status,\n            note: statusNotes || `Status changed from ${currentApplication.status} to ${status}`,\n          },\n        });\n\n        if (application.applicationType === AppType.FOSTER && status === AppStatus.APPROVED) {\n          await tx.fosterProfile.upsert({\n            where: { profileId: application.profileId },\n            update: {},\n            create: {\n              profileId: application.profileId,\n            },\n          });\n        }\n\n        return application;\n      },\n      {\n        actorId: userId,\n        action: AuditAction.APPLICATION_STATUS_CHANGE,\n        entityType: 'application',\n        entityId: appId,\n        note: `Status changed from ${currentApplication.status} to ${status}`,\n      },\n      prisma\n    );\n\n    revalidatePath(`/admin/applications/${appId}`);\n    revalidatePath(\"/admin/applications\");\n\n    return ok(null, \"Application status updated successfully!\");\n  } catch (error) {\n    return fail(error instanceof Error ? error.message : \"Failed to update status\");\n  }\n}\n\nexport async function getApplicationById(id: number): Promise<AdminApplicationDetail> {\n  const parsed = z.object({ id: z.coerce.number().int().positive() }).safeParse({ id });\n  if (!parsed.success) {\n    throw new Error(\"Invalid application ID\");\n  }\n\n  const application = await prisma.application.findUnique({\n    where: { id },\n    select: {\n      id: true,\n      createdAt: true,\n      updatedAt: true,\n      applicationType: true,\n      status: true,\n      statusNotes: true,\n      profileId: true,\n      applicantName: true,\n      applicantEmail: true,\n      applicantPhone: true,\n      address: true,\n      housingType: true,\n      hasYard: true,\n      yardFenced: true,\n      otherPets: true,\n      vetName: true,\n      vetPhone: true,\n      homeEnvironmentDescription: true,\n      reason: true,\n      references: true,\n      dog: {\n        select: {\n          id: true,\n          name: true,\n          status: true,\n          bioPublic: true,\n        },\n      },\n    },\n  });\n  if (!application) notFound();\n\n  // 2. DELETE ALL JSON.parse logic. It's not needed.\n  // const formData = JSON.parse(application.formDataJson);\n  // return { ...application, formData };\n\n  // Decrypt PII fields from profile before returning\n\n  return {\n    ...application,\n    housingTypeLabel: application.housingType || \"Not specified\",\n    hasYardLabel:\n      application.hasYard === \"YES\"\n        ? \"Yes\"\n        : application.hasYard === \"NO\"\n        ? \"No\"\n        : application.hasYard === \"SHARED\"\n        ? \"Shared\"\n        : \"Not specified\",\n    yardFencedLabel:\n      application.yardFenced === true\n        ? \"Yes\"\n        : application.yardFenced === false\n        ? \"No\"\n        : \"Not specified\",\n    otherPetsLabel: application.otherPets || \"Not specified\",\n    homeEnvironmentDescriptionLabel: application.homeEnvironmentDescription || \"Not specified\",\n  };\n}\n\nexport async function getAllApplications(searchParams?: { [key: string]: string | undefined }): Promise<{\n    applications: ApplicationListItem[];\n    pagination: {\n        currentPage: number;\n        totalPages: number;\n        totalCount: number;\n        hasNextPage: boolean;\n        hasPreviousPage: boolean;\n    };\n}> {\n    await assertRole(UserRole.STAFF);\n\n    // Parse and validate search parameters using shared helper\n    const validatedParams = parseApplicationSearchParams(searchParams || {});\n\n    // Validate status filter\n    if (validatedParams.status && validatedParams.status !== \"all\") {\n        if (!Object.values(AppStatus).includes(validatedParams.status as AppStatus)) {\n            throw new Error(`Invalid status filter: ${validatedParams.status}`);\n        }\n    }\n\n    // Validate type filter\n    if (validatedParams.type && validatedParams.type !== \"all\") {\n        if (!Object.values(AppType).includes(validatedParams.type as AppType)) {\n            throw new Error(`Invalid type filter: ${validatedParams.type}`);\n        }\n    }\n\n    const offset = (validatedParams.page - 1) * validatedParams.limit;\n\n    // Build where clause for filtering\n    const where: Prisma.ApplicationWhereInput = {};\n\n    if (validatedParams.status && validatedParams.status !== \"all\") {\n        where.status = validatedParams.status as AppStatus;\n    }\n\n    if (validatedParams.type && validatedParams.type !== \"all\") {\n        where.applicationType = validatedParams.type as AppType;\n    }\n\n    if (validatedParams.search) {\n        where.OR = [\n            {\n                applicantName: {\n                    contains: validatedParams.search,\n                    mode: \"insensitive\"\n                }\n            },\n            {\n                applicantEmail: {\n                    contains: validatedParams.search,\n                    mode: \"insensitive\"\n                }\n            }\n        ];\n    }\n\n    const [applications, totalCount] = await Promise.all([\n        prisma.application.findMany({\n            where,\n            select: {\n                id: true,\n                createdAt: true,\n                updatedAt: true,\n                applicationType: true,\n                status: true,\n                applicantName: true,\n                applicantEmail: true,\n                reason: true,\n                dog: {\n                    select: {\n                        id: true,\n                        name: true,\n                        status: true,\n                    },\n                },\n            },\n            orderBy: { [validatedParams.sortBy]: validatedParams.sortOrder },\n            skip: offset,\n            take: validatedParams.limit,\n        }),\n        prisma.application.count({ where }),\n    ]);\n\n    const totalPages = Math.ceil(totalCount / validatedParams.limit);\n\n    return {\n        applications: applications as ApplicationListItem[],\n        pagination: {\n            currentPage: validatedParams.page,\n            totalPages,\n            totalCount,\n            hasNextPage: validatedParams.page < totalPages,\n            hasPreviousPage: validatedParams.page > 1,\n        },\n    };\n}\n\nexport async function getUserApplications(profileId: string) {\n    const parsed = z.object({ profileId: z.string().uuid() }).safeParse({ profileId });\n    if (!parsed.success) {\n        throw new Error(\"Invalid profile ID\");\n    }\n\n    const applications = await prisma.application.findMany({\n        where: { profileId },\n        include: {\n            references: true,\n        },\n        orderBy: { createdAt: 'desc' }\n    });\n\n    return applications;\n}\n\n// Form action wrapper for updateApplicationStatus\nexport async function updateApplicationStatusForm(formData: FormData) {\n  return updateApplicationStatus(ok(null), formData);\n}\n\nconst bulkUpdateSchema = z.object({\n  appIds: z.array(z.coerce.number().int().positive({ message: \"Invalid application ID\" })),\n  status: z.nativeEnum(AppStatus, { message: \"Invalid status\" }),\n  statusNotes: z.string().optional(),\n});\n\nexport async function bulkUpdateApplicationStatus(\n  appIds: number[],\n  status: AppStatus,\n  statusNotes?: string\n): Promise<ActionResult<{ ok: number[]; failed: { id: number; reason: string }[] }>> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = bulkUpdateSchema.safeParse({ appIds, status, statusNotes });\n    if (!parsed.success) {\n      const fieldErrors = parsed.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED/WITHDRAWN\n    const requiresNotes: AppStatus[] = [AppStatus.APPROVED, AppStatus.REJECTED, AppStatus.WITHDRAWN]\n    if (requiresNotes.includes(status) && (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required when moving to approved, rejected, or withdrawn status.\", { statusNotes: [\"Required for terminal status changes\"] });\n    }\n\n    // Get current user for authentication\n    const supabase = await createClient();\n    const { data: { user: updater } } = await supabase.auth.getUser();\n    if (!updater) {\n      return fail(\"Authentication required.\");\n    }\n\n    // Get updater's role from database\n    const updaterProfile = await prisma.profile.findUnique({\n      where: { id: updater.id },\n      select: { role: true },\n    });\n\n    if (!updaterProfile || (updaterProfile.role !== UserRole.ADMIN && updaterProfile.role !== UserRole.STAFF)) {\n      return fail(\"Insufficient permissions.\");\n    }\n\n    // Get current applications to validate status transitions\n    const currentApplications = await prisma.application.findMany({\n      where: { id: { in: appIds } },\n      select: {\n        id: true,\n        status: true,\n        applicationType: true,\n      },\n    });\n\n    const appMap = new Map(currentApplications.map(app => [app.id, app]));\n    const successfulIds: number[] = [];\n    const failed: { id: number; reason: string }[] = [];\n\n    // Validate each transition and collect failures\n    for (const appId of appIds) {\n      const currentApp = appMap.get(appId);\n      if (!currentApp) {\n        failed.push({ id: appId, reason: \"Application not found\" });\n        continue;\n      }\n\n      // Validate that the status transition is allowed\n      const allowedStatuses = getAllowedStatuses(currentApp.applicationType, currentApp.status);\n      if (!allowedStatuses.includes(status)) {\n        failed.push({\n          id: appId,\n          reason: `Invalid status transition from ${currentApp.status} for ${currentApp.applicationType} application`\n        });\n        continue;\n      }\n\n      successfulIds.push(appId);\n    }\n\n    // Update successful applications and write audit records\n    if (successfulIds.length > 0) {\n      await prisma.$transaction(async (tx) => {\n        // Update applications\n        await tx.application.updateMany({\n          where: { id: { in: successfulIds } },\n          data: {\n            status,\n            statusNotes: statusNotes || null,\n          },\n        });\n\n        // Write to append-only ApplicationAudit table for each updated application\n        await tx.applicationAudit.createMany({\n          data: successfulIds.map(appId => {\n            const currentApp = appMap.get(appId)!;\n            return {\n              applicationId: appId,\n              actorId: updater.id,\n              oldStatus: currentApp.status,\n              newStatus: status,\n              note: statusNotes || `Bulk status change from ${currentApp.status} to ${status}`,\n            };\n          }),\n        });\n      });\n\n      // Revalidate on success\n      revalidatePath(\"/admin/applications\");\n    }\n\n    return ok({ ok: successfulIds, failed }, `Updated ${successfulIds.length} application${successfulIds.length !== 1 ? 's' : ''} successfully${failed.length > 0 ? `, ${failed.length} failed` : ''}.`);\n  } catch (error) {\n    return fail(error instanceof Error ? error.message : \"An unexpected error occurred.\");\n  }\n}\n\nexport async function getApplicationHistory(applicationId: number): Promise<ApplicationHistoryEntry[]> {\n  await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n  const history = await prisma.applicationAudit.findMany({\n    where: { applicationId },\n    select: {\n      id: true,\n      applicationId: true,\n      oldStatus: true,\n      newStatus: true,\n      note: true,\n      createdAt: true,\n      actor: {\n        select: {\n          name: true,\n          email: true,\n        },\n      },\n    },\n    orderBy: { createdAt: \"desc\" },\n  });\n\n  return history as ApplicationHistoryEntry[];\n}\n\n// Server actions for useActionState (form-based)\nexport async function bulkAssignApplications(\n  prevState: ActionResult,\n  formData: FormData\n): Promise<ActionResult> {\n  try {\n    await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n    const applicationIds = formData.getAll(\"applicationIds\").map(id => parseInt(id as string));\n    const staffId = formData.get(\"staffId\") as string;\n\n    if (!staffId || applicationIds.length === 0) {\n      return fail(\"Staff member and applications are required\");\n    }\n\n    // Verify staff user exists\n    const staffUser = await prisma.profile.findUnique({\n      where: { id: staffId },\n      select: { id: true, role: true },\n    });\n\n    if (!staffUser || (staffUser.role !== UserRole.STAFF && staffUser.role !== UserRole.ADMIN)) {\n      return fail(\"Invalid staff member selected\");\n    }\n\n    // Perform bulk update\n    const updateResult = await prisma.application.updateMany({\n      where: {\n        id: { in: applicationIds },\n      },\n      data: {\n        assignedToUserId: staffId,\n        updatedAt: new Date(),\n      },\n    });\n\n    revalidatePath(\"/admin/applications\");\n\n    return ok(null, `Successfully assigned ${updateResult.count} application(s)`);\n\n  } catch (error) {\n    console.error(\"Bulk assign error:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to assign applications\");\n  }\n}\n\nexport async function bulkUpdateApplications(\n  prevState: ActionResult<{ failed?: { id: number; reason: string }[] }>,\n  formData: FormData\n): Promise<ActionResult<{ failed?: { id: number; reason: string }[] }>> {\n  try {\n    await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n    const applicationIds = parseApplicationIds(formData);\n    const status = formData.get(\"status\") as AppStatus;\n    const statusNotes = formData.get(\"statusNotes\") as string;\n\n    if (applicationIds.length === 0) {\n      return fail(\"No applications selected\");\n    }\n\n    if (!status) {\n      return fail(\"Status is required\");\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED/WITHDRAWN\n    const requiresNotes: AppStatus[] = [AppStatus.APPROVED, AppStatus.REJECTED, AppStatus.WITHDRAWN];\n    if (requiresNotes.includes(status) && (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required for terminal status changes\");\n    }\n\n    const result = await bulkUpdateApplicationStatus(\n      applicationIds,\n      status,\n      statusNotes?.trim() || undefined\n    );\n\n    if (result.success) {\n      const successCount = result.data?.ok.length || 0;\n\n      revalidatePath(\"/admin/applications\");\n\n      return ok({ failed: result.data?.failed }, `Successfully updated ${successCount} application(s)`);\n    } else {\n      return fail(result.message || \"Bulk update failed\");\n    }\n\n  } catch (error) {\n    console.error(\"Bulk update error:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to update applications\");\n  }\n}\n\nexport async function exportApplicationsCSV(\n  searchParams: { [key: string]: string | undefined },\n  minimal: boolean\n): Promise<{ success: true; csvData: string; filename: string } | { success: false; message: string }> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const filters = { ...searchParams };\n    delete filters.minimal; // Remove minimal param from filters\n\n    const appData = await getAllApplications(filters);\n    const applications: ApplicationListItem[] = appData.applications;\n\n    // Guard against exporting insane data sets\n    const MAX_EXPORT_ROWS = 10000;\n    if (applications.length > MAX_EXPORT_ROWS) {\n      return {\n        success: false,\n        message: `Export too large: ${applications.length} applications found, maximum allowed is ${MAX_EXPORT_ROWS}. Please apply filters to reduce the dataset size.`\n      };\n    }\n\n    // Generate CSV data\n    let csvData: Record<string, unknown>[];\n    let csvHeaders: string[];\n\n    if (minimal) {\n      // Minimal export: no PII (phone/address)\n      csvData = applications.map(app => ({\n        id: app.id,\n        submitted_date: app.createdAt.toISOString().split('T')[0],\n        name: missing(app.applicantName, 'Unknown'),\n        email: missing(app.applicantEmail, 'Unknown'),\n        type: app.applicationType,\n        status: app.status,\n        dog_name: app.dog?.name || '',\n        reason: app.reason,\n      }));\n      csvHeaders = [\n        'ID', 'Submitted Date', 'Name', 'Email', 'Type', 'Status',\n        'Dog Name', 'Reason'\n      ];\n    } else {\n      // Full export with available fields\n      csvData = applications.map(app => ({\n        id: app.id,\n        submitted_date: app.createdAt.toISOString().split('T')[0],\n        name: missing(app.applicantName, 'Unknown'),\n        email: missing(app.applicantEmail, 'Unknown'),\n        type: app.applicationType,\n        status: app.status,\n        dog_name: app.dog?.name || '',\n        reason: app.reason,\n      }));\n      csvHeaders = [\n        'ID', 'Submitted Date', 'Name', 'Email', 'Type', 'Status',\n        'Dog Name', 'Reason'\n      ];\n    }\n\n    const csvWithBOM = toCsv(csvData, csvHeaders);\n    const filename = `applications-${new Date().toISOString().split('T')[0]}${minimal ? '-minimal' : ''}.csv`;\n\n    return {\n      success: true,\n      csvData: csvWithBOM,\n      filename\n    };\n  } catch (error) {\n    console.error('CSV export error:', error);\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : 'Failed to generate export'\n    };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IAkuBsB,yBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 1746, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/profile.actions.ts"],"sourcesContent":["// lib/actions/profile.actions.ts\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { prisma } from \"@/lib/prisma\";\nimport { UserRole } from \"@prisma/client\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { z } from \"zod\";\nimport { ActionResult } from \"@/lib/types\";\n\nconst createProfileSchema = z.object({\n  name: z.string().optional(),\n});\n\n\n// Add this new function\nexport async function getActingUser(\n  { requireAuth = true }: { requireAuth?: boolean } = {}\n) {\n  // Check for synthetic session headers first (set by middleware)\n  const { headers } = await import('next/headers');\n  const headerData = await headers();\n  const testUserId = headerData.get('x-test-user-id');\n  const testUserRole = headerData.get('x-test-user-role');\n\n  if (testUserId && testUserRole) {\n    // Return a mock/partial User object based on headers\n    return {\n      id: testUserId,\n      email: `test-${testUserRole.toLowerCase()}@example.test`,\n      app_metadata: { role: testUserRole as UserRole },\n    } as {\n      id: string;\n      email: string;\n      app_metadata: { role: UserRole };\n    };\n  }\n\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n\n  if (requireAuth && !user) {\n    redirect(\"/auth/login\");\n  }\n  return user;\n}\n\n// Add this new function\nexport async function requireRole(role: UserRole | UserRole[]) {\n  const user = await getActingUser();\n  if (!user) {\n    // This should be redundant due to getActingUser, but good for type safety\n    throw new Error(\"Authentication required.\");\n  }\n\n  const roles = Array.isArray(role) ? role : [role];\n  const userRole = await getActingUserRole(); // Assumes this queries the DB\n\n  // Role hierarchy: ADMIN can access everything\n  if (userRole === UserRole.ADMIN) {\n    return; // Admin has access to everything\n  }\n\n  if (!roles.includes(userRole)) {\n    throw new Error(\"Unauthorized.\");\n  }\n}\n\n// Defense-in-depth RBAC helper - throws on unauthorized access\nexport async function assertRole(requiredRoles: UserRole | UserRole[]): Promise<void> {\n  const user = await getActingUser();\n  if (!user) {\n    throw new Error(\"Authentication required.\");\n  }\n\n  const userRole = await getActingUserRole();\n  const roles = Array.isArray(requiredRoles) ? requiredRoles : [requiredRoles];\n\n  // ADMIN can access everything\n  if (userRole === UserRole.ADMIN) {\n    return;\n  }\n\n  if (!roles.includes(userRole)) {\n    throw new Error(\"Insufficient permissions.\");\n  }\n}\n\nexport async function createProfile(name: string) {\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) { throw new Error(\"User not authenticated.\"); }\n\n  const parsed = createProfileSchema.safeParse({ name });\n  if (!parsed.success) {\n    throw new Error(parsed.error.issues[0]?.message ?? \"Invalid name\");\n  }\n\n  await prisma.profile.upsert({\n     where: { id: user.id },\n     update: { name: parsed.data.name, email: user.email }, // Update name/email if they exist\n     create: { id: user.id, email: user.email!, name: parsed.data.name },\n  });\n}\n\nexport async function updateUserRole(prevState: ActionResult, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.ADMIN);\n\n    const userId = formData.get('userId') as string;\n    const role = formData.get('role') as UserRole;\n\n    if (!userId || !role) {\n      return {\n        success: false,\n        message: \"Missing required fields\",\n        fieldErrors: undefined,\n        data: null,\n      };\n    }\n\n    // Protect \"last admin\" from demotion\n    const adminCount = await prisma.profile.count({ where: { role: 'ADMIN' } });\n    const user = await prisma.profile.findUnique({ where: { id: userId }, select: { role: true } });\n    if (!user) {\n      return {\n        success: false,\n        message: 'User not found',\n        fieldErrors: { userId: ['User not found'] },\n        data: null,\n      };\n    }\n    if (user.role === 'ADMIN' && role !== 'ADMIN' && adminCount <= 1) {\n      return {\n        success: false,\n        message: 'Cannot demote the last admin',\n        fieldErrors: { role: ['Cannot demote the last admin'] },\n        data: null,\n      };\n    }\n\n    await prisma.profile.update({ where: { id: userId }, data: { role } });\n    revalidatePath('/admin/users');\n    return {\n      success: true,\n      message: 'Role updated successfully',\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch {\n    return {\n      success: false,\n      message: \"Failed to update user role\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function getAllUsers() {\n  if (process.env.NODE_ENV !== 'test') {\n    await assertRole(UserRole.ADMIN);\n  }\n  return await prisma.profile.findMany({\n    orderBy: { email: \"asc\" },\n    select: {\n      id: true,\n      name: true,\n      email: true,\n      role: true,\n    },\n  });\n}\n\nexport async function getAllStaffUsers() {\n  if (process.env.NODE_ENV !== 'test') {\n    await assertRole(UserRole.STAFF);\n  }\n  return await prisma.profile.findMany({\n    where: {\n      role: {\n        in: [UserRole.STAFF, UserRole.ADMIN],\n      },\n    },\n    orderBy: { email: \"asc\" },\n    select: {\n      id: true,\n      name: true,\n      email: true,\n    },\n  });\n}\n\nexport async function getActingUserRole(): Promise<UserRole> {\n  // Check for synthetic session headers first (set by middleware)\n  const { headers } = await import('next/headers');\n  const headerData = await headers();\n  const testUserRole = headerData.get('x-test-user-role');\n\n  if (testUserRole && ['ADMIN', 'STAFF', 'VOLUNTEER'].includes(testUserRole)) {\n    return testUserRole as UserRole;\n  }\n\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n\n  if (!user) {\n    throw new Error(\"Not authenticated\");\n  }\n\n  const profile = await prisma.profile.findUnique({\n    where: { id: user.id },\n    select: { role: true },\n  });\n\n  if (!profile) {\n    throw new Error(\"Profile not found\");\n  }\n\n  return profile.role;\n}\n\nexport async function getUserProfile(userId: string) {\n  // Ensure user can only view their own profile (skip in test environment)\n  if (process.env.NODE_ENV !== 'test') {\n    const currentUser = await getActingUser();\n    if (!currentUser || currentUser.id !== userId) {\n      throw new Error(\"Unauthorized: Can only view your own profile\");\n    }\n  }\n\n  const parsed = z.object({ userId: z.string() }).safeParse({ userId });\n  if (!parsed.success) {\n    throw new Error(\"Invalid user ID\");\n  }\n\n  const profile = await prisma.profile.findUnique({\n    where: { id: userId },\n    select: {\n      name: true,\n      email: true,\n      role: true,\n      trainingCompleted: true,\n      backgroundCheckCompleted: true,\n      shiftCapacity: true,\n      prefersWeekdays: true,\n      prefersMornings: true,\n    },\n  });\n\n  // Return null if profile doesn't exist\n  return profile;\n}\n\nexport async function getUserSignupIds(userId: string) {\n  // Ensure user can only view their own signup IDs (skip in test environment)\n  if (process.env.NODE_ENV !== 'test') {\n    const currentUser = await getActingUser();\n    if (!currentUser || currentUser.id !== userId) {\n      throw new Error(\"Unauthorized: Can only view your own signups\");\n    }\n  }\n\n  const parsed = z.object({ userId: z.string() }).safeParse({ userId });\n  if (!parsed.success) {\n    throw new Error(\"Invalid user ID\");\n  }\n\n  try {\n    const userSignups = await prisma.volunteerShiftSignup.findMany({\n      where: { volunteerId: userId },\n      select: { shiftId: true }\n    });\n\n    return userSignups.map(signup => signup.shiftId);\n  } catch {\n    // Return empty array on any lookup failure (user doesn't exist, etc.)\n    return [];\n  }\n}\n"],"names":[],"mappings":";;;;;;;IA+KsB,mBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 1758, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/toast.tsx"],"sourcesContent":["import { useState, useEffect } from \"react\";\nimport { X } from \"lucide-react\";\nimport { Button } from \"./button\";\n\ntype ToastType = \"success\" | \"error\";\n\ninterface ToastProps {\n  message: string;\n  type: ToastType;\n  onClose: () => void;\n}\n\nfunction Toast({ message, type, onClose }: ToastProps) {\n  useEffect(() => {\n    const timer = setTimeout(onClose, 5000); // Auto close after 5 seconds\n    return () => clearTimeout(timer);\n  }, [onClose]);\n\n  return (\n    <div\n      data-testid={type === \"success\" ? \"toast-success\" : \"toast-error\"}\n      role=\"status\"\n      aria-live=\"polite\"\n      className={`fixed top-4 right-4 z-50 flex items-center gap-2 px-4 py-2 rounded-md shadow-lg ${\n        type === \"success\"\n          ? \"bg-green-500 text-white\"\n          : \"bg-red-500 text-white\"\n      }`}\n    >\n      <span className=\"flex-1\">{message}</span>\n      <Button\n        variant=\"ghost\"\n        size=\"sm\"\n        onClick={onClose}\n        className=\"h-auto p-1 hover:bg-white/20\"\n      >\n        <X className=\"h-4 w-4\" />\n      </Button>\n    </div>\n  );\n}\n\nexport function useToast() {\n  const [toast, setToast] = useState<{\n    message: string;\n    type: ToastType;\n  } | null>(null);\n\n  const showToast = (message: string, type: ToastType) => {\n    setToast({ message, type });\n  };\n\n  const hideToast = () => {\n    setToast(null);\n  };\n\n  const ToastComponent = () =>\n    toast ? (\n      <Toast\n        message={toast.message}\n        type={toast.type}\n        onClose={hideToast}\n      />\n    ) : null;\n\n  return { showToast, ToastComponent };\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;;;;;AAUA,SAAS,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAc;IACnD,IAAA,kNAAS,EAAC;QACR,MAAM,QAAQ,WAAW,SAAS,OAAO,6BAA6B;QACtE,OAAO,IAAM,aAAa;IAC5B,GAAG;QAAC;KAAQ;IAEZ,qBACE,8OAAC;QACC,eAAa,SAAS,YAAY,kBAAkB;QACpD,MAAK;QACL,aAAU;QACV,WAAW,CAAC,gFAAgF,EAC1F,SAAS,YACL,4BACA,yBACJ;;0BAEF,8OAAC;gBAAK,WAAU;0BAAU;;;;;;0BAC1B,8OAAC,qIAAM;gBACL,SAAQ;gBACR,MAAK;gBACL,SAAS;gBACT,WAAU;0BAEV,cAAA,8OAAC,iMAAC;oBAAC,WAAU;;;;;;;;;;;;;;;;;AAIrB;AAEO,SAAS;IACd,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,iNAAQ,EAGxB;IAEV,MAAM,YAAY,CAAC,SAAiB;QAClC,SAAS;YAAE;YAAS;QAAK;IAC3B;IAEA,MAAM,YAAY;QAChB,SAAS;IACX;IAEA,MAAM,iBAAiB,IACrB,sBACE,8OAAC;YACC,SAAS,MAAM,OAAO;YACtB,MAAM,MAAM,IAAI;YAChB,SAAS;;;;;mBAET;IAEN,OAAO;QAAE;QAAW;IAAe;AACrC","debugId":null}},
    {"offset": {"line": 1844, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/types.ts"],"sourcesContent":["// lib/types.ts\n\n/**\n * Result type for server actions - follows Railway-oriented programming pattern\n */\nexport type Result<T, E = Error> = { success: true; data: T } | { success: false; error: E };\n\n/**\n * Canonical action result type for server actions\n */\nexport type ActionResult<T = null> = {\n  data: T | null;\n  success: boolean;\n  message: string | null;\n  fieldErrors?: Record<string, string[]>;\n};\n\n/**\n * Helper constructor for successful ActionResult\n */\nexport function ok<T = null>(data: T, message: string | null = null): ActionResult<T> {\n  return {\n    success: true,\n    message,\n    data,\n    fieldErrors: undefined,\n  };\n}\n\n/**\n * Helper constructor for failed ActionResult\n */\nexport function fail<T = null>(message: string, fieldErrors?: Record<string, string[]>): ActionResult<T> {\n  return {\n    success: false,\n    message,\n    data: null,\n    fieldErrors,\n  } as ActionResult<T>;\n}\n\n/**\n * Helper constructor for ActionResult with default values\n */\nexport function makeActionResult<T>(overrides?: Partial<ActionResult<T>>): ActionResult<T> {\n  return {\n    success: false,\n    message: null,\n    data: null,\n    fieldErrors: undefined,\n    ...overrides,\n  };\n}\n\n/**\n * Canonical dog list item for admin tables and listings\n */\nexport interface DogListItem {\n  id: number;\n  mutt_id: string | null;\n  name: string;\n  breed: string | null;\n  dateOfBirth: Date | null;\n  gender: import(\"@prisma/client\").Gender | null;\n  size: import(\"@prisma/client\").DogSize | null;\n  weight_lbs: number | null;\n  primaryPhotoUrl: string | null;\n  specialNeeds: boolean;\n  bioPublic: string | null;\n  status: import(\"@prisma/client\").DogStatus;\n  fosterProfile?: {\n    name: string | null;\n    email: string;\n  } | null;\n}\n\n/**\n * Public dog list item for adopt page with derived fields\n */\nexport interface PublicDogListItem extends Omit<DogListItem, 'gender' | 'mutt_id'> {\n  gender: import(\"@prisma/client\").Gender;\n  mutt_id: string | null;\n  isSenior: boolean;\n  hasPhotos: boolean;\n}\n\n/**\n * Canonical pagination metadata\n */\nexport interface PaginationMeta {\n  currentPage: number;\n  totalPages: number;\n  totalCount: number;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n}\n"],"names":[],"mappings":"AAAA,eAAe;AAEf;;CAEC;;;;;;;;AAgBM,SAAS,GAAa,IAAO,EAAE,UAAyB,IAAI;IACjE,OAAO;QACL,SAAS;QACT;QACA;QACA,aAAa;IACf;AACF;AAKO,SAAS,KAAe,OAAe,EAAE,WAAsC;IACpF,OAAO;QACL,SAAS;QACT;QACA,MAAM;QACN;IACF;AACF;AAKO,SAAS,iBAAoB,SAAoC;IACtE,OAAO;QACL,SAAS;QACT,SAAS;QACT,MAAM;QACN,aAAa;QACb,GAAG,SAAS;IACd;AACF","debugId":null}},
    {"offset": {"line": 1884, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/applications/_components/AssignToStaffDialog.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState, useTransition, useActionState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/components/ui/dialog\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { bulkAssignApplications } from \"@/lib/actions/application.actions\";\nimport { getAllStaffUsers } from \"@/lib/actions/profile.actions\";\nimport { useToast } from \"@/components/ui/toast\";\nimport { makeActionResult } from \"@/lib/types\";\n\ninterface AssignToStaffDialogProps {\n  selectedApplicationIds: number[];\n  onPendingChange?: (pending: boolean) => void;\n}\n\nexport function AssignToStaffDialog({ selectedApplicationIds, onPendingChange }: AssignToStaffDialogProps) {\n  const { showToast } = useToast();\n  const [selectedStaffId, setSelectedStaffId] = useState(\"\");\n  const [staffUsers, setStaffUsers] = useState<Array<{ id: string; name: string | null; email: string }>>([]);\n  const [isOpen, setIsOpen] = useState(false);\n  const [isPending, startTransition] = useTransition();\n\n  // Fetch staff users when component mounts\n  useEffect(() => {\n    getAllStaffUsers().then(setStaffUsers).catch(console.error);\n  }, []);\n\n  // Server action for bulk assignment\n  const [assignState, assignAction] = useActionState(bulkAssignApplications, makeActionResult());\n\n  // Handle assign action state changes\n  useEffect(() => {\n    if (assignState.message) {\n      showToast(assignState.message, assignState.success ? \"success\" : \"error\");\n      if (assignState.success) {\n        setSelectedStaffId(\"\");\n        setIsOpen(false);\n      }\n    }\n  }, [assignState, showToast]);\n\n  useEffect(() => {\n    onPendingChange?.(isPending);\n  }, [isPending, onPendingChange]);\n\n  const handleAssign = (formData: FormData) => {\n    startTransition(() => {\n      assignAction(formData);\n    });\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={setIsOpen}>\n      <DialogTrigger asChild>\n        <Button variant=\"outline\" disabled={isPending} data-testid=\"btn-bulk-assign\">\n          Assign to Staff\n        </Button>\n      </DialogTrigger>\n      <DialogContent data-testid=\"assign-dialog\">\n        <DialogHeader>\n          <DialogTitle>Assign Applications to Staff</DialogTitle>\n          <DialogDescription>\n            Select a staff member to assign {selectedApplicationIds.length} selected application{selectedApplicationIds.length !== 1 ? 's' : ''} to.\n          </DialogDescription>\n        </DialogHeader>\n        <form action={handleAssign} className=\"py-4\">\n          {selectedApplicationIds.map(id => (\n            <input key={id} type=\"hidden\" name=\"applicationIds\" value={id} />\n          ))}\n          <Select name=\"staffId\" value={selectedStaffId} onValueChange={setSelectedStaffId} data-testid=\"select-assignee\">\n            <SelectTrigger>\n              <SelectValue placeholder=\"Select staff member...\" />\n            </SelectTrigger>\n            <SelectContent>\n              {staffUsers.map((staff) => (\n                <SelectItem key={staff.id} value={staff.id}>\n                  {staff.name || staff.email}\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n          <DialogFooter className=\"mt-4\">\n            <Button\n              type=\"submit\"\n              disabled={!selectedStaffId || isPending}\n              data-testid=\"btn-confirm-assign\"\n            >\n              {isPending ? 'Assigning...' : 'Assign'}\n            </Button>\n          </DialogFooter>\n        </form>\n      </DialogContent>\n    </Dialog>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AASA;AAOA;AACA;AACA;AACA;AAvBA;;;;;;;;;;AA8BO,SAAS,oBAAoB,EAAE,sBAAsB,EAAE,eAAe,EAA4B;IACvG,MAAM,EAAE,SAAS,EAAE,GAAG,IAAA,sIAAQ;IAC9B,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,IAAA,iNAAQ,EAAC;IACvD,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,iNAAQ,EAA4D,EAAE;IAC1G,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,iNAAQ,EAAC;IACrC,MAAM,CAAC,WAAW,gBAAgB,GAAG,IAAA,sNAAa;IAElD,0CAA0C;IAC1C,IAAA,kNAAS,EAAC;QACR,IAAA,0KAAgB,IAAG,IAAI,CAAC,eAAe,KAAK,CAAC,QAAQ,KAAK;IAC5D,GAAG,EAAE;IAEL,oCAAoC;IACpC,MAAM,CAAC,aAAa,aAAa,GAAG,IAAA,uNAAc,EAAC,gLAAsB,EAAE,IAAA,gIAAgB;IAE3F,qCAAqC;IACrC,IAAA,kNAAS,EAAC;QACR,IAAI,YAAY,OAAO,EAAE;YACvB,UAAU,YAAY,OAAO,EAAE,YAAY,OAAO,GAAG,YAAY;YACjE,IAAI,YAAY,OAAO,EAAE;gBACvB,mBAAmB;gBACnB,UAAU;YACZ;QACF;IACF,GAAG;QAAC;QAAa;KAAU;IAE3B,IAAA,kNAAS,EAAC;QACR,kBAAkB;IACpB,GAAG;QAAC;QAAW;KAAgB;IAE/B,MAAM,eAAe,CAAC;QACpB,gBAAgB;YACd,aAAa;QACf;IACF;IAEA,qBACE,8OAAC,qIAAM;QAAC,MAAM;QAAQ,cAAc;;0BAClC,8OAAC,4IAAa;gBAAC,OAAO;0BACpB,cAAA,8OAAC,qIAAM;oBAAC,SAAQ;oBAAU,UAAU;oBAAW,eAAY;8BAAkB;;;;;;;;;;;0BAI/E,8OAAC,4IAAa;gBAAC,eAAY;;kCACzB,8OAAC,2IAAY;;0CACX,8OAAC,0IAAW;0CAAC;;;;;;0CACb,8OAAC,gJAAiB;;oCAAC;oCACgB,uBAAuB,MAAM;oCAAC;oCAAsB,uBAAuB,MAAM,KAAK,IAAI,MAAM;oCAAG;;;;;;;;;;;;;kCAGxI,8OAAC;wBAAK,QAAQ;wBAAc,WAAU;;4BACnC,uBAAuB,GAAG,CAAC,CAAA,mBAC1B,8OAAC;oCAAe,MAAK;oCAAS,MAAK;oCAAiB,OAAO;mCAA/C;;;;;0CAEd,8OAAC,qIAAM;gCAAC,MAAK;gCAAU,OAAO;gCAAiB,eAAe;gCAAoB,eAAY;;kDAC5F,8OAAC,4IAAa;kDACZ,cAAA,8OAAC,0IAAW;4CAAC,aAAY;;;;;;;;;;;kDAE3B,8OAAC,4IAAa;kDACX,WAAW,GAAG,CAAC,CAAC,sBACf,8OAAC,yIAAU;gDAAgB,OAAO,MAAM,EAAE;0DACvC,MAAM,IAAI,IAAI,MAAM,KAAK;+CADX,MAAM,EAAE;;;;;;;;;;;;;;;;0CAM/B,8OAAC,2IAAY;gCAAC,WAAU;0CACtB,cAAA,8OAAC,qIAAM;oCACL,MAAK;oCACL,UAAU,CAAC,mBAAmB;oCAC9B,eAAY;8CAEX,YAAY,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAO5C","debugId":null}},
    {"offset": {"line": 2087, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/dropdown-menu.tsx"],"sourcesContent":["\"use client\";\n\nimport * as React from \"react\";\nimport * as DropdownMenuPrimitive from \"@radix-ui/react-dropdown-menu\";\nimport { Check, ChevronRight, Circle } from \"lucide-react\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst DropdownMenu = DropdownMenuPrimitive.Root;\n\nconst DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;\n\nconst DropdownMenuGroup = DropdownMenuPrimitive.Group;\n\nconst DropdownMenuPortal = DropdownMenuPrimitive.Portal;\n\nconst DropdownMenuSub = DropdownMenuPrimitive.Sub;\n\nconst DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;\n\nconst DropdownMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {\n    inset?: boolean;\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className,\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto\" />\n  </DropdownMenuPrimitive.SubTrigger>\n));\nDropdownMenuSubTrigger.displayName =\n  DropdownMenuPrimitive.SubTrigger.displayName;\n\nconst DropdownMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\",\n      className,\n    )}\n    {...props}\n  />\n));\nDropdownMenuSubContent.displayName =\n  DropdownMenuPrimitive.SubContent.displayName;\n\nconst DropdownMenuContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <DropdownMenuPrimitive.Portal>\n    <DropdownMenuPrimitive.Content\n      ref={ref}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md\",\n        \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\",\n        className,\n      )}\n      {...props}\n    />\n  </DropdownMenuPrimitive.Portal>\n));\nDropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;\n\nconst DropdownMenuItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {\n    inset?: boolean;\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0\",\n      inset && \"pl-8\",\n      className,\n    )}\n    {...props}\n  />\n));\nDropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <DropdownMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className,\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.CheckboxItem>\n));\nDropdownMenuCheckboxItem.displayName =\n  DropdownMenuPrimitive.CheckboxItem.displayName;\n\nconst DropdownMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className,\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.RadioItem>\n));\nDropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;\n\nconst DropdownMenuLabel = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {\n    inset?: boolean;\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className,\n    )}\n    {...props}\n  />\n));\nDropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;\n\nconst DropdownMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n));\nDropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;\n\nconst DropdownMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\"ml-auto text-xs tracking-widest opacity-60\", className)}\n      {...props}\n    />\n  );\n};\nDropdownMenuShortcut.displayName = \"DropdownMenuShortcut\";\n\nexport {\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuShortcut,\n  DropdownMenuGroup,\n  DropdownMenuPortal,\n  DropdownMenuSub,\n  DropdownMenuSubContent,\n  DropdownMenuSubTrigger,\n  DropdownMenuRadioGroup,\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AANA;;;;;;AAQA,MAAM,eAAe,oLAA0B;AAE/C,MAAM,sBAAsB,uLAA6B;AAEzD,MAAM,oBAAoB,qLAA2B;AAErD,MAAM,qBAAqB,sLAA4B;AAEvD,MAAM,kBAAkB,mLAAyB;AAEjD,MAAM,yBAAyB,0LAAgC;AAE/D,MAAM,uCAAyB,mNAAgB,CAK7C,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBAC3C,8OAAC,0LAAgC;QAC/B,KAAK;QACL,WAAW,IAAA,kIAAE,EACX,0MACA,SAAS,QACT;QAED,GAAG,KAAK;;YAER;0BACD,8OAAC,sOAAY;gBAAC,WAAU;;;;;;;;;;;;AAG5B,uBAAuB,WAAW,GAChC,0LAAgC,CAAC,WAAW;AAE9C,MAAM,uCAAyB,mNAAgB,CAG7C,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,0LAAgC;QAC/B,KAAK;QACL,WAAW,IAAA,kIAAE,EACX,ifACA;QAED,GAAG,KAAK;;;;;;AAGb,uBAAuB,WAAW,GAChC,0LAAgC,CAAC,WAAW;AAE9C,MAAM,oCAAsB,mNAAgB,CAG1C,CAAC,EAAE,SAAS,EAAE,aAAa,CAAC,EAAE,GAAG,OAAO,EAAE,oBAC1C,8OAAC,sLAA4B;kBAC3B,cAAA,8OAAC,uLAA6B;YAC5B,KAAK;YACL,YAAY;YACZ,WAAW,IAAA,kIAAE,EACX,sLACA,4YACA;YAED,GAAG,KAAK;;;;;;;;;;;AAIf,oBAAoB,WAAW,GAAG,uLAA6B,CAAC,WAAW;AAE3E,MAAM,iCAAmB,mNAAgB,CAKvC,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG,OAAO,EAAE,oBACjC,8OAAC,oLAA0B;QACzB,KAAK;QACL,WAAW,IAAA,kIAAE,EACX,yQACA,SAAS,QACT;QAED,GAAG,KAAK;;;;;;AAGb,iBAAiB,WAAW,GAAG,oLAA0B,CAAC,WAAW;AAErE,MAAM,yCAA2B,mNAAgB,CAG/C,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG,OAAO,EAAE,oBAC7C,8OAAC,4LAAkC;QACjC,KAAK;QACL,WAAW,IAAA,kIAAE,EACX,wOACA;QAEF,SAAS;QACR,GAAG,KAAK;;0BAET,8OAAC;gBAAK,WAAU;0BACd,cAAA,8OAAC,6LAAmC;8BAClC,cAAA,8OAAC,6MAAK;wBAAC,WAAU;;;;;;;;;;;;;;;;YAGpB;;;;;;;AAGL,yBAAyB,WAAW,GAClC,4LAAkC,CAAC,WAAW;AAEhD,MAAM,sCAAwB,mNAAgB,CAG5C,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,8OAAC,yLAA+B;QAC9B,KAAK;QACL,WAAW,IAAA,kIAAE,EACX,wOACA;QAED,GAAG,KAAK;;0BAET,8OAAC;gBAAK,WAAU;0BACd,cAAA,8OAAC,6LAAmC;8BAClC,cAAA,8OAAC,gNAAM;wBAAC,WAAU;;;;;;;;;;;;;;;;YAGrB;;;;;;;AAGL,sBAAsB,WAAW,GAAG,yLAA+B,CAAC,WAAW;AAE/E,MAAM,kCAAoB,mNAAgB,CAKxC,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG,OAAO,EAAE,oBACjC,8OAAC,qLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,kIAAE,EACX,qCACA,SAAS,QACT;QAED,GAAG,KAAK;;;;;;AAGb,kBAAkB,WAAW,GAAG,qLAA2B,CAAC,WAAW;AAEvE,MAAM,sCAAwB,mNAAgB,CAG5C,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC,yLAA+B;QAC9B,KAAK;QACL,WAAW,IAAA,kIAAE,EAAC,4BAA4B;QACzC,GAAG,KAAK;;;;;;AAGb,sBAAsB,WAAW,GAAG,yLAA+B,CAAC,WAAW;AAE/E,MAAM,uBAAuB,CAAC,EAC5B,SAAS,EACT,GAAG,OACmC;IACtC,qBACE,8OAAC;QACC,WAAW,IAAA,kIAAE,EAAC,8CAA8C;QAC3D,GAAG,KAAK;;;;;;AAGf;AACA,qBAAqB,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 2298, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/application.actions.ts"],"sourcesContent":["// lib/actions/application.actions.ts\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { notFound, redirect } from \"next/navigation\";\nimport { prisma } from \"@/lib/db\";\nimport { AppStatus, AppType, Prisma, AuditAction } from \"@prisma/client\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { applicationSchema, profileSchema } from \"@/lib/zod/applicationSchema\"; // Zod schema\nimport { applicationSchema as newApplicationSchema } from \"@/lib/schemas/application.schema\"; // New Zod schema\nimport { z } from \"zod\";\nimport { assertRole } from \"@/lib/actions/profile.actions\";\nimport { UserRole } from \"@prisma/client\";\nimport { ActionResult, ok, fail } from \"@/lib/types\";\nimport { getAllowedStatuses } from \"@/lib/utils\";\nimport { withAudit } from \"@/lib/audit/withAudit\";\nimport { getCurrentUserId } from \"./audit.actions\";\nimport { getSSRUser } from \"@/lib/auth/session.server\";\nimport { missing } from \"@/lib/format\";\nimport { toCsv } from \"@/lib/csv\";\nimport {\n  AdminApplicationDetail,\n  ApplicationListItem,\n  ApplicationHistoryEntry,\n} from \"@/lib/view-models/applications\";\nimport { parseApplicationSearchParams } from \"@/lib/url-pagination\";\n\nconst updateStatusSchema = z.object({\n  appId: z.coerce.number().int().positive({ message: \"Invalid application ID\" }),\n  status: z.nativeEnum(AppStatus, { message: \"Invalid status\" }),\n  statusNotes: z.string().optional(),\n});\n\nfunction parseApplicationIds(formData: FormData): number[] {\n  const raw = formData.get(\"applicationIds\");\n  if (!raw || typeof raw !== \"string\") return [];\n  return raw\n    .split(\",\")\n    .map(s => s.trim())\n    .filter(Boolean)\n    .map(Number)\n    .filter(Number.isFinite);\n}\n\n\nexport async function createApplication(\n  prevState: ActionResult<null>,\n  formData: FormData\n): Promise<ActionResult<null>> {\n\n  const user = await getSSRUser();\n  if (!user) {\n    // This should never happen if middleware is correct, but it's a good guard.\n    return fail(\"Authentication error. Please log in again.\");\n  }\n\n  // Fetch profile data for snapshot\n  const profile = await prisma.profile.findUnique({\n    where: { id: user.id }\n  });\n  if (!profile) {\n    return fail(\"Profile not found. Please contact support.\");\n  }\n\n  const rawData = Object.fromEntries(formData.entries());\n\n  // Coerce form data for validation\n  const coercedData = {\n    ...rawData,\n    formType: rawData.formType,\n    dogId: rawData.dogId ? Number(rawData.dogId) : undefined,\n    yardFenced: rawData.yardFenced ? rawData.yardFenced === 'on' : undefined,\n    // ... add any other coercions (e.g., references)\n  };\n\n  const result = newApplicationSchema.safeParse(coercedData);\n  if (!result.success) {\n    console.warn(\"Application validation failed:\", result.error.flatten().fieldErrors);\n    return fail(\"Validation failed. Please check your entries.\", result.error.flatten().fieldErrors);\n  }\n\n  const { data } = result;\n\n  try {\n    // Use a transaction. It's the only safe way.\n    await prisma.$transaction(async (tx) => {\n\n      await tx.application.create({\n        data: {\n          applicationType: data.formType,\n          status: 'SUBMITTED',\n          reason: data.reason,\n          dogId: data.dogId,\n          profileId: user.id, // <-- Correct\n          submittedAt: new Date(),\n\n          // --- SNAPSHOT COPY FROM PROFILE ---\n          applicantName: profile.name || 'Unknown',\n          applicantEmail: profile.email,\n          // --- FORM DATA (snapshot of what user provided at submission time) ---\n          applicantPhone: data.applicantPhone,\n          address: data.address,\n          housingType: data.housingType,\n          hasYard: data.hasYard,\n          yardFenced: data.yardFenced,\n          otherPets: data.otherPets,\n          vetName: data.vetName,\n          vetPhone: data.vetPhone,\n          homeEnvironmentDescription: data.homeEnvironmentDescription,\n        }\n      });\n\n      // Create references if provided\n      if (data.references && data.references.length > 0) {\n        // Get the application ID we just created - this is tricky in a transaction\n        // We need to create the application first to get the ID\n        // Let me restructure this...\n\n        // Actually, let me get the application ID after creation\n        // For now, let's create references after the transaction\n      }\n    });\n\n    // Handle references outside transaction for simplicity\n    if (data.references && data.references.length > 0) {\n      // Get the application we just created\n      const createdApplication = await prisma.application.findFirst({\n        where: {\n          profileId: user.id,\n          applicationType: data.formType,\n          status: 'SUBMITTED',\n        },\n        orderBy: { createdAt: 'desc' },\n        select: { id: true },\n      });\n\n      if (createdApplication) {\n        await prisma.reference.createMany({\n          data: data.references.map((ref) => ({\n            ...ref,\n            applicationId: createdApplication.id,\n          })),\n        });\n      }\n    }\n  } catch (error) {\n    console.error(\"Application submission error:\", error);\n    return fail(\"A database error occurred. Please try again.\");\n  }\n\n  // Revalidate admin path and redirect user\n  revalidatePath(\"/admin/applications\");\n  const successPath = data.formType === 'ADOPTER' ? '/apply/adopt/success' : '/apply/foster/success';\n  redirect(successPath);\n}\n\nexport async function submitApplication(formData: FormData): Promise<ActionResult<{ applicationId: number }>> {\n  console.log('submitApplication called with formData keys:', Array.from(formData.keys()));\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) {\n    console.log('submitApplication: user not authenticated');\n    return fail(\"Not authenticated\");\n  }\n  console.log('submitApplication: user authenticated, proceeding with submission');\n\n  try {\n    // Parse form data\n    const formType = formData.get('formType') as AppType;\n    const dogId = formData.get('dogId') ? parseInt(formData.get('dogId') as string) : undefined;\n\n    // Optional: applications can target a specific dog or be general interest applications\n    let validatedDogId: number | undefined;\n    if (dogId !== undefined && dogId !== null) {\n      if (isNaN(dogId) || dogId <= 0) {\n        return fail(\"Invalid dog ID provided.\", { dogId: [\"Must be a valid positive number\"] });\n      }\n      validatedDogId = dogId;\n    }\n\n    // Handle references - parse nested array format from form data\n    const parsedReferences: Array<{ name: string; phone: string; relationship: string }> = [];\n    let index = 0;\n    while (true) {\n      const name = formData.get(`references[${index}][name]`) as string;\n      const phone = formData.get(`references[${index}][phone]`) as string;\n      const relationship = formData.get(`references[${index}][relationship]`) as string;\n\n      if (!name) break; // No more references\n\n      parsedReferences.push({\n        name,\n        phone: phone || '',\n        relationship: relationship || '',\n      });\n      index++;\n    }\n\n    // Extract form fields - separate profile and application data\n    const profileData = {\n      firstName: formData.get('firstName') as string,\n      lastName: formData.get('lastName') as string,\n      email: formData.get('email') as string,\n    };\n\n    const applicantData = {\n      applicantPhone: formData.get('applicantPhone') as string || undefined,\n      address: formData.get('address') as string,\n      housingType: (formData.get('housingType') as 'OWN_HOME' | 'RENT_HOME' | 'OWN_APT_CONDO' | 'RENT_APT_CONDO' | 'OTHER') ?? 'OTHER',\n      hasYard: (formData.get('hasYard') as 'YES' | 'NO' | 'SHARED') ?? 'NO',\n      yardFenced: formData.get('yardFenced') === 'on',\n      otherPets: formData.get('otherPets') as string || undefined,\n      vetName: formData.get('vetName') as string || undefined,\n      vetPhone: formData.get('vetPhone') as string || undefined,\n      homeEnvironmentDescription: formData.get('homeEnvironmentDescription') as string,\n    };\n\n    const applicationData = {\n      reason: formData.get('reason') as string,\n      dogId: validatedDogId,\n      references: parsedReferences,\n      ...applicantData, // Include applicant fields in application data\n    };\n\n    // Validate profile data (only name and email)\n    const validatedProfileData = profileSchema.safeParse(profileData);\n    if (!validatedProfileData.success) {\n      const fieldErrors = validatedProfileData.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // Validate application data (includes applicant fields)\n    const validatedApplicationData = applicationSchema.safeParse(applicationData);\n    if (!validatedApplicationData.success) {\n      const fieldErrors = validatedApplicationData.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // 1. Separate references from the application data.\n    const { references: validatedReferences, ...applicationFields } = validatedApplicationData.data;\n\n    // 2. Use a transaction to ensure data integrity.\n    let app: { id: number } | undefined;\n    await prisma.$transaction(async (tx) => {\n      // 3. Upsert the user's profile with name and email\n      await tx.profile.upsert({\n        where: { id: user.id },\n        update: {\n          name: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n          email: validatedProfileData.data.email,\n        },\n        create: {\n          id: user.id,\n          name: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n          email: validatedProfileData.data.email,\n          role: UserRole.VOLUNTEER, // Default role for new profiles\n        },\n      });\n\n      // 4. Create the application with application-specific data only\n      const applicationData: Prisma.ApplicationCreateInput = {\n        applicationType: formType,\n        profileId: user.id,\n        status: AppStatus.SUBMITTED,\n        submittedAt: new Date(),\n        reason: applicationFields.reason,\n        applicantName: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n        applicantEmail: validatedProfileData.data.email,\n      };\n\n      // Add optional fields if they exist\n      if (applicationFields.dogId !== undefined) applicationData.dog = { connect: { id: applicationFields.dogId } };\n      if (applicationFields.applicantPhone !== undefined) applicationData.applicantPhone = applicationFields.applicantPhone;\n      if (applicationFields.address !== undefined) applicationData.address = applicationFields.address;\n      if (applicationFields.housingType !== undefined) applicationData.housingType = applicationFields.housingType;\n      if (applicationFields.hasYard !== undefined) applicationData.hasYard = applicationFields.hasYard;\n      if (applicationFields.yardFenced !== undefined) applicationData.yardFenced = applicationFields.yardFenced;\n      if (applicationFields.otherPets !== undefined) applicationData.otherPets = applicationFields.otherPets;\n      if (applicationFields.vetName !== undefined) applicationData.vetName = applicationFields.vetName;\n      if (applicationFields.vetPhone !== undefined) applicationData.vetPhone = applicationFields.vetPhone;\n      if (applicationFields.homeEnvironmentDescription !== undefined) applicationData.homeEnvironmentDescription = applicationFields.homeEnvironmentDescription;\n\n      app = await tx.application.create({\n        data: applicationData,\n      });\n\n      // 5. If references exist, create them and link them.\n      if (validatedReferences && validatedReferences.length > 0) {\n        await tx.reference.createMany({\n          data: validatedReferences.map((ref) => ({\n            ...ref,\n            applicationId: app!.id, // Link to the new application\n          })),\n        });\n      }\n    });\n\n    // 6. Revalidate paths\n    revalidatePath(\"/admin/applications\");\n\n    if (!app) {\n      throw new Error(\"Failed to create application\");\n    }\n\n    console.log('submitApplication: application created successfully with ID:', app.id);\n    return ok({ applicationId: app.id }, 'Application submitted successfully!');\n  } catch (error) {\n    console.error(\"Application submission failed:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to submit application.\");\n  }\n}\n\nexport async function updateApplicationStatus(prevState: ActionResult, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n    const userId = await getCurrentUserId();\n\n    const parsed = updateStatusSchema.safeParse(Object.fromEntries(formData.entries()));\n    if (!parsed.success) {\n      const fieldErrors = parsed.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    const { appId, status, statusNotes } = parsed.data;\n\n    // Get current application to validate status transition\n    const currentApplication = await prisma.application.findUnique({\n      where: { id: appId },\n      select: {\n        status: true,\n        applicationType: true,\n      },\n    });\n\n    if (!currentApplication) {\n      return fail(\"Application not found.\");\n    }\n\n    // Validate that the status transition is allowed (server-side enforcement)\n    const allowedStatuses = getAllowedStatuses(currentApplication.applicationType, currentApplication.status);\n    if (!allowedStatuses.includes(status)) {\n      return fail(\"Invalid status transition for this application type.\");\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED\n    if ((status === AppStatus.APPROVED || status === AppStatus.REJECTED) &&\n        (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required when moving to approved or rejected status.\", { statusNotes: [\"Required for terminal status changes\"] });\n    }\n\n    await withAudit(\n      async (tx) => {\n        const application = await tx.application.update({\n          where: { id: appId },\n          data: {\n            status,\n            statusNotes: statusNotes || null,\n          },\n          select: {\n            applicationType: true,\n            profileId: true,\n          },\n        });\n\n        // Write to append-only ApplicationAudit table\n        await tx.applicationAudit.create({\n          data: {\n            applicationId: appId,\n            actorId: userId,\n            oldStatus: currentApplication.status,\n            newStatus: status,\n            note: statusNotes || `Status changed from ${currentApplication.status} to ${status}`,\n          },\n        });\n\n        if (application.applicationType === AppType.FOSTER && status === AppStatus.APPROVED) {\n          await tx.fosterProfile.upsert({\n            where: { profileId: application.profileId },\n            update: {},\n            create: {\n              profileId: application.profileId,\n            },\n          });\n        }\n\n        return application;\n      },\n      {\n        actorId: userId,\n        action: AuditAction.APPLICATION_STATUS_CHANGE,\n        entityType: 'application',\n        entityId: appId,\n        note: `Status changed from ${currentApplication.status} to ${status}`,\n      },\n      prisma\n    );\n\n    revalidatePath(`/admin/applications/${appId}`);\n    revalidatePath(\"/admin/applications\");\n\n    return ok(null, \"Application status updated successfully!\");\n  } catch (error) {\n    return fail(error instanceof Error ? error.message : \"Failed to update status\");\n  }\n}\n\nexport async function getApplicationById(id: number): Promise<AdminApplicationDetail> {\n  const parsed = z.object({ id: z.coerce.number().int().positive() }).safeParse({ id });\n  if (!parsed.success) {\n    throw new Error(\"Invalid application ID\");\n  }\n\n  const application = await prisma.application.findUnique({\n    where: { id },\n    select: {\n      id: true,\n      createdAt: true,\n      updatedAt: true,\n      applicationType: true,\n      status: true,\n      statusNotes: true,\n      profileId: true,\n      applicantName: true,\n      applicantEmail: true,\n      applicantPhone: true,\n      address: true,\n      housingType: true,\n      hasYard: true,\n      yardFenced: true,\n      otherPets: true,\n      vetName: true,\n      vetPhone: true,\n      homeEnvironmentDescription: true,\n      reason: true,\n      references: true,\n      dog: {\n        select: {\n          id: true,\n          name: true,\n          status: true,\n          bioPublic: true,\n        },\n      },\n    },\n  });\n  if (!application) notFound();\n\n  // 2. DELETE ALL JSON.parse logic. It's not needed.\n  // const formData = JSON.parse(application.formDataJson);\n  // return { ...application, formData };\n\n  // Decrypt PII fields from profile before returning\n\n  return {\n    ...application,\n    housingTypeLabel: application.housingType || \"Not specified\",\n    hasYardLabel:\n      application.hasYard === \"YES\"\n        ? \"Yes\"\n        : application.hasYard === \"NO\"\n        ? \"No\"\n        : application.hasYard === \"SHARED\"\n        ? \"Shared\"\n        : \"Not specified\",\n    yardFencedLabel:\n      application.yardFenced === true\n        ? \"Yes\"\n        : application.yardFenced === false\n        ? \"No\"\n        : \"Not specified\",\n    otherPetsLabel: application.otherPets || \"Not specified\",\n    homeEnvironmentDescriptionLabel: application.homeEnvironmentDescription || \"Not specified\",\n  };\n}\n\nexport async function getAllApplications(searchParams?: { [key: string]: string | undefined }): Promise<{\n    applications: ApplicationListItem[];\n    pagination: {\n        currentPage: number;\n        totalPages: number;\n        totalCount: number;\n        hasNextPage: boolean;\n        hasPreviousPage: boolean;\n    };\n}> {\n    await assertRole(UserRole.STAFF);\n\n    // Parse and validate search parameters using shared helper\n    const validatedParams = parseApplicationSearchParams(searchParams || {});\n\n    // Validate status filter\n    if (validatedParams.status && validatedParams.status !== \"all\") {\n        if (!Object.values(AppStatus).includes(validatedParams.status as AppStatus)) {\n            throw new Error(`Invalid status filter: ${validatedParams.status}`);\n        }\n    }\n\n    // Validate type filter\n    if (validatedParams.type && validatedParams.type !== \"all\") {\n        if (!Object.values(AppType).includes(validatedParams.type as AppType)) {\n            throw new Error(`Invalid type filter: ${validatedParams.type}`);\n        }\n    }\n\n    const offset = (validatedParams.page - 1) * validatedParams.limit;\n\n    // Build where clause for filtering\n    const where: Prisma.ApplicationWhereInput = {};\n\n    if (validatedParams.status && validatedParams.status !== \"all\") {\n        where.status = validatedParams.status as AppStatus;\n    }\n\n    if (validatedParams.type && validatedParams.type !== \"all\") {\n        where.applicationType = validatedParams.type as AppType;\n    }\n\n    if (validatedParams.search) {\n        where.OR = [\n            {\n                applicantName: {\n                    contains: validatedParams.search,\n                    mode: \"insensitive\"\n                }\n            },\n            {\n                applicantEmail: {\n                    contains: validatedParams.search,\n                    mode: \"insensitive\"\n                }\n            }\n        ];\n    }\n\n    const [applications, totalCount] = await Promise.all([\n        prisma.application.findMany({\n            where,\n            select: {\n                id: true,\n                createdAt: true,\n                updatedAt: true,\n                applicationType: true,\n                status: true,\n                applicantName: true,\n                applicantEmail: true,\n                reason: true,\n                dog: {\n                    select: {\n                        id: true,\n                        name: true,\n                        status: true,\n                    },\n                },\n            },\n            orderBy: { [validatedParams.sortBy]: validatedParams.sortOrder },\n            skip: offset,\n            take: validatedParams.limit,\n        }),\n        prisma.application.count({ where }),\n    ]);\n\n    const totalPages = Math.ceil(totalCount / validatedParams.limit);\n\n    return {\n        applications: applications as ApplicationListItem[],\n        pagination: {\n            currentPage: validatedParams.page,\n            totalPages,\n            totalCount,\n            hasNextPage: validatedParams.page < totalPages,\n            hasPreviousPage: validatedParams.page > 1,\n        },\n    };\n}\n\nexport async function getUserApplications(profileId: string) {\n    const parsed = z.object({ profileId: z.string().uuid() }).safeParse({ profileId });\n    if (!parsed.success) {\n        throw new Error(\"Invalid profile ID\");\n    }\n\n    const applications = await prisma.application.findMany({\n        where: { profileId },\n        include: {\n            references: true,\n        },\n        orderBy: { createdAt: 'desc' }\n    });\n\n    return applications;\n}\n\n// Form action wrapper for updateApplicationStatus\nexport async function updateApplicationStatusForm(formData: FormData) {\n  return updateApplicationStatus(ok(null), formData);\n}\n\nconst bulkUpdateSchema = z.object({\n  appIds: z.array(z.coerce.number().int().positive({ message: \"Invalid application ID\" })),\n  status: z.nativeEnum(AppStatus, { message: \"Invalid status\" }),\n  statusNotes: z.string().optional(),\n});\n\nexport async function bulkUpdateApplicationStatus(\n  appIds: number[],\n  status: AppStatus,\n  statusNotes?: string\n): Promise<ActionResult<{ ok: number[]; failed: { id: number; reason: string }[] }>> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = bulkUpdateSchema.safeParse({ appIds, status, statusNotes });\n    if (!parsed.success) {\n      const fieldErrors = parsed.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED/WITHDRAWN\n    const requiresNotes: AppStatus[] = [AppStatus.APPROVED, AppStatus.REJECTED, AppStatus.WITHDRAWN]\n    if (requiresNotes.includes(status) && (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required when moving to approved, rejected, or withdrawn status.\", { statusNotes: [\"Required for terminal status changes\"] });\n    }\n\n    // Get current user for authentication\n    const supabase = await createClient();\n    const { data: { user: updater } } = await supabase.auth.getUser();\n    if (!updater) {\n      return fail(\"Authentication required.\");\n    }\n\n    // Get updater's role from database\n    const updaterProfile = await prisma.profile.findUnique({\n      where: { id: updater.id },\n      select: { role: true },\n    });\n\n    if (!updaterProfile || (updaterProfile.role !== UserRole.ADMIN && updaterProfile.role !== UserRole.STAFF)) {\n      return fail(\"Insufficient permissions.\");\n    }\n\n    // Get current applications to validate status transitions\n    const currentApplications = await prisma.application.findMany({\n      where: { id: { in: appIds } },\n      select: {\n        id: true,\n        status: true,\n        applicationType: true,\n      },\n    });\n\n    const appMap = new Map(currentApplications.map(app => [app.id, app]));\n    const successfulIds: number[] = [];\n    const failed: { id: number; reason: string }[] = [];\n\n    // Validate each transition and collect failures\n    for (const appId of appIds) {\n      const currentApp = appMap.get(appId);\n      if (!currentApp) {\n        failed.push({ id: appId, reason: \"Application not found\" });\n        continue;\n      }\n\n      // Validate that the status transition is allowed\n      const allowedStatuses = getAllowedStatuses(currentApp.applicationType, currentApp.status);\n      if (!allowedStatuses.includes(status)) {\n        failed.push({\n          id: appId,\n          reason: `Invalid status transition from ${currentApp.status} for ${currentApp.applicationType} application`\n        });\n        continue;\n      }\n\n      successfulIds.push(appId);\n    }\n\n    // Update successful applications and write audit records\n    if (successfulIds.length > 0) {\n      await prisma.$transaction(async (tx) => {\n        // Update applications\n        await tx.application.updateMany({\n          where: { id: { in: successfulIds } },\n          data: {\n            status,\n            statusNotes: statusNotes || null,\n          },\n        });\n\n        // Write to append-only ApplicationAudit table for each updated application\n        await tx.applicationAudit.createMany({\n          data: successfulIds.map(appId => {\n            const currentApp = appMap.get(appId)!;\n            return {\n              applicationId: appId,\n              actorId: updater.id,\n              oldStatus: currentApp.status,\n              newStatus: status,\n              note: statusNotes || `Bulk status change from ${currentApp.status} to ${status}`,\n            };\n          }),\n        });\n      });\n\n      // Revalidate on success\n      revalidatePath(\"/admin/applications\");\n    }\n\n    return ok({ ok: successfulIds, failed }, `Updated ${successfulIds.length} application${successfulIds.length !== 1 ? 's' : ''} successfully${failed.length > 0 ? `, ${failed.length} failed` : ''}.`);\n  } catch (error) {\n    return fail(error instanceof Error ? error.message : \"An unexpected error occurred.\");\n  }\n}\n\nexport async function getApplicationHistory(applicationId: number): Promise<ApplicationHistoryEntry[]> {\n  await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n  const history = await prisma.applicationAudit.findMany({\n    where: { applicationId },\n    select: {\n      id: true,\n      applicationId: true,\n      oldStatus: true,\n      newStatus: true,\n      note: true,\n      createdAt: true,\n      actor: {\n        select: {\n          name: true,\n          email: true,\n        },\n      },\n    },\n    orderBy: { createdAt: \"desc\" },\n  });\n\n  return history as ApplicationHistoryEntry[];\n}\n\n// Server actions for useActionState (form-based)\nexport async function bulkAssignApplications(\n  prevState: ActionResult,\n  formData: FormData\n): Promise<ActionResult> {\n  try {\n    await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n    const applicationIds = formData.getAll(\"applicationIds\").map(id => parseInt(id as string));\n    const staffId = formData.get(\"staffId\") as string;\n\n    if (!staffId || applicationIds.length === 0) {\n      return fail(\"Staff member and applications are required\");\n    }\n\n    // Verify staff user exists\n    const staffUser = await prisma.profile.findUnique({\n      where: { id: staffId },\n      select: { id: true, role: true },\n    });\n\n    if (!staffUser || (staffUser.role !== UserRole.STAFF && staffUser.role !== UserRole.ADMIN)) {\n      return fail(\"Invalid staff member selected\");\n    }\n\n    // Perform bulk update\n    const updateResult = await prisma.application.updateMany({\n      where: {\n        id: { in: applicationIds },\n      },\n      data: {\n        assignedToUserId: staffId,\n        updatedAt: new Date(),\n      },\n    });\n\n    revalidatePath(\"/admin/applications\");\n\n    return ok(null, `Successfully assigned ${updateResult.count} application(s)`);\n\n  } catch (error) {\n    console.error(\"Bulk assign error:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to assign applications\");\n  }\n}\n\nexport async function bulkUpdateApplications(\n  prevState: ActionResult<{ failed?: { id: number; reason: string }[] }>,\n  formData: FormData\n): Promise<ActionResult<{ failed?: { id: number; reason: string }[] }>> {\n  try {\n    await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n    const applicationIds = parseApplicationIds(formData);\n    const status = formData.get(\"status\") as AppStatus;\n    const statusNotes = formData.get(\"statusNotes\") as string;\n\n    if (applicationIds.length === 0) {\n      return fail(\"No applications selected\");\n    }\n\n    if (!status) {\n      return fail(\"Status is required\");\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED/WITHDRAWN\n    const requiresNotes: AppStatus[] = [AppStatus.APPROVED, AppStatus.REJECTED, AppStatus.WITHDRAWN];\n    if (requiresNotes.includes(status) && (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required for terminal status changes\");\n    }\n\n    const result = await bulkUpdateApplicationStatus(\n      applicationIds,\n      status,\n      statusNotes?.trim() || undefined\n    );\n\n    if (result.success) {\n      const successCount = result.data?.ok.length || 0;\n\n      revalidatePath(\"/admin/applications\");\n\n      return ok({ failed: result.data?.failed }, `Successfully updated ${successCount} application(s)`);\n    } else {\n      return fail(result.message || \"Bulk update failed\");\n    }\n\n  } catch (error) {\n    console.error(\"Bulk update error:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to update applications\");\n  }\n}\n\nexport async function exportApplicationsCSV(\n  searchParams: { [key: string]: string | undefined },\n  minimal: boolean\n): Promise<{ success: true; csvData: string; filename: string } | { success: false; message: string }> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const filters = { ...searchParams };\n    delete filters.minimal; // Remove minimal param from filters\n\n    const appData = await getAllApplications(filters);\n    const applications: ApplicationListItem[] = appData.applications;\n\n    // Guard against exporting insane data sets\n    const MAX_EXPORT_ROWS = 10000;\n    if (applications.length > MAX_EXPORT_ROWS) {\n      return {\n        success: false,\n        message: `Export too large: ${applications.length} applications found, maximum allowed is ${MAX_EXPORT_ROWS}. Please apply filters to reduce the dataset size.`\n      };\n    }\n\n    // Generate CSV data\n    let csvData: Record<string, unknown>[];\n    let csvHeaders: string[];\n\n    if (minimal) {\n      // Minimal export: no PII (phone/address)\n      csvData = applications.map(app => ({\n        id: app.id,\n        submitted_date: app.createdAt.toISOString().split('T')[0],\n        name: missing(app.applicantName, 'Unknown'),\n        email: missing(app.applicantEmail, 'Unknown'),\n        type: app.applicationType,\n        status: app.status,\n        dog_name: app.dog?.name || '',\n        reason: app.reason,\n      }));\n      csvHeaders = [\n        'ID', 'Submitted Date', 'Name', 'Email', 'Type', 'Status',\n        'Dog Name', 'Reason'\n      ];\n    } else {\n      // Full export with available fields\n      csvData = applications.map(app => ({\n        id: app.id,\n        submitted_date: app.createdAt.toISOString().split('T')[0],\n        name: missing(app.applicantName, 'Unknown'),\n        email: missing(app.applicantEmail, 'Unknown'),\n        type: app.applicationType,\n        status: app.status,\n        dog_name: app.dog?.name || '',\n        reason: app.reason,\n      }));\n      csvHeaders = [\n        'ID', 'Submitted Date', 'Name', 'Email', 'Type', 'Status',\n        'Dog Name', 'Reason'\n      ];\n    }\n\n    const csvWithBOM = toCsv(csvData, csvHeaders);\n    const filename = `applications-${new Date().toISOString().split('T')[0]}${minimal ? '-minimal' : ''}.csv`;\n\n    return {\n      success: true,\n      csvData: csvWithBOM,\n      filename\n    };\n  } catch (error) {\n    console.error('CSV export error:', error);\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : 'Failed to generate export'\n    };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IA+wBsB,yBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 2310, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/applications/_components/UpdateStatusDropdown.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useActionState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport { ChevronDown } from \"lucide-react\";\nimport { AppStatus } from \"@prisma/client\";\nimport { bulkUpdateApplications } from \"@/lib/actions/application.actions\";\nimport { useToast } from \"@/components/ui/toast\";\nimport { ActionResult, makeActionResult } from \"@/lib/types\";\n\ninterface UpdateStatusDropdownProps {\n  selectedApplicationIds: number[];\n  bulkNotes: string;\n  onResult?: (result: ActionResult<{ failed?: { id: number; reason: string }[] }>) => void;\n  onPendingChange?: (pending: boolean) => void;\n}\n\nexport function UpdateStatusDropdown({\n  selectedApplicationIds,\n  bulkNotes,\n  onResult,\n  onPendingChange,\n}: UpdateStatusDropdownProps) {\n  const { showToast } = useToast();\n\n  const [state, formAction, isPending] = useActionState(\n    bulkUpdateApplications,\n    makeActionResult<{ failed?: { id: number; reason: string }[] }>()\n  );\n\n  useEffect(() => {\n    onPendingChange?.(isPending);\n  }, [isPending, onPendingChange]);\n\n  useEffect(() => {\n    if (state.message) {\n      showToast(state.message, state.success ? \"success\" : \"error\");\n      onResult?.(state);\n    }\n  }, [state, showToast, onResult]);\n\n  const idsValue = selectedApplicationIds.join(\",\");\n\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button variant=\"default\" disabled={isPending || selectedApplicationIds.length === 0} data-testid=\"btn-bulk-update\">\n          {isPending ? 'Processing...' : `Apply to ${selectedApplicationIds.length} selected`}\n          <ChevronDown className=\"ml-2 h-4 w-4\" />\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent align=\"end\">\n        <DropdownMenuItem asChild disabled={isPending}>\n          <form action={formAction}>\n            <input type=\"hidden\" name=\"applicationIds\" value={idsValue} />\n            <input type=\"hidden\" name=\"status\" value={AppStatus.APPROVED} />\n            <input type=\"hidden\" name=\"statusNotes\" value={bulkNotes} />\n            <button type=\"submit\" style={{ all: 'unset', width: '100%' }}>\n              Approve Applications\n            </button>\n          </form>\n        </DropdownMenuItem>\n        <DropdownMenuItem asChild disabled={isPending}>\n          <form action={formAction}>\n            <input type=\"hidden\" name=\"applicationIds\" value={idsValue} />\n            <input type=\"hidden\" name=\"status\" value={AppStatus.REJECTED} />\n            <input type=\"hidden\" name=\"statusNotes\" value={bulkNotes} />\n            <button type=\"submit\" style={{ all: 'unset', width: '100%' }}>\n              Reject Applications\n            </button>\n          </form>\n        </DropdownMenuItem>\n        <DropdownMenuItem asChild disabled={isPending}>\n          <form action={formAction}>\n            <input type=\"hidden\" name=\"applicationIds\" value={idsValue} />\n            <input type=\"hidden\" name=\"status\" value={AppStatus.WITHDRAWN} />\n            <input type=\"hidden\" name=\"statusNotes\" value={bulkNotes} />\n            <button type=\"submit\" style={{ all: 'unset', width: '100%' }}>\n              Withdraw Applications\n            </button>\n          </form>\n        </DropdownMenuItem>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AAdA;;;;;;;;;;AAuBO,SAAS,qBAAqB,EACnC,sBAAsB,EACtB,SAAS,EACT,QAAQ,EACR,eAAe,EACW;IAC1B,MAAM,EAAE,SAAS,EAAE,GAAG,IAAA,sIAAQ;IAE9B,MAAM,CAAC,OAAO,YAAY,UAAU,GAAG,IAAA,uNAAc,EACnD,gLAAsB,EACtB,IAAA,gIAAgB;IAGlB,IAAA,kNAAS,EAAC;QACR,kBAAkB;IACpB,GAAG;QAAC;QAAW;KAAgB;IAE/B,IAAA,kNAAS,EAAC;QACR,IAAI,MAAM,OAAO,EAAE;YACjB,UAAU,MAAM,OAAO,EAAE,MAAM,OAAO,GAAG,YAAY;YACrD,WAAW;QACb;IACF,GAAG;QAAC;QAAO;QAAW;KAAS;IAE/B,MAAM,WAAW,uBAAuB,IAAI,CAAC;IAE7C,qBACE,8OAAC,qJAAY;;0BACX,8OAAC,4JAAmB;gBAAC,OAAO;0BAC1B,cAAA,8OAAC,qIAAM;oBAAC,SAAQ;oBAAU,UAAU,aAAa,uBAAuB,MAAM,KAAK;oBAAG,eAAY;;wBAC/F,YAAY,kBAAkB,CAAC,SAAS,EAAE,uBAAuB,MAAM,CAAC,SAAS,CAAC;sCACnF,8OAAC,mOAAW;4BAAC,WAAU;;;;;;;;;;;;;;;;;0BAG3B,8OAAC,4JAAmB;gBAAC,OAAM;;kCACzB,8OAAC,yJAAgB;wBAAC,OAAO;wBAAC,UAAU;kCAClC,cAAA,8OAAC;4BAAK,QAAQ;;8CACZ,8OAAC;oCAAM,MAAK;oCAAS,MAAK;oCAAiB,OAAO;;;;;;8CAClD,8OAAC;oCAAM,MAAK;oCAAS,MAAK;oCAAS,OAAO,0IAAS,CAAC,QAAQ;;;;;;8CAC5D,8OAAC;oCAAM,MAAK;oCAAS,MAAK;oCAAc,OAAO;;;;;;8CAC/C,8OAAC;oCAAO,MAAK;oCAAS,OAAO;wCAAE,KAAK;wCAAS,OAAO;oCAAO;8CAAG;;;;;;;;;;;;;;;;;kCAKlE,8OAAC,yJAAgB;wBAAC,OAAO;wBAAC,UAAU;kCAClC,cAAA,8OAAC;4BAAK,QAAQ;;8CACZ,8OAAC;oCAAM,MAAK;oCAAS,MAAK;oCAAiB,OAAO;;;;;;8CAClD,8OAAC;oCAAM,MAAK;oCAAS,MAAK;oCAAS,OAAO,0IAAS,CAAC,QAAQ;;;;;;8CAC5D,8OAAC;oCAAM,MAAK;oCAAS,MAAK;oCAAc,OAAO;;;;;;8CAC/C,8OAAC;oCAAO,MAAK;oCAAS,OAAO;wCAAE,KAAK;wCAAS,OAAO;oCAAO;8CAAG;;;;;;;;;;;;;;;;;kCAKlE,8OAAC,yJAAgB;wBAAC,OAAO;wBAAC,UAAU;kCAClC,cAAA,8OAAC;4BAAK,QAAQ;;8CACZ,8OAAC;oCAAM,MAAK;oCAAS,MAAK;oCAAiB,OAAO;;;;;;8CAClD,8OAAC;oCAAM,MAAK;oCAAS,MAAK;oCAAS,OAAO,0IAAS,CAAC,SAAS;;;;;;8CAC7D,8OAAC;oCAAM,MAAK;oCAAS,MAAK;oCAAc,OAAO;;;;;;8CAC/C,8OAAC;oCAAO,MAAK;oCAAS,OAAO;wCAAE,KAAK;wCAAS,OAAO;oCAAO;8CAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQ1E","debugId":null}},
    {"offset": {"line": 2569, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/csv.ts"],"sourcesContent":["// lib/csv.ts\n\n/**\n * Sanitizes a value for CSV export, preventing Excel formula injection attacks\n * and handling null/undefined values safely.\n */\nexport const sanitizeCell = (value: unknown): string => {\n  let s = value == null ? '' : String(value);\n  // Prefix with single quote if starts with formula characters to prevent Excel injection\n  if (/^[=+\\-@]/.test(s)) s = `'${s}`;\n  // Escape quotes by doubling them and wrap in quotes\n  return `\"${s.replace(/\"/g, '\"\"')}\"`;\n};\n\n/**\n * Converts an array of objects to CSV format with headers.\n * @param data Array of objects to convert\n * @param headers Optional custom headers. If not provided, uses object keys from first item\n * @returns CSV string with BOM for Excel UTF-8 compatibility\n */\nexport const toCsv = <T extends Record<string, unknown>>(\n  data: T[],\n  headers?: string[]\n): string => {\n  const headerRow = headers || (data.length > 0 ? Object.keys(data[0]) : []);\n  const csvRows = [\n    headerRow.map(sanitizeCell).join(','),\n    ...data.map(row =>\n      headerRow.map(key => sanitizeCell(row[key])).join(',')\n    )\n  ];\n\n  // Prepend BOM for Excel UTF-8 compatibility\n  return '\\uFEFF' + csvRows.join('\\n') + (csvRows.length > 0 ? '\\n' : '');\n};\n\n/**\n * Downloads CSV data as a file with the given filename.\n * @param filename The name of the file to download (without extension)\n * @param data The CSV data as a string\n */\nexport const downloadCsv = (filename: string, data: string): void => {\n  const blob = new Blob([data], { type: 'text/csv;charset=utf-8;' });\n  const url = URL.createObjectURL(blob);\n\n  // Create a temporary link and trigger download\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename.endsWith('.csv') ? filename : `${filename}.csv`;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n\n  // Clean up the URL object\n  URL.revokeObjectURL(url);\n};\n"],"names":[],"mappings":"AAAA,aAAa;AAEb;;;CAGC;;;;;;;;AACM,MAAM,eAAe,CAAC;IAC3B,IAAI,IAAI,SAAS,OAAO,KAAK,OAAO;IACpC,wFAAwF;IACxF,IAAI,WAAW,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,EAAE,GAAG;IACnC,oDAAoD;IACpD,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,MAAM,MAAM,CAAC,CAAC;AACrC;AAQO,MAAM,QAAQ,CACnB,MACA;IAEA,MAAM,YAAY,WAAW,CAAC,KAAK,MAAM,GAAG,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE;IACzE,MAAM,UAAU;QACd,UAAU,GAAG,CAAC,cAAc,IAAI,CAAC;WAC9B,KAAK,GAAG,CAAC,CAAA,MACV,UAAU,GAAG,CAAC,CAAA,MAAO,aAAa,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC;KAErD;IAED,4CAA4C;IAC5C,OAAO,WAAW,QAAQ,IAAI,CAAC,QAAQ,CAAC,QAAQ,MAAM,GAAG,IAAI,OAAO,EAAE;AACxE;AAOO,MAAM,cAAc,CAAC,UAAkB;IAC5C,MAAM,OAAO,IAAI,KAAK;QAAC;KAAK,EAAE;QAAE,MAAM;IAA0B;IAChE,MAAM,MAAM,IAAI,eAAe,CAAC;IAEhC,+CAA+C;IAC/C,MAAM,OAAO,SAAS,aAAa,CAAC;IACpC,KAAK,IAAI,GAAG;IACZ,KAAK,QAAQ,GAAG,SAAS,QAAQ,CAAC,UAAU,WAAW,GAAG,SAAS,IAAI,CAAC;IACxE,SAAS,IAAI,CAAC,WAAW,CAAC;IAC1B,KAAK,KAAK;IACV,SAAS,IAAI,CAAC,WAAW,CAAC;IAE1B,0BAA0B;IAC1B,IAAI,eAAe,CAAC;AACtB","debugId":null}},
    {"offset": {"line": 2618, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/applications/_components/FailedUpdateAlert.tsx"],"sourcesContent":["\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { Download } from \"lucide-react\";\nimport { downloadCsv } from \"@/lib/csv\";\n\ninterface FailedUpdate {\n  id: number;\n  reason: string;\n}\n\ninterface FailedUpdateAlertProps {\n  failedUpdates: FailedUpdate[];\n}\n\nexport function FailedUpdateAlert({ failedUpdates }: FailedUpdateAlertProps) {\n  const downloadFailedUpdatesCSV = () => {\n    if (failedUpdates.length === 0) return;\n\n    const csvContent = [\n      \"Application ID,Failure Reason\",\n      ...failedUpdates.map(\n        (failure) =>\n          `${failure.id},\"${failure.reason.replace(/\"/g, '\"\"')}\"`,\n      ),\n    ].join(\"\\n\");\n\n    const filename = `failed-application-updates-${new Date().toISOString().split(\"T\")[0]}`;\n    downloadCsv(filename, csvContent);\n  };\n\n  if (failedUpdates.length === 0) return null;\n\n  return (\n    <div className=\"flex items-center justify-between bg-destructive/10 border border-destructive/20 rounded p-3\">\n      <div className=\"flex items-center gap-2\">\n        <span className=\"text-sm text-destructive font-medium\">\n          {failedUpdates.length} update{failedUpdates.length !== 1 ? 's' : ''} failed\n        </span>\n      </div>\n      <Button\n        variant=\"outline\"\n        size=\"sm\"\n        onClick={downloadFailedUpdatesCSV}\n        className=\"flex items-center gap-2\"\n      >\n        <Download className=\"h-3 w-3\" />\n        Download CSV\n      </Button>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAJA;;;;;AAeO,SAAS,kBAAkB,EAAE,aAAa,EAA0B;IACzE,MAAM,2BAA2B;QAC/B,IAAI,cAAc,MAAM,KAAK,GAAG;QAEhC,MAAM,aAAa;YACjB;eACG,cAAc,GAAG,CAClB,CAAC,UACC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE,QAAQ,MAAM,CAAC,OAAO,CAAC,MAAM,MAAM,CAAC,CAAC;SAE5D,CAAC,IAAI,CAAC;QAEP,MAAM,WAAW,CAAC,2BAA2B,EAAE,IAAI,OAAO,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE;QACvF,IAAA,yHAAW,EAAC,UAAU;IACxB;IAEA,IAAI,cAAc,MAAM,KAAK,GAAG,OAAO;IAEvC,qBACE,8OAAC;QAAI,WAAU;;0BACb,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC;oBAAK,WAAU;;wBACb,cAAc,MAAM;wBAAC;wBAAQ,cAAc,MAAM,KAAK,IAAI,MAAM;wBAAG;;;;;;;;;;;;0BAGxE,8OAAC,qIAAM;gBACL,SAAQ;gBACR,MAAK;gBACL,SAAS;gBACT,WAAU;;kCAEV,8OAAC,sNAAQ;wBAAC,WAAU;;;;;;oBAAY;;;;;;;;;;;;;AAKxC","debugId":null}},
    {"offset": {"line": 2696, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/applications/_components/BulkActionsBar.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Label } from \"@/components/ui/label\";\nimport { CheckSquare } from \"lucide-react\";\nimport { AssignToStaffDialog } from \"./AssignToStaffDialog\";\nimport { UpdateStatusDropdown } from \"./UpdateStatusDropdown\";\nimport { FailedUpdateAlert } from \"./FailedUpdateAlert\";\nimport type { ActionResult } from \"@/lib/types\";\n\ninterface BulkActionsBarProps {\n  selectedApplicationIds: number[];\n}\n\nexport default function BulkActionsBar({ selectedApplicationIds }: BulkActionsBarProps) {\n  const [bulkNotes, setBulkNotes] = useState(\"\");\n  const [failedUpdates, setFailedUpdates] = useState<Array<{ id: number; reason: string }>>([]);\n  const [isAssignPending, setIsAssignPending] = useState(false);\n  const [isStatusUpdatePending, setIsStatusUpdatePending] = useState(false);\n\n  useEffect(() => {\n    setFailedUpdates([]);\n  }, [selectedApplicationIds]);\n\n  const handleBulkResult = (result: ActionResult<{ failed?: { id: number; reason: string }[] }>) => {\n    if (result.success) {\n      setBulkNotes(\"\");\n    }\n    setFailedUpdates(result.data?.failed || []);\n  };\n\n  const isOperationInProgress = isAssignPending || isStatusUpdatePending;\n\n  return (\n    <div className=\"bg-muted/50 border rounded-lg p-4 space-y-4\" aria-label=\"Bulk actions for selected applications\">\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center gap-2\">\n          <CheckSquare className=\"h-4 w-4\" />\n          <span className=\"font-medium\">\n            {selectedApplicationIds.length} application{selectedApplicationIds.length !== 1 ? 's' : ''} selected\n          </span>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <Label htmlFor=\"bulk-notes\" className=\"text-sm\">Notes (optional)</Label>\n          <Textarea\n            id=\"bulk-notes\"\n            placeholder=\"Add notes for this bulk action...\"\n            value={bulkNotes}\n            onChange={(e) => setBulkNotes(e.target.value)}\n            className=\"w-64 h-8 resize-none\"\n            rows={1}\n            disabled={isOperationInProgress}\n          />\n        </div>\n      </div>\n\n      <div className=\"flex items-center gap-2\">\n        <AssignToStaffDialog\n          selectedApplicationIds={selectedApplicationIds}\n          onPendingChange={setIsAssignPending}\n        />\n\n        <UpdateStatusDropdown\n          selectedApplicationIds={selectedApplicationIds}\n          bulkNotes={bulkNotes}\n          onResult={handleBulkResult}\n          onPendingChange={setIsStatusUpdatePending}\n        />\n      </div>\n\n      <FailedUpdateAlert failedUpdates={failedUpdates} />\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;;;;;;;;;AAee,SAAS,eAAe,EAAE,sBAAsB,EAAuB;IACpF,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,iNAAQ,EAAC;IAC3C,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,iNAAQ,EAAwC,EAAE;IAC5F,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,IAAA,iNAAQ,EAAC;IACvD,MAAM,CAAC,uBAAuB,yBAAyB,GAAG,IAAA,iNAAQ,EAAC;IAEnE,IAAA,kNAAS,EAAC;QACR,iBAAiB,EAAE;IACrB,GAAG;QAAC;KAAuB;IAE3B,MAAM,mBAAmB,CAAC;QACxB,IAAI,OAAO,OAAO,EAAE;YAClB,aAAa;QACf;QACA,iBAAiB,OAAO,IAAI,EAAE,UAAU,EAAE;IAC5C;IAEA,MAAM,wBAAwB,mBAAmB;IAEjD,qBACE,8OAAC;QAAI,WAAU;QAA8C,cAAW;;0BACtE,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBAAI,WAAU;;0CACb,8OAAC,0OAAW;gCAAC,WAAU;;;;;;0CACvB,8OAAC;gCAAK,WAAU;;oCACb,uBAAuB,MAAM;oCAAC;oCAAa,uBAAuB,MAAM,KAAK,IAAI,MAAM;oCAAG;;;;;;;;;;;;;kCAG/F,8OAAC;wBAAI,WAAU;;0CACb,8OAAC,mIAAK;gCAAC,SAAQ;gCAAa,WAAU;0CAAU;;;;;;0CAChD,8OAAC,yIAAQ;gCACP,IAAG;gCACH,aAAY;gCACZ,OAAO;gCACP,UAAU,CAAC,IAAM,aAAa,EAAE,MAAM,CAAC,KAAK;gCAC5C,WAAU;gCACV,MAAM;gCACN,UAAU;;;;;;;;;;;;;;;;;;0BAKhB,8OAAC;gBAAI,WAAU;;kCACb,8OAAC,0LAAmB;wBAClB,wBAAwB;wBACxB,iBAAiB;;;;;;kCAGnB,8OAAC,4LAAoB;wBACnB,wBAAwB;wBACxB,WAAW;wBACX,UAAU;wBACV,iBAAiB;;;;;;;;;;;;0BAIrB,8OAAC,sLAAiB;gBAAC,eAAe;;;;;;;;;;;;AAGxC","debugId":null}},
    {"offset": {"line": 2852, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/applications/ApplicationsTableClient.tsx"],"sourcesContent":["\"use client\";\n\nimport AdoptPagination from \"@/app/adopt/_components/AdoptPagination\";\nimport { useApplicationsFilters } from \"@/lib/hooks/useApplicationsFilters\";\nimport { useApplicationsSelection } from \"@/lib/hooks/useApplicationsSelection\";\nimport ApplicationsFilters from \"./_components/ApplicationsFilters\";\nimport { ApplicationsTable } from \"./_components/ApplicationsTable\";\nimport BulkActionsBar from \"./_components/BulkActionsBar\";\nimport { ApplicationListItem } from \"@/lib/view-models/applications\";\n\ninterface ApplicationsTableClientProps {\n  initialApplications: ApplicationListItem[];\n  pagination: {\n    currentPage: number;\n    totalPages: number;\n    totalCount: number;\n    hasNextPage: boolean;\n    hasPreviousPage: boolean;\n  };\n}\n\nexport default function ApplicationsTableClient({\n  initialApplications,\n  pagination,\n}: ApplicationsTableClientProps) {\n  const { filters, updateSearchParams } = useApplicationsFilters();\n  const {\n    selectedApplicationIds,\n    handleSelectAll,\n    handleSelectApplication,\n    isAllSelected,\n    isIndeterminate,\n  } = useApplicationsSelection();\n\n  // Applications are now pre-filtered from server\n  const filteredApplications = initialApplications;\n\n  // Calculate selection state based on data and hook state\n  const allSelected = isAllSelected(filteredApplications.length);\n  const indeterminate = isIndeterminate(filteredApplications.length);\n\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Filters */}\n      <ApplicationsFilters filters={filters} onFilterChange={updateSearchParams} />\n\n      {/* Bulk Actions Bar */}\n      {selectedApplicationIds.length > 0 && (\n        <BulkActionsBar selectedApplicationIds={selectedApplicationIds} />\n      )}\n\n\n      {/* Results count */}\n      <div className=\"text-sm text-muted-foreground\">\n        Showing {filteredApplications.length} of {pagination.totalCount} applications (Page {pagination.currentPage} of {pagination.totalPages})\n      </div>\n\n      <ApplicationsTable\n        applications={filteredApplications}\n        selectedApplicationIds={selectedApplicationIds}\n        allSelected={allSelected}\n        indeterminate={indeterminate}\n        onSelectAll={(checked) => handleSelectAll(checked, filteredApplications)}\n        onSelectApplication={handleSelectApplication}\n        totalCount={pagination.totalCount}\n      />\n      {filteredApplications.length === 0 && (\n        <p className=\"text-center text-muted-foreground mt-8\">\n          {pagination.totalCount === 0\n            ? \"No applications submitted yet.\"\n            : \"No applications match your current filters.\"}\n        </p>\n      )}\n\n      <AdoptPagination\n        currentPage={pagination.currentPage}\n        totalPages={pagination.totalPages}\n        hasNextPage={pagination.hasNextPage}\n        hasPrevPage={pagination.hasPreviousPage}\n      />\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAPA;;;;;;;;AAqBe,SAAS,wBAAwB,EAC9C,mBAAmB,EACnB,UAAU,EACmB;IAC7B,MAAM,EAAE,OAAO,EAAE,kBAAkB,EAAE,GAAG,IAAA,gKAAsB;IAC9D,MAAM,EACJ,sBAAsB,EACtB,eAAe,EACf,uBAAuB,EACvB,aAAa,EACb,eAAe,EAChB,GAAG,IAAA,oKAAwB;IAE5B,gDAAgD;IAChD,MAAM,uBAAuB;IAE7B,yDAAyD;IACzD,MAAM,cAAc,cAAc,qBAAqB,MAAM;IAC7D,MAAM,gBAAgB,gBAAgB,qBAAqB,MAAM;IAGjE,qBACE,8OAAC;QAAI,WAAU;;0BAEb,8OAAC,8KAAmB;gBAAC,SAAS;gBAAS,gBAAgB;;;;;;YAGtD,uBAAuB,MAAM,GAAG,mBAC/B,8OAAC,yKAAc;gBAAC,wBAAwB;;;;;;0BAK1C,8OAAC;gBAAI,WAAU;;oBAAgC;oBACpC,qBAAqB,MAAM;oBAAC;oBAAK,WAAW,UAAU;oBAAC;oBAAqB,WAAW,WAAW;oBAAC;oBAAK,WAAW,UAAU;oBAAC;;;;;;;0BAGzI,8OAAC,sLAAiB;gBAChB,cAAc;gBACd,wBAAwB;gBACxB,aAAa;gBACb,eAAe;gBACf,aAAa,CAAC,UAAY,gBAAgB,SAAS;gBACnD,qBAAqB;gBACrB,YAAY,WAAW,UAAU;;;;;;YAElC,qBAAqB,MAAM,KAAK,mBAC/B,8OAAC;gBAAE,WAAU;0BACV,WAAW,UAAU,KAAK,IACvB,mCACA;;;;;;0BAIR,8OAAC,0JAAe;gBACd,aAAa,WAAW,WAAW;gBACnC,YAAY,WAAW,UAAU;gBACjC,aAAa,WAAW,WAAW;gBACnC,aAAa,WAAW,eAAe;;;;;;;;;;;;AAI/C","debugId":null}},
    {"offset": {"line": 2957, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/application.actions.ts"],"sourcesContent":["// lib/actions/application.actions.ts\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { notFound, redirect } from \"next/navigation\";\nimport { prisma } from \"@/lib/db\";\nimport { AppStatus, AppType, Prisma, AuditAction } from \"@prisma/client\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { applicationSchema, profileSchema } from \"@/lib/zod/applicationSchema\"; // Zod schema\nimport { applicationSchema as newApplicationSchema } from \"@/lib/schemas/application.schema\"; // New Zod schema\nimport { z } from \"zod\";\nimport { assertRole } from \"@/lib/actions/profile.actions\";\nimport { UserRole } from \"@prisma/client\";\nimport { ActionResult, ok, fail } from \"@/lib/types\";\nimport { getAllowedStatuses } from \"@/lib/utils\";\nimport { withAudit } from \"@/lib/audit/withAudit\";\nimport { getCurrentUserId } from \"./audit.actions\";\nimport { getSSRUser } from \"@/lib/auth/session.server\";\nimport { missing } from \"@/lib/format\";\nimport { toCsv } from \"@/lib/csv\";\nimport {\n  AdminApplicationDetail,\n  ApplicationListItem,\n  ApplicationHistoryEntry,\n} from \"@/lib/view-models/applications\";\nimport { parseApplicationSearchParams } from \"@/lib/url-pagination\";\n\nconst updateStatusSchema = z.object({\n  appId: z.coerce.number().int().positive({ message: \"Invalid application ID\" }),\n  status: z.nativeEnum(AppStatus, { message: \"Invalid status\" }),\n  statusNotes: z.string().optional(),\n});\n\nfunction parseApplicationIds(formData: FormData): number[] {\n  const raw = formData.get(\"applicationIds\");\n  if (!raw || typeof raw !== \"string\") return [];\n  return raw\n    .split(\",\")\n    .map(s => s.trim())\n    .filter(Boolean)\n    .map(Number)\n    .filter(Number.isFinite);\n}\n\n\nexport async function createApplication(\n  prevState: ActionResult<null>,\n  formData: FormData\n): Promise<ActionResult<null>> {\n\n  const user = await getSSRUser();\n  if (!user) {\n    // This should never happen if middleware is correct, but it's a good guard.\n    return fail(\"Authentication error. Please log in again.\");\n  }\n\n  // Fetch profile data for snapshot\n  const profile = await prisma.profile.findUnique({\n    where: { id: user.id }\n  });\n  if (!profile) {\n    return fail(\"Profile not found. Please contact support.\");\n  }\n\n  const rawData = Object.fromEntries(formData.entries());\n\n  // Coerce form data for validation\n  const coercedData = {\n    ...rawData,\n    formType: rawData.formType,\n    dogId: rawData.dogId ? Number(rawData.dogId) : undefined,\n    yardFenced: rawData.yardFenced ? rawData.yardFenced === 'on' : undefined,\n    // ... add any other coercions (e.g., references)\n  };\n\n  const result = newApplicationSchema.safeParse(coercedData);\n  if (!result.success) {\n    console.warn(\"Application validation failed:\", result.error.flatten().fieldErrors);\n    return fail(\"Validation failed. Please check your entries.\", result.error.flatten().fieldErrors);\n  }\n\n  const { data } = result;\n\n  try {\n    // Use a transaction. It's the only safe way.\n    await prisma.$transaction(async (tx) => {\n\n      await tx.application.create({\n        data: {\n          applicationType: data.formType,\n          status: 'SUBMITTED',\n          reason: data.reason,\n          dogId: data.dogId,\n          profileId: user.id, // <-- Correct\n          submittedAt: new Date(),\n\n          // --- SNAPSHOT COPY FROM PROFILE ---\n          applicantName: profile.name || 'Unknown',\n          applicantEmail: profile.email,\n          // --- FORM DATA (snapshot of what user provided at submission time) ---\n          applicantPhone: data.applicantPhone,\n          address: data.address,\n          housingType: data.housingType,\n          hasYard: data.hasYard,\n          yardFenced: data.yardFenced,\n          otherPets: data.otherPets,\n          vetName: data.vetName,\n          vetPhone: data.vetPhone,\n          homeEnvironmentDescription: data.homeEnvironmentDescription,\n        }\n      });\n\n      // Create references if provided\n      if (data.references && data.references.length > 0) {\n        // Get the application ID we just created - this is tricky in a transaction\n        // We need to create the application first to get the ID\n        // Let me restructure this...\n\n        // Actually, let me get the application ID after creation\n        // For now, let's create references after the transaction\n      }\n    });\n\n    // Handle references outside transaction for simplicity\n    if (data.references && data.references.length > 0) {\n      // Get the application we just created\n      const createdApplication = await prisma.application.findFirst({\n        where: {\n          profileId: user.id,\n          applicationType: data.formType,\n          status: 'SUBMITTED',\n        },\n        orderBy: { createdAt: 'desc' },\n        select: { id: true },\n      });\n\n      if (createdApplication) {\n        await prisma.reference.createMany({\n          data: data.references.map((ref) => ({\n            ...ref,\n            applicationId: createdApplication.id,\n          })),\n        });\n      }\n    }\n  } catch (error) {\n    console.error(\"Application submission error:\", error);\n    return fail(\"A database error occurred. Please try again.\");\n  }\n\n  // Revalidate admin path and redirect user\n  revalidatePath(\"/admin/applications\");\n  const successPath = data.formType === 'ADOPTER' ? '/apply/adopt/success' : '/apply/foster/success';\n  redirect(successPath);\n}\n\nexport async function submitApplication(formData: FormData): Promise<ActionResult<{ applicationId: number }>> {\n  console.log('submitApplication called with formData keys:', Array.from(formData.keys()));\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) {\n    console.log('submitApplication: user not authenticated');\n    return fail(\"Not authenticated\");\n  }\n  console.log('submitApplication: user authenticated, proceeding with submission');\n\n  try {\n    // Parse form data\n    const formType = formData.get('formType') as AppType;\n    const dogId = formData.get('dogId') ? parseInt(formData.get('dogId') as string) : undefined;\n\n    // Optional: applications can target a specific dog or be general interest applications\n    let validatedDogId: number | undefined;\n    if (dogId !== undefined && dogId !== null) {\n      if (isNaN(dogId) || dogId <= 0) {\n        return fail(\"Invalid dog ID provided.\", { dogId: [\"Must be a valid positive number\"] });\n      }\n      validatedDogId = dogId;\n    }\n\n    // Handle references - parse nested array format from form data\n    const parsedReferences: Array<{ name: string; phone: string; relationship: string }> = [];\n    let index = 0;\n    while (true) {\n      const name = formData.get(`references[${index}][name]`) as string;\n      const phone = formData.get(`references[${index}][phone]`) as string;\n      const relationship = formData.get(`references[${index}][relationship]`) as string;\n\n      if (!name) break; // No more references\n\n      parsedReferences.push({\n        name,\n        phone: phone || '',\n        relationship: relationship || '',\n      });\n      index++;\n    }\n\n    // Extract form fields - separate profile and application data\n    const profileData = {\n      firstName: formData.get('firstName') as string,\n      lastName: formData.get('lastName') as string,\n      email: formData.get('email') as string,\n    };\n\n    const applicantData = {\n      applicantPhone: formData.get('applicantPhone') as string || undefined,\n      address: formData.get('address') as string,\n      housingType: (formData.get('housingType') as 'OWN_HOME' | 'RENT_HOME' | 'OWN_APT_CONDO' | 'RENT_APT_CONDO' | 'OTHER') ?? 'OTHER',\n      hasYard: (formData.get('hasYard') as 'YES' | 'NO' | 'SHARED') ?? 'NO',\n      yardFenced: formData.get('yardFenced') === 'on',\n      otherPets: formData.get('otherPets') as string || undefined,\n      vetName: formData.get('vetName') as string || undefined,\n      vetPhone: formData.get('vetPhone') as string || undefined,\n      homeEnvironmentDescription: formData.get('homeEnvironmentDescription') as string,\n    };\n\n    const applicationData = {\n      reason: formData.get('reason') as string,\n      dogId: validatedDogId,\n      references: parsedReferences,\n      ...applicantData, // Include applicant fields in application data\n    };\n\n    // Validate profile data (only name and email)\n    const validatedProfileData = profileSchema.safeParse(profileData);\n    if (!validatedProfileData.success) {\n      const fieldErrors = validatedProfileData.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // Validate application data (includes applicant fields)\n    const validatedApplicationData = applicationSchema.safeParse(applicationData);\n    if (!validatedApplicationData.success) {\n      const fieldErrors = validatedApplicationData.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // 1. Separate references from the application data.\n    const { references: validatedReferences, ...applicationFields } = validatedApplicationData.data;\n\n    // 2. Use a transaction to ensure data integrity.\n    let app: { id: number } | undefined;\n    await prisma.$transaction(async (tx) => {\n      // 3. Upsert the user's profile with name and email\n      await tx.profile.upsert({\n        where: { id: user.id },\n        update: {\n          name: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n          email: validatedProfileData.data.email,\n        },\n        create: {\n          id: user.id,\n          name: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n          email: validatedProfileData.data.email,\n          role: UserRole.VOLUNTEER, // Default role for new profiles\n        },\n      });\n\n      // 4. Create the application with application-specific data only\n      const applicationData: Prisma.ApplicationCreateInput = {\n        applicationType: formType,\n        profileId: user.id,\n        status: AppStatus.SUBMITTED,\n        submittedAt: new Date(),\n        reason: applicationFields.reason,\n        applicantName: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n        applicantEmail: validatedProfileData.data.email,\n      };\n\n      // Add optional fields if they exist\n      if (applicationFields.dogId !== undefined) applicationData.dog = { connect: { id: applicationFields.dogId } };\n      if (applicationFields.applicantPhone !== undefined) applicationData.applicantPhone = applicationFields.applicantPhone;\n      if (applicationFields.address !== undefined) applicationData.address = applicationFields.address;\n      if (applicationFields.housingType !== undefined) applicationData.housingType = applicationFields.housingType;\n      if (applicationFields.hasYard !== undefined) applicationData.hasYard = applicationFields.hasYard;\n      if (applicationFields.yardFenced !== undefined) applicationData.yardFenced = applicationFields.yardFenced;\n      if (applicationFields.otherPets !== undefined) applicationData.otherPets = applicationFields.otherPets;\n      if (applicationFields.vetName !== undefined) applicationData.vetName = applicationFields.vetName;\n      if (applicationFields.vetPhone !== undefined) applicationData.vetPhone = applicationFields.vetPhone;\n      if (applicationFields.homeEnvironmentDescription !== undefined) applicationData.homeEnvironmentDescription = applicationFields.homeEnvironmentDescription;\n\n      app = await tx.application.create({\n        data: applicationData,\n      });\n\n      // 5. If references exist, create them and link them.\n      if (validatedReferences && validatedReferences.length > 0) {\n        await tx.reference.createMany({\n          data: validatedReferences.map((ref) => ({\n            ...ref,\n            applicationId: app!.id, // Link to the new application\n          })),\n        });\n      }\n    });\n\n    // 6. Revalidate paths\n    revalidatePath(\"/admin/applications\");\n\n    if (!app) {\n      throw new Error(\"Failed to create application\");\n    }\n\n    console.log('submitApplication: application created successfully with ID:', app.id);\n    return ok({ applicationId: app.id }, 'Application submitted successfully!');\n  } catch (error) {\n    console.error(\"Application submission failed:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to submit application.\");\n  }\n}\n\nexport async function updateApplicationStatus(prevState: ActionResult, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n    const userId = await getCurrentUserId();\n\n    const parsed = updateStatusSchema.safeParse(Object.fromEntries(formData.entries()));\n    if (!parsed.success) {\n      const fieldErrors = parsed.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    const { appId, status, statusNotes } = parsed.data;\n\n    // Get current application to validate status transition\n    const currentApplication = await prisma.application.findUnique({\n      where: { id: appId },\n      select: {\n        status: true,\n        applicationType: true,\n      },\n    });\n\n    if (!currentApplication) {\n      return fail(\"Application not found.\");\n    }\n\n    // Validate that the status transition is allowed (server-side enforcement)\n    const allowedStatuses = getAllowedStatuses(currentApplication.applicationType, currentApplication.status);\n    if (!allowedStatuses.includes(status)) {\n      return fail(\"Invalid status transition for this application type.\");\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED\n    if ((status === AppStatus.APPROVED || status === AppStatus.REJECTED) &&\n        (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required when moving to approved or rejected status.\", { statusNotes: [\"Required for terminal status changes\"] });\n    }\n\n    await withAudit(\n      async (tx) => {\n        const application = await tx.application.update({\n          where: { id: appId },\n          data: {\n            status,\n            statusNotes: statusNotes || null,\n          },\n          select: {\n            applicationType: true,\n            profileId: true,\n          },\n        });\n\n        // Write to append-only ApplicationAudit table\n        await tx.applicationAudit.create({\n          data: {\n            applicationId: appId,\n            actorId: userId,\n            oldStatus: currentApplication.status,\n            newStatus: status,\n            note: statusNotes || `Status changed from ${currentApplication.status} to ${status}`,\n          },\n        });\n\n        if (application.applicationType === AppType.FOSTER && status === AppStatus.APPROVED) {\n          await tx.fosterProfile.upsert({\n            where: { profileId: application.profileId },\n            update: {},\n            create: {\n              profileId: application.profileId,\n            },\n          });\n        }\n\n        return application;\n      },\n      {\n        actorId: userId,\n        action: AuditAction.APPLICATION_STATUS_CHANGE,\n        entityType: 'application',\n        entityId: appId,\n        note: `Status changed from ${currentApplication.status} to ${status}`,\n      },\n      prisma\n    );\n\n    revalidatePath(`/admin/applications/${appId}`);\n    revalidatePath(\"/admin/applications\");\n\n    return ok(null, \"Application status updated successfully!\");\n  } catch (error) {\n    return fail(error instanceof Error ? error.message : \"Failed to update status\");\n  }\n}\n\nexport async function getApplicationById(id: number): Promise<AdminApplicationDetail> {\n  const parsed = z.object({ id: z.coerce.number().int().positive() }).safeParse({ id });\n  if (!parsed.success) {\n    throw new Error(\"Invalid application ID\");\n  }\n\n  const application = await prisma.application.findUnique({\n    where: { id },\n    select: {\n      id: true,\n      createdAt: true,\n      updatedAt: true,\n      applicationType: true,\n      status: true,\n      statusNotes: true,\n      profileId: true,\n      applicantName: true,\n      applicantEmail: true,\n      applicantPhone: true,\n      address: true,\n      housingType: true,\n      hasYard: true,\n      yardFenced: true,\n      otherPets: true,\n      vetName: true,\n      vetPhone: true,\n      homeEnvironmentDescription: true,\n      reason: true,\n      references: true,\n      dog: {\n        select: {\n          id: true,\n          name: true,\n          status: true,\n          bioPublic: true,\n        },\n      },\n    },\n  });\n  if (!application) notFound();\n\n  // 2. DELETE ALL JSON.parse logic. It's not needed.\n  // const formData = JSON.parse(application.formDataJson);\n  // return { ...application, formData };\n\n  // Decrypt PII fields from profile before returning\n\n  return {\n    ...application,\n    housingTypeLabel: application.housingType || \"Not specified\",\n    hasYardLabel:\n      application.hasYard === \"YES\"\n        ? \"Yes\"\n        : application.hasYard === \"NO\"\n        ? \"No\"\n        : application.hasYard === \"SHARED\"\n        ? \"Shared\"\n        : \"Not specified\",\n    yardFencedLabel:\n      application.yardFenced === true\n        ? \"Yes\"\n        : application.yardFenced === false\n        ? \"No\"\n        : \"Not specified\",\n    otherPetsLabel: application.otherPets || \"Not specified\",\n    homeEnvironmentDescriptionLabel: application.homeEnvironmentDescription || \"Not specified\",\n  };\n}\n\nexport async function getAllApplications(searchParams?: { [key: string]: string | undefined }): Promise<{\n    applications: ApplicationListItem[];\n    pagination: {\n        currentPage: number;\n        totalPages: number;\n        totalCount: number;\n        hasNextPage: boolean;\n        hasPreviousPage: boolean;\n    };\n}> {\n    await assertRole(UserRole.STAFF);\n\n    // Parse and validate search parameters using shared helper\n    const validatedParams = parseApplicationSearchParams(searchParams || {});\n\n    // Validate status filter\n    if (validatedParams.status && validatedParams.status !== \"all\") {\n        if (!Object.values(AppStatus).includes(validatedParams.status as AppStatus)) {\n            throw new Error(`Invalid status filter: ${validatedParams.status}`);\n        }\n    }\n\n    // Validate type filter\n    if (validatedParams.type && validatedParams.type !== \"all\") {\n        if (!Object.values(AppType).includes(validatedParams.type as AppType)) {\n            throw new Error(`Invalid type filter: ${validatedParams.type}`);\n        }\n    }\n\n    const offset = (validatedParams.page - 1) * validatedParams.limit;\n\n    // Build where clause for filtering\n    const where: Prisma.ApplicationWhereInput = {};\n\n    if (validatedParams.status && validatedParams.status !== \"all\") {\n        where.status = validatedParams.status as AppStatus;\n    }\n\n    if (validatedParams.type && validatedParams.type !== \"all\") {\n        where.applicationType = validatedParams.type as AppType;\n    }\n\n    if (validatedParams.search) {\n        where.OR = [\n            {\n                applicantName: {\n                    contains: validatedParams.search,\n                    mode: \"insensitive\"\n                }\n            },\n            {\n                applicantEmail: {\n                    contains: validatedParams.search,\n                    mode: \"insensitive\"\n                }\n            }\n        ];\n    }\n\n    const [applications, totalCount] = await Promise.all([\n        prisma.application.findMany({\n            where,\n            select: {\n                id: true,\n                createdAt: true,\n                updatedAt: true,\n                applicationType: true,\n                status: true,\n                applicantName: true,\n                applicantEmail: true,\n                reason: true,\n                dog: {\n                    select: {\n                        id: true,\n                        name: true,\n                        status: true,\n                    },\n                },\n            },\n            orderBy: { [validatedParams.sortBy]: validatedParams.sortOrder },\n            skip: offset,\n            take: validatedParams.limit,\n        }),\n        prisma.application.count({ where }),\n    ]);\n\n    const totalPages = Math.ceil(totalCount / validatedParams.limit);\n\n    return {\n        applications: applications as ApplicationListItem[],\n        pagination: {\n            currentPage: validatedParams.page,\n            totalPages,\n            totalCount,\n            hasNextPage: validatedParams.page < totalPages,\n            hasPreviousPage: validatedParams.page > 1,\n        },\n    };\n}\n\nexport async function getUserApplications(profileId: string) {\n    const parsed = z.object({ profileId: z.string().uuid() }).safeParse({ profileId });\n    if (!parsed.success) {\n        throw new Error(\"Invalid profile ID\");\n    }\n\n    const applications = await prisma.application.findMany({\n        where: { profileId },\n        include: {\n            references: true,\n        },\n        orderBy: { createdAt: 'desc' }\n    });\n\n    return applications;\n}\n\n// Form action wrapper for updateApplicationStatus\nexport async function updateApplicationStatusForm(formData: FormData) {\n  return updateApplicationStatus(ok(null), formData);\n}\n\nconst bulkUpdateSchema = z.object({\n  appIds: z.array(z.coerce.number().int().positive({ message: \"Invalid application ID\" })),\n  status: z.nativeEnum(AppStatus, { message: \"Invalid status\" }),\n  statusNotes: z.string().optional(),\n});\n\nexport async function bulkUpdateApplicationStatus(\n  appIds: number[],\n  status: AppStatus,\n  statusNotes?: string\n): Promise<ActionResult<{ ok: number[]; failed: { id: number; reason: string }[] }>> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = bulkUpdateSchema.safeParse({ appIds, status, statusNotes });\n    if (!parsed.success) {\n      const fieldErrors = parsed.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED/WITHDRAWN\n    const requiresNotes: AppStatus[] = [AppStatus.APPROVED, AppStatus.REJECTED, AppStatus.WITHDRAWN]\n    if (requiresNotes.includes(status) && (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required when moving to approved, rejected, or withdrawn status.\", { statusNotes: [\"Required for terminal status changes\"] });\n    }\n\n    // Get current user for authentication\n    const supabase = await createClient();\n    const { data: { user: updater } } = await supabase.auth.getUser();\n    if (!updater) {\n      return fail(\"Authentication required.\");\n    }\n\n    // Get updater's role from database\n    const updaterProfile = await prisma.profile.findUnique({\n      where: { id: updater.id },\n      select: { role: true },\n    });\n\n    if (!updaterProfile || (updaterProfile.role !== UserRole.ADMIN && updaterProfile.role !== UserRole.STAFF)) {\n      return fail(\"Insufficient permissions.\");\n    }\n\n    // Get current applications to validate status transitions\n    const currentApplications = await prisma.application.findMany({\n      where: { id: { in: appIds } },\n      select: {\n        id: true,\n        status: true,\n        applicationType: true,\n      },\n    });\n\n    const appMap = new Map(currentApplications.map(app => [app.id, app]));\n    const successfulIds: number[] = [];\n    const failed: { id: number; reason: string }[] = [];\n\n    // Validate each transition and collect failures\n    for (const appId of appIds) {\n      const currentApp = appMap.get(appId);\n      if (!currentApp) {\n        failed.push({ id: appId, reason: \"Application not found\" });\n        continue;\n      }\n\n      // Validate that the status transition is allowed\n      const allowedStatuses = getAllowedStatuses(currentApp.applicationType, currentApp.status);\n      if (!allowedStatuses.includes(status)) {\n        failed.push({\n          id: appId,\n          reason: `Invalid status transition from ${currentApp.status} for ${currentApp.applicationType} application`\n        });\n        continue;\n      }\n\n      successfulIds.push(appId);\n    }\n\n    // Update successful applications and write audit records\n    if (successfulIds.length > 0) {\n      await prisma.$transaction(async (tx) => {\n        // Update applications\n        await tx.application.updateMany({\n          where: { id: { in: successfulIds } },\n          data: {\n            status,\n            statusNotes: statusNotes || null,\n          },\n        });\n\n        // Write to append-only ApplicationAudit table for each updated application\n        await tx.applicationAudit.createMany({\n          data: successfulIds.map(appId => {\n            const currentApp = appMap.get(appId)!;\n            return {\n              applicationId: appId,\n              actorId: updater.id,\n              oldStatus: currentApp.status,\n              newStatus: status,\n              note: statusNotes || `Bulk status change from ${currentApp.status} to ${status}`,\n            };\n          }),\n        });\n      });\n\n      // Revalidate on success\n      revalidatePath(\"/admin/applications\");\n    }\n\n    return ok({ ok: successfulIds, failed }, `Updated ${successfulIds.length} application${successfulIds.length !== 1 ? 's' : ''} successfully${failed.length > 0 ? `, ${failed.length} failed` : ''}.`);\n  } catch (error) {\n    return fail(error instanceof Error ? error.message : \"An unexpected error occurred.\");\n  }\n}\n\nexport async function getApplicationHistory(applicationId: number): Promise<ApplicationHistoryEntry[]> {\n  await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n  const history = await prisma.applicationAudit.findMany({\n    where: { applicationId },\n    select: {\n      id: true,\n      applicationId: true,\n      oldStatus: true,\n      newStatus: true,\n      note: true,\n      createdAt: true,\n      actor: {\n        select: {\n          name: true,\n          email: true,\n        },\n      },\n    },\n    orderBy: { createdAt: \"desc\" },\n  });\n\n  return history as ApplicationHistoryEntry[];\n}\n\n// Server actions for useActionState (form-based)\nexport async function bulkAssignApplications(\n  prevState: ActionResult,\n  formData: FormData\n): Promise<ActionResult> {\n  try {\n    await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n    const applicationIds = formData.getAll(\"applicationIds\").map(id => parseInt(id as string));\n    const staffId = formData.get(\"staffId\") as string;\n\n    if (!staffId || applicationIds.length === 0) {\n      return fail(\"Staff member and applications are required\");\n    }\n\n    // Verify staff user exists\n    const staffUser = await prisma.profile.findUnique({\n      where: { id: staffId },\n      select: { id: true, role: true },\n    });\n\n    if (!staffUser || (staffUser.role !== UserRole.STAFF && staffUser.role !== UserRole.ADMIN)) {\n      return fail(\"Invalid staff member selected\");\n    }\n\n    // Perform bulk update\n    const updateResult = await prisma.application.updateMany({\n      where: {\n        id: { in: applicationIds },\n      },\n      data: {\n        assignedToUserId: staffId,\n        updatedAt: new Date(),\n      },\n    });\n\n    revalidatePath(\"/admin/applications\");\n\n    return ok(null, `Successfully assigned ${updateResult.count} application(s)`);\n\n  } catch (error) {\n    console.error(\"Bulk assign error:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to assign applications\");\n  }\n}\n\nexport async function bulkUpdateApplications(\n  prevState: ActionResult<{ failed?: { id: number; reason: string }[] }>,\n  formData: FormData\n): Promise<ActionResult<{ failed?: { id: number; reason: string }[] }>> {\n  try {\n    await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n    const applicationIds = parseApplicationIds(formData);\n    const status = formData.get(\"status\") as AppStatus;\n    const statusNotes = formData.get(\"statusNotes\") as string;\n\n    if (applicationIds.length === 0) {\n      return fail(\"No applications selected\");\n    }\n\n    if (!status) {\n      return fail(\"Status is required\");\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED/WITHDRAWN\n    const requiresNotes: AppStatus[] = [AppStatus.APPROVED, AppStatus.REJECTED, AppStatus.WITHDRAWN];\n    if (requiresNotes.includes(status) && (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required for terminal status changes\");\n    }\n\n    const result = await bulkUpdateApplicationStatus(\n      applicationIds,\n      status,\n      statusNotes?.trim() || undefined\n    );\n\n    if (result.success) {\n      const successCount = result.data?.ok.length || 0;\n\n      revalidatePath(\"/admin/applications\");\n\n      return ok({ failed: result.data?.failed }, `Successfully updated ${successCount} application(s)`);\n    } else {\n      return fail(result.message || \"Bulk update failed\");\n    }\n\n  } catch (error) {\n    console.error(\"Bulk update error:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to update applications\");\n  }\n}\n\nexport async function exportApplicationsCSV(\n  searchParams: { [key: string]: string | undefined },\n  minimal: boolean\n): Promise<{ success: true; csvData: string; filename: string } | { success: false; message: string }> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const filters = { ...searchParams };\n    delete filters.minimal; // Remove minimal param from filters\n\n    const appData = await getAllApplications(filters);\n    const applications: ApplicationListItem[] = appData.applications;\n\n    // Guard against exporting insane data sets\n    const MAX_EXPORT_ROWS = 10000;\n    if (applications.length > MAX_EXPORT_ROWS) {\n      return {\n        success: false,\n        message: `Export too large: ${applications.length} applications found, maximum allowed is ${MAX_EXPORT_ROWS}. Please apply filters to reduce the dataset size.`\n      };\n    }\n\n    // Generate CSV data\n    let csvData: Record<string, unknown>[];\n    let csvHeaders: string[];\n\n    if (minimal) {\n      // Minimal export: no PII (phone/address)\n      csvData = applications.map(app => ({\n        id: app.id,\n        submitted_date: app.createdAt.toISOString().split('T')[0],\n        name: missing(app.applicantName, 'Unknown'),\n        email: missing(app.applicantEmail, 'Unknown'),\n        type: app.applicationType,\n        status: app.status,\n        dog_name: app.dog?.name || '',\n        reason: app.reason,\n      }));\n      csvHeaders = [\n        'ID', 'Submitted Date', 'Name', 'Email', 'Type', 'Status',\n        'Dog Name', 'Reason'\n      ];\n    } else {\n      // Full export with available fields\n      csvData = applications.map(app => ({\n        id: app.id,\n        submitted_date: app.createdAt.toISOString().split('T')[0],\n        name: missing(app.applicantName, 'Unknown'),\n        email: missing(app.applicantEmail, 'Unknown'),\n        type: app.applicationType,\n        status: app.status,\n        dog_name: app.dog?.name || '',\n        reason: app.reason,\n      }));\n      csvHeaders = [\n        'ID', 'Submitted Date', 'Name', 'Email', 'Type', 'Status',\n        'Dog Name', 'Reason'\n      ];\n    }\n\n    const csvWithBOM = toCsv(csvData, csvHeaders);\n    const filename = `applications-${new Date().toISOString().split('T')[0]}${minimal ? '-minimal' : ''}.csv`;\n\n    return {\n      success: true,\n      csvData: csvWithBOM,\n      filename\n    };\n  } catch (error) {\n    console.error('CSV export error:', error);\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : 'Failed to generate export'\n    };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IA8zBsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 2969, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/applications/ExportCSVButton.tsx"],"sourcesContent":["\"use client\";\n\nimport { useActionState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Download } from \"lucide-react\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport { useToast } from \"@/components/ui/toast\";\nimport { exportApplicationsCSV } from \"@/lib/actions/application.actions\";\nimport { ApplicationSearchParams } from \"@/lib/url-pagination\";\n\ninterface ExportCSVButtonProps {\n  searchParams: ApplicationSearchParams;\n}\n\nexport default function ExportCSVButton({ searchParams }: ExportCSVButtonProps) {\n  const { showToast } = useToast();\n\n  const [, formAction] = useActionState(\n    async (prevState: { message?: string; success?: boolean }, formData: FormData) => {\n      const minimal = formData.get('minimal') === 'true';\n      // Convert ApplicationSearchParams to generic search params object\n      const genericSearchParams: { [key: string]: string | undefined } = {\n        page: searchParams.page.toString(),\n        limit: searchParams.limit.toString(),\n        status: searchParams.status,\n        type: searchParams.type,\n        search: searchParams.search,\n        sortBy: searchParams.sortBy,\n        sortOrder: searchParams.sortOrder,\n      };\n      const result = await exportApplicationsCSV(genericSearchParams, minimal);\n\n      if (result.success) {\n        // Create blob and trigger download\n        const blob = new Blob([result.csvData], { type: 'text/csv' });\n        const url = URL.createObjectURL(blob);\n\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = result.filename;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n\n        URL.revokeObjectURL(url);\n\n        showToast('Export completed successfully', 'success');\n        return { message: 'Export completed successfully', success: true };\n      } else {\n        showToast(result.message, 'error');\n        return { message: result.message, success: false };\n      }\n    },\n    { message: '', success: false }\n  );\n\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button data-testid=\"btn-export-csv\">\n          <Download className=\"mr-2 h-4 w-4\" />\n          Export CSV\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent align=\"end\">\n        <form action={formAction}>\n          <input type=\"hidden\" name=\"minimal\" value=\"false\" />\n          <DropdownMenuItem asChild>\n            <button type=\"submit\" className=\"w-full text-left\">\n              <Download className=\"mr-2 h-4 w-4\" />\n              Full Export (with PII)\n            </button>\n          </DropdownMenuItem>\n        </form>\n        <form action={formAction}>\n          <input type=\"hidden\" name=\"minimal\" value=\"true\" />\n          <DropdownMenuItem asChild>\n            <button type=\"submit\" className=\"w-full text-left\">\n              <Download className=\"mr-2 h-4 w-4\" />\n              Minimal Export (no phone/address)\n            </button>\n          </DropdownMenuItem>\n        </form>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}\n\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AAMA;AACA;AAZA;;;;;;;;AAmBe,SAAS,gBAAgB,EAAE,YAAY,EAAwB;IAC5E,MAAM,EAAE,SAAS,EAAE,GAAG,IAAA,sIAAQ;IAE9B,MAAM,GAAG,WAAW,GAAG,IAAA,uNAAc,EACnC,OAAO,WAAoD;QACzD,MAAM,UAAU,SAAS,GAAG,CAAC,eAAe;QAC5C,kEAAkE;QAClE,MAAM,sBAA6D;YACjE,MAAM,aAAa,IAAI,CAAC,QAAQ;YAChC,OAAO,aAAa,KAAK,CAAC,QAAQ;YAClC,QAAQ,aAAa,MAAM;YAC3B,MAAM,aAAa,IAAI;YACvB,QAAQ,aAAa,MAAM;YAC3B,QAAQ,aAAa,MAAM;YAC3B,WAAW,aAAa,SAAS;QACnC;QACA,MAAM,SAAS,MAAM,IAAA,+KAAqB,EAAC,qBAAqB;QAEhE,IAAI,OAAO,OAAO,EAAE;YAClB,mCAAmC;YACnC,MAAM,OAAO,IAAI,KAAK;gBAAC,OAAO,OAAO;aAAC,EAAE;gBAAE,MAAM;YAAW;YAC3D,MAAM,MAAM,IAAI,eAAe,CAAC;YAEhC,MAAM,OAAO,SAAS,aAAa,CAAC;YACpC,KAAK,IAAI,GAAG;YACZ,KAAK,QAAQ,GAAG,OAAO,QAAQ;YAC/B,SAAS,IAAI,CAAC,WAAW,CAAC;YAC1B,KAAK,KAAK;YACV,SAAS,IAAI,CAAC,WAAW,CAAC;YAE1B,IAAI,eAAe,CAAC;YAEpB,UAAU,iCAAiC;YAC3C,OAAO;gBAAE,SAAS;gBAAiC,SAAS;YAAK;QACnE,OAAO;YACL,UAAU,OAAO,OAAO,EAAE;YAC1B,OAAO;gBAAE,SAAS,OAAO,OAAO;gBAAE,SAAS;YAAM;QACnD;IACF,GACA;QAAE,SAAS;QAAI,SAAS;IAAM;IAGhC,qBACE,8OAAC,qJAAY;;0BACX,8OAAC,4JAAmB;gBAAC,OAAO;0BAC1B,cAAA,8OAAC,qIAAM;oBAAC,eAAY;;sCAClB,8OAAC,sNAAQ;4BAAC,WAAU;;;;;;wBAAiB;;;;;;;;;;;;0BAIzC,8OAAC,4JAAmB;gBAAC,OAAM;;kCACzB,8OAAC;wBAAK,QAAQ;;0CACZ,8OAAC;gCAAM,MAAK;gCAAS,MAAK;gCAAU,OAAM;;;;;;0CAC1C,8OAAC,yJAAgB;gCAAC,OAAO;0CACvB,cAAA,8OAAC;oCAAO,MAAK;oCAAS,WAAU;;sDAC9B,8OAAC,sNAAQ;4CAAC,WAAU;;;;;;wCAAiB;;;;;;;;;;;;;;;;;;kCAK3C,8OAAC;wBAAK,QAAQ;;0CACZ,8OAAC;gCAAM,MAAK;gCAAS,MAAK;gCAAU,OAAM;;;;;;0CAC1C,8OAAC,yJAAgB;gCAAC,OAAO;0CACvB,cAAA,8OAAC;oCAAO,MAAK;oCAAS,WAAU;;sDAC9B,8OAAC,sNAAQ;4CAAC,WAAU;;;;;;wCAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQnD","debugId":null}}]
}