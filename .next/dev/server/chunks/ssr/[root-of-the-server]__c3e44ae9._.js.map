{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/event.actions.ts"],"sourcesContent":["\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { prisma } from \"@/lib/prisma\";\nimport { assertRole } from \"@/lib/actions/profile.actions\";\nimport { UserRole } from \"@prisma/client\";\nimport { ActionResult } from \"@/lib/types\";\nimport { eventFormSchema, shiftIdSchema } from \"@/lib/schemas\";\nimport { z } from \"zod\";\n\nconst deleteEventSchema = z.object({\n  eventId: z.coerce.number().int().positive({ message: \"Invalid event ID\" }),\n});\n\nconst duplicateEventSchema = z.object({\n  eventId: z.coerce.number().int().positive({ message: \"Invalid event ID\" }),\n  fail: z.coerce.string().optional(), // For testing failure injection\n});\n\nconst revalidateEventPaths = () => {\n  revalidatePath(\"/admin/events\");\n  revalidatePath(\"/events\");\n};\n\nexport async function createEvent(prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult<{ id: number }>> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const title = formData.get('title') as string;\n    const startTime = formData.get('startTime') as string;\n    const endTime = formData.get('endTime') as string;\n    const description = formData.get('description') as string;\n\n    if (!title || !startTime || !endTime) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { title: !title ? ['Title is required'] : [], startTime: !startTime ? ['Start time is required'] : [], endTime: !endTime ? ['End time is required'] : [] },\n        data: null,\n      };\n    }\n\n    // validate times server-side\n    const start = new Date(startTime);\n    const end = new Date(endTime);\n    if (!(start instanceof Date) || !(end instanceof Date) || Number.isNaN(+start) || Number.isNaN(+end)) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { startTime: ['Invalid date/time'], endTime: ['Invalid date/time'] },\n        data: null,\n      };\n    }\n    if (end <= start) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { endTime: ['End time must be after start time'] },\n        data: null,\n      };\n    }\n\n    const ev = await prisma.event.create({\n      data: { title, startTime: start, endTime: end, description: description || null }\n    });\n    revalidatePath('/admin/events');\n    revalidatePath('/events'); // public list must reflect immediately\n    return {\n      success: true,\n      message: \"Event created successfully.\",\n      fieldErrors: undefined,\n      data: { id: ev.id },\n    };\n  } catch {\n    return {\n      success: false,\n      message: \"Failed to create event.\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function getEvents() {\n  return prisma.event.findMany({\n    orderBy: {\n      startTime: \"asc\",\n    },\n  });\n}\n\nexport async function updateEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const idParsed = shiftIdSchema.safeParse({\n      shiftId: formData.get(\"id\"),\n    });\n\n    if (!idParsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: idParsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    const parsed = eventFormSchema.safeParse({\n      title: formData.get(\"title\"),\n      description: formData.get(\"description\"),\n      startTime: formData.get(\"startTime\"),\n      endTime: formData.get(\"endTime\"),\n      location: formData.get(\"location\"),\n      capacity: formData.get(\"capacity\"),\n    });\n\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    const data = parsed.data;\n    const startTime = new Date(data.startTime);\n    const endTime = new Date(data.endTime);\n\n    // Server-side validation: startTime must be before endTime\n    if (startTime >= endTime) {\n      return {\n        success: false,\n        message: \"Start time must be before end time.\",\n        fieldErrors: { startTime: [\"Start time must be before end time\"] },\n        data: null,\n      };\n    }\n\n    // Server-side validation: forbid past start times\n    if (startTime <= new Date()) {\n      return {\n        success: false,\n        message: \"Cannot update events to start in the past.\",\n        fieldErrors: { startTime: [\"Start time must be in the future\"] },\n        data: null,\n      };\n    }\n\n    await prisma.event.update({\n      where: { id: idParsed.data.shiftId },\n      data: {\n        title: data.title,\n        description: data.description,\n        startTime,\n        endTime: new Date(data.endTime),\n        location: data.location,\n        capacity: data.capacity,\n      },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event updated successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to update event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function duplicateEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = duplicateEventSchema.safeParse({\n      eventId: formData.get(\"eventId\"),\n      fail: formData.get(\"fail\"),\n    });\n\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    // Check if we should inject a failure for testing\n    if (parsed.data.fail === '1') {\n      return {\n        success: false,\n        message: \"Simulated failure for testing optimistic rollback\",\n        fieldErrors: undefined,\n        data: null,\n      };\n    }\n\n    const originalEvent = await prisma.event.findUnique({\n      where: { id: parsed.data.eventId },\n    });\n\n    if (!originalEvent) {\n      return {\n        success: false,\n        message: \"Event not found.\",\n        fieldErrors: { eventId: [\"Event not found\"] },\n        data: null,\n      };\n    }\n\n    // Create duplicate with \"Copy of\" prefix\n    await prisma.event.create({\n      data: {\n        title: `Copy of ${originalEvent.title}`,\n        description: originalEvent.description,\n        startTime: originalEvent.startTime,\n        endTime: originalEvent.endTime,\n        location: originalEvent.location,\n        capacity: originalEvent.capacity,\n      },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event duplicated successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to duplicate event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function deleteEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = deleteEventSchema.safeParse({\n      eventId: formData.get(\"eventId\"),\n    });\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    await prisma.event.delete({\n      where: { id: parsed.data.eventId },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event deleted successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to delete event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IAwBsB,cAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/testing/RouteReady.tsx"],"sourcesContent":["/**\n * RouteReady - A test sentinel component that marks when a route has finished loading.\n *\n * This component renders a visible element that Playwright can detect as visible,\n * while remaining visually unobtrusive to users. Used for E2E test synchronization.\n */\nexport function RouteReady({ route }: { route: string }) {\n  return (\n    <div\n      data-testid=\"route-ready\"\n      data-route={route}\n      aria-hidden=\"true\"\n      style={{\n        position: 'absolute',\n        width: 1,\n        height: 1,\n        top: 0,\n        left: 0,\n        opacity: 1, // Make visible for test detection\n        pointerEvents: 'none',\n        visibility: 'visible', // Ensure it's visible\n      }}\n    />\n  );\n}\n\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;AACM,SAAS,WAAW,EAAE,KAAK,EAAqB;IACrD,qBACE,8OAAC;QACC,eAAY;QACZ,cAAY;QACZ,eAAY;QACZ,OAAO;YACL,UAAU;YACV,OAAO;YACP,QAAQ;YACR,KAAK;YACL,MAAM;YACN,SAAS;YACT,eAAe;YACf,YAAY;QACd;;;;;;AAGN","debugId":null}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/utils/index.ts"],"sourcesContent":["// lib/utils/index.ts\n// Shared utility functions for the application\n\nimport { AppStatus, AppType } from \"@prisma/client\";\n\n/**\n * Humanize enum values by replacing underscores with spaces and capitalizing words\n */\nexport const humanizeEnum = (value: string): string => {\n  return value\n    .toLowerCase()\n    .replace(/_/g, ' ')\n    .replace(/\\b\\w/g, l => l.toUpperCase());\n};\n\n/**\n * Status variant functions for consistent badge styling\n */\nexport const getAppStatusVariant = (status: AppStatus) => {\n  switch (status) {\n    case \"APPROVED\": return \"default\";\n    case \"SUBMITTED\": case \"IN_REVIEW\": return \"secondary\";\n    case \"REJECTED\": return \"destructive\";\n    default: return \"outline\";\n  }\n};\n\n/**\n * Get allowed status transitions for applications\n */\nexport const getAllowedStatuses = (applicationType: AppType, currentStatus?: AppStatus): AppStatus[] => {\n  const allStatuses = Object.values(AppStatus);\n\n  // For foster applications, restrict some status transitions\n  if (applicationType === AppType.FOSTER) {\n    // Fosters can be approved (creates foster profile) or rejected\n    // Can't be marked as \"IN_REVIEW\" inappropriately\n    return allStatuses.filter(status =>\n      status !== AppStatus.IN_REVIEW || currentStatus === AppStatus.IN_REVIEW\n    );\n  }\n\n  // For adoption applications, all statuses are allowed\n  return allStatuses;\n};\n\n/**\n * Check if status change notes are required for a given status\n */\nexport const areStatusNotesRequired = (status: AppStatus): boolean => {\n  return status === AppStatus.APPROVED || status === AppStatus.REJECTED;\n};\n"],"names":[],"mappings":"AAAA,qBAAqB;AACrB,+CAA+C;;;;;;;;;;;AAE/C;;AAKO,MAAM,eAAe,CAAC;IAC3B,OAAO,MACJ,WAAW,GACX,OAAO,CAAC,MAAM,KACd,OAAO,CAAC,SAAS,CAAA,IAAK,EAAE,WAAW;AACxC;AAKO,MAAM,sBAAsB,CAAC;IAClC,OAAQ;QACN,KAAK;YAAY,OAAO;QACxB,KAAK;QAAa,KAAK;YAAa,OAAO;QAC3C,KAAK;YAAY,OAAO;QACxB;YAAS,OAAO;IAClB;AACF;AAKO,MAAM,qBAAqB,CAAC,iBAA0B;IAC3D,MAAM,cAAc,OAAO,MAAM,CAAC,0IAAS;IAE3C,4DAA4D;IAC5D,IAAI,oBAAoB,wIAAO,CAAC,MAAM,EAAE;QACtC,+DAA+D;QAC/D,iDAAiD;QACjD,OAAO,YAAY,MAAM,CAAC,CAAA,SACxB,WAAW,0IAAS,CAAC,SAAS,IAAI,kBAAkB,0IAAS,CAAC,SAAS;IAE3E;IAEA,sDAAsD;IACtD,OAAO;AACT;AAKO,MAAM,yBAAyB,CAAC;IACrC,OAAO,WAAW,0IAAS,CAAC,QAAQ,IAAI,WAAW,0IAAS,CAAC,QAAQ;AACvE","debugId":null}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { AppStatus, AppType, DogStatus } from \"@prisma/client\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\n\n// This check can be removed, it is just for tutorial purposes\nexport const hasEnvVars =\n  !!(process.env.NEXT_PUBLIC_SUPABASE_URL &&\n     process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);\n\n\nexport const getDogStatusVariant = (status: DogStatus) => {\n  switch (status) {\n    case \"ADOPTED\": return \"default\";\n    case \"AVAILABLE\": return \"secondary\";\n    case \"MEDICAL_HOLD\": return \"destructive\";\n    case \"PENDING\": case \"IN_FOSTER\": return \"outline\";\n    default: return \"secondary\";\n  }\n};\n\n// Date formatting utilities\nexport const formatDateTime = (date: Date) =>\n  new Intl.DateTimeFormat(\"en-US\", {\n    month: \"short\",\n    day: \"numeric\",\n    year: \"numeric\",\n    hour: \"numeric\",\n    minute: \"2-digit\",\n  }).format(date);\n\nexport const formatDateRange = (start: Date, end: Date) => {\n  const sameDay =\n    start.getFullYear() === end.getFullYear() &&\n    start.getMonth() === end.getMonth() &&\n    start.getDate() === end.getDate();\n\n  if (sameDay) {\n    return `${formatDateTime(start)} – ${new Intl.DateTimeFormat(\"en-US\", {\n      hour: \"numeric\",\n      minute: \"2-digit\",\n    }).format(end)}`;\n  }\n\n  return `${formatDateTime(start)} → ${formatDateTime(end)}`;\n};\n\nexport const formatShiftTime = (start: Date, end: Date): string => {\n  const startDate = start.toLocaleDateString();\n  const startTime = start.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });\n  const endTime = end.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });\n\n  if (startDate === end.toLocaleDateString()) {\n    return `${startDate}, ${startTime} - ${endTime}`;\n  }\n  return `${startDate}, ${startTime} - ${end.toLocaleDateString()}, ${endTime}`;\n};\n\nexport const formatAdoptionDate = (date: Date) =>\n  new Intl.DateTimeFormat(\"en-US\", {\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\",\n  }).format(date);\n\n// Re-export shared utilities\nexport { humanizeEnum, getAppStatusVariant, getAllowedStatuses, areStatusNotesRequired } from './utils/index';\n\n// Test endpoint validation - allow in test environment or with test secret header\nexport function validateTestEndpoint(request: Request): { isValid: boolean; response?: Response } {\n  const isTestEnv = process.env.NODE_ENV === 'test' && process.env.EXPOSE_TEST_API === '1';\n\n  const testSecret = request.headers.get('x-test-secret');\n  const expectedSecret = process.env.TEST_SECRET || 'test-secret-default';\n  const hasValidTestSecret = testSecret === expectedSecret;\n\n  if (!isTestEnv || !hasValidTestSecret) {\n    return {\n      isValid: false,\n      response: new Response(null, { status: 404 })\n    };\n  }\n\n  return { isValid: true };\n}\n\n// Route definitions have been moved to lib/routes.ts\n// Import route functions from @/lib/routes instead\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AAqEA,6BAA6B;AAC7B;;;AAlEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,sKAAO,EAAC,IAAA,6IAAI,EAAC;AACtB;AAIO,MAAM,aACX,CAAC,CAAC,CAAC,kKACyC;AAGvC,MAAM,sBAAsB,CAAC;IAClC,OAAQ;QACN,KAAK;YAAW,OAAO;QACvB,KAAK;YAAa,OAAO;QACzB,KAAK;YAAgB,OAAO;QAC5B,KAAK;QAAW,KAAK;YAAa,OAAO;QACzC;YAAS,OAAO;IAClB;AACF;AAGO,MAAM,iBAAiB,CAAC,OAC7B,IAAI,KAAK,cAAc,CAAC,SAAS;QAC/B,OAAO;QACP,KAAK;QACL,MAAM;QACN,MAAM;QACN,QAAQ;IACV,GAAG,MAAM,CAAC;AAEL,MAAM,kBAAkB,CAAC,OAAa;IAC3C,MAAM,UACJ,MAAM,WAAW,OAAO,IAAI,WAAW,MACvC,MAAM,QAAQ,OAAO,IAAI,QAAQ,MACjC,MAAM,OAAO,OAAO,IAAI,OAAO;IAEjC,IAAI,SAAS;QACX,OAAO,GAAG,eAAe,OAAO,GAAG,EAAE,IAAI,KAAK,cAAc,CAAC,SAAS;YACpE,MAAM;YACN,QAAQ;QACV,GAAG,MAAM,CAAC,MAAM;IAClB;IAEA,OAAO,GAAG,eAAe,OAAO,GAAG,EAAE,eAAe,MAAM;AAC5D;AAEO,MAAM,kBAAkB,CAAC,OAAa;IAC3C,MAAM,YAAY,MAAM,kBAAkB;IAC1C,MAAM,YAAY,MAAM,kBAAkB,CAAC,EAAE,EAAE;QAAE,MAAM;QAAW,QAAQ;IAAU;IACpF,MAAM,UAAU,IAAI,kBAAkB,CAAC,EAAE,EAAE;QAAE,MAAM;QAAW,QAAQ;IAAU;IAEhF,IAAI,cAAc,IAAI,kBAAkB,IAAI;QAC1C,OAAO,GAAG,UAAU,EAAE,EAAE,UAAU,GAAG,EAAE,SAAS;IAClD;IACA,OAAO,GAAG,UAAU,EAAE,EAAE,UAAU,GAAG,EAAE,IAAI,kBAAkB,GAAG,EAAE,EAAE,SAAS;AAC/E;AAEO,MAAM,qBAAqB,CAAC,OACjC,IAAI,KAAK,cAAc,CAAC,SAAS;QAC/B,MAAM;QACN,OAAO;QACP,KAAK;IACP,GAAG,MAAM,CAAC;;AAML,SAAS,qBAAqB,OAAgB;IACnD,MAAM,YAAY,oDAAyB,UAAU,QAAQ,GAAG,CAAC,eAAe,KAAK;IAErF,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,MAAM,iBAAiB,QAAQ,GAAG,CAAC,WAAW,IAAI;IAClD,MAAM,qBAAqB,eAAe;IAE1C,wCAAuC;QACrC,OAAO;YACL,SAAS;YACT,UAAU,IAAI,SAAS,MAAM;gBAAE,QAAQ;YAAI;QAC7C;IACF;;;AAGF,EAEA,qDAAqD;CACrD,mDAAmD","debugId":null}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n        \"icon-sm\": \"size-8\",\n        \"icon-lg\": \"size-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  type = \"button\",\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      type={Comp === \"button\" ? type : undefined}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;;;AACA;AACA;AAEA;;;;;AAEA,MAAM,iBAAiB,IAAA,uKAAG,EACxB,+bACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,SACE;YACF,WACE;YACF,OACE;YACF,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;YACN,WAAW;YACX,WAAW;QACb;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AAGF,SAAS,OAAO,EACd,SAAS,EACT,OAAO,EACP,IAAI,EACJ,UAAU,KAAK,EACf,OAAO,QAAQ,EACf,GAAG,OAIF;IACD,MAAM,OAAO,UAAU,wKAAI,GAAG;IAE9B,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QACxD,MAAM,SAAS,WAAW,OAAO;QAChC,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 286, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/toast.tsx"],"sourcesContent":["import { useState, useEffect } from \"react\";\nimport { X } from \"lucide-react\";\nimport { Button } from \"./button\";\n\ntype ToastType = \"success\" | \"error\";\n\ninterface ToastProps {\n  message: string;\n  type: ToastType;\n  onClose: () => void;\n}\n\nfunction Toast({ message, type, onClose }: ToastProps) {\n  useEffect(() => {\n    const timer = setTimeout(onClose, 5000); // Auto close after 5 seconds\n    return () => clearTimeout(timer);\n  }, [onClose]);\n\n  return (\n    <div\n      data-testid={type === \"success\" ? \"toast-success\" : \"toast-error\"}\n      role=\"status\"\n      aria-live=\"polite\"\n      className={`fixed top-4 right-4 z-50 flex items-center gap-2 px-4 py-2 rounded-md shadow-lg ${\n        type === \"success\"\n          ? \"bg-green-500 text-white\"\n          : \"bg-red-500 text-white\"\n      }`}\n    >\n      <span className=\"flex-1\">{message}</span>\n      <Button\n        variant=\"ghost\"\n        size=\"sm\"\n        onClick={onClose}\n        className=\"h-auto p-1 hover:bg-white/20\"\n      >\n        <X className=\"h-4 w-4\" />\n      </Button>\n    </div>\n  );\n}\n\nexport function useToast() {\n  const [toast, setToast] = useState<{\n    message: string;\n    type: ToastType;\n  } | null>(null);\n\n  const showToast = (message: string, type: ToastType) => {\n    setToast({ message, type });\n  };\n\n  const hideToast = () => {\n    setToast(null);\n  };\n\n  const ToastComponent = () =>\n    toast ? (\n      <Toast\n        message={toast.message}\n        type={toast.type}\n        onClose={hideToast}\n      />\n    ) : null;\n\n  return { showToast, ToastComponent };\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;;;;;AAUA,SAAS,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAc;IACnD,IAAA,kNAAS,EAAC;QACR,MAAM,QAAQ,WAAW,SAAS,OAAO,6BAA6B;QACtE,OAAO,IAAM,aAAa;IAC5B,GAAG;QAAC;KAAQ;IAEZ,qBACE,8OAAC;QACC,eAAa,SAAS,YAAY,kBAAkB;QACpD,MAAK;QACL,aAAU;QACV,WAAW,CAAC,gFAAgF,EAC1F,SAAS,YACL,4BACA,yBACJ;;0BAEF,8OAAC;gBAAK,WAAU;0BAAU;;;;;;0BAC1B,8OAAC,qIAAM;gBACL,SAAQ;gBACR,MAAK;gBACL,SAAS;gBACT,WAAU;0BAEV,cAAA,8OAAC,iMAAC;oBAAC,WAAU;;;;;;;;;;;;;;;;;AAIrB;AAEO,SAAS;IACd,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,iNAAQ,EAGxB;IAEV,MAAM,YAAY,CAAC,SAAiB;QAClC,SAAS;YAAE;YAAS;QAAK;IAC3B;IAEA,MAAM,YAAY;QAChB,SAAS;IACX;IAEA,MAAM,iBAAiB,IACrB,sBACE,8OAAC;YACC,SAAS,MAAM,OAAO;YACtB,MAAM,MAAM,IAAI;YAChB,SAAS;;;;;mBAET;IAEN,OAAO;QAAE;QAAW;IAAe;AACrC","debugId":null}},
    {"offset": {"line": 372, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n          className,\n        )}\n        ref={ref}\n        {...props}\n      />\n    );\n  },\n);\nInput.displayName = \"Input\";\n\nexport { Input };\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,mNAAgB,CAC5B,CAAC,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAO,EAAE;IAC9B,qBACE,8OAAC;QACC,MAAM;QACN,WAAW,IAAA,kIAAE,EACX,2WACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;AAEF,MAAM,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 400, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/textarea.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Textarea({ className, ...props }: React.ComponentProps<\"textarea\">) {\n  return (\n    <textarea\n      data-slot=\"textarea\"\n      className={cn(\n        \"border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Textarea }\n"],"names":[],"mappings":";;;;;AAEA;;;AAEA,SAAS,SAAS,EAAE,SAAS,EAAE,GAAG,OAAyC;IACzE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,ucACA;QAED,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 424, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        \"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Label }\n"],"names":[],"mappings":";;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,MAAM,EACb,SAAS,EACT,GAAG,OAC8C;IACjD,qBACE,8OAAC,yKAAmB;QAClB,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,uNACA;QAED,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 451, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/events/_components/EventForm.tsx"],"sourcesContent":["\"use client\";\n\nimport { useRef } from \"react\";\nimport { Event } from \"@prisma/client\";\nimport { Save, X } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Label } from \"@/components/ui/label\";\n\nexport interface EventFormSubmitResult {\n  success: boolean;\n}\n\ninterface EventFormProps {\n  event?: Event;\n  onSubmit?: (formData: FormData) => Promise<EventFormSubmitResult | boolean | void>;\n  onCancel?: () => void;\n  isSubmitting?: boolean;\n}\n\nexport default function EventForm({\n  event,\n  onSubmit,\n  onCancel,\n  isSubmitting = false,\n}: EventFormProps) {\n  const formRef = useRef<HTMLFormElement | null>(null);\n\n  const formId = event ? `edit-event-${event.id}` : \"create-event\";\n\n  const handleSubmit = async (formData: FormData) => {\n    if (event) {\n      formData.set(\"id\", event.id.toString());\n    }\n\n    const result = await onSubmit?.(formData);\n    const didSucceed = typeof result === \"boolean\" ? result : result?.success;\n\n    if (!event && didSucceed) {\n      formRef.current?.reset();\n    }\n  };\n\n  const startTimeDefault = event?.startTime\n    ? event.startTime.toISOString().slice(0, 16)\n    : \"\";\n  const endTimeDefault = event?.endTime\n    ? event.endTime.toISOString().slice(0, 16)\n    : \"\";\n\n  return (\n    <form\n      ref={formRef}\n      id={formId}\n      action={handleSubmit}\n      className=\"space-y-4\"\n      data-testid=\"event-form\"\n    >\n      {event ? (\n        <input type=\"hidden\" name=\"id\" value={event.id} />\n      ) : null}\n\n      <div>\n        <Label htmlFor={`${formId}-title`}>Title</Label>\n        <Input\n          id={`${formId}-title`}\n          name=\"title\"\n          defaultValue={event?.title ?? \"\"}\n          className=\"text-lg font-semibold\"\n          required\n          data-testid=\"event-title\"\n        />\n      </div>\n\n      <div>\n        <Label htmlFor={`${formId}-description`}>Description</Label>\n        <Textarea\n          id={`${formId}-description`}\n          name=\"description\"\n          defaultValue={event?.description ?? \"\"}\n          rows={3}\n          data-testid=\"event-description\"\n        />\n      </div>\n\n      <div className=\"grid grid-cols-1 gap-4 md:grid-cols-2\">\n        <div>\n          <Label htmlFor={`${formId}-startTime`}>Start Time</Label>\n          <Input\n            id={`${formId}-startTime`}\n            name=\"startTime\"\n            type=\"datetime-local\"\n            defaultValue={startTimeDefault}\n            required\n            data-testid=\"event-date\"\n          />\n        </div>\n\n        <div>\n          <Label htmlFor={`${formId}-endTime`}>End Time</Label>\n          <Input\n            id={`${formId}-endTime`}\n            name=\"endTime\"\n            type=\"datetime-local\"\n            defaultValue={endTimeDefault}\n            required\n            data-testid=\"event-end-date\"\n          />\n        </div>\n      </div>\n\n      <div>\n        <Label htmlFor={`${formId}-location`}>Location</Label>\n        <Input\n          id={`${formId}-location`}\n          name=\"location\"\n          defaultValue={event?.location ?? \"\"}\n          data-testid=\"event-location\"\n        />\n      </div>\n\n      <div>\n        <Label htmlFor={`${formId}-capacity`}>Capacity</Label>\n        <Input\n          id={`${formId}-capacity`}\n          name=\"capacity\"\n          type=\"number\"\n          min=\"1\"\n          defaultValue={event?.capacity?.toString() ?? \"\"}\n          data-testid=\"event-capacity\"\n        />\n      </div>\n\n      <div className=\"flex gap-2 pt-4\">\n        <Button\n          type=\"submit\"\n          className=\"flex items-center gap-1\"\n          data-testid=\"btn-save-event\"\n          disabled={isSubmitting}\n        >\n          <Save className=\"h-3 w-3\" />\n          {isSubmitting ? \"Saving...\" : \"Save\"}\n        </Button>\n        {onCancel ? (\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            onClick={onCancel}\n            className=\"flex items-center gap-1\"\n            data-testid=\"btn-cancel-event\"\n            disabled={isSubmitting}\n          >\n            <X className=\"h-3 w-3\" />\n            Cancel\n          </Button>\n        ) : null}\n      </div>\n    </form>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 738, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/event.actions.ts"],"sourcesContent":["\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { prisma } from \"@/lib/prisma\";\nimport { assertRole } from \"@/lib/actions/profile.actions\";\nimport { UserRole } from \"@prisma/client\";\nimport { ActionResult } from \"@/lib/types\";\nimport { eventFormSchema, shiftIdSchema } from \"@/lib/schemas\";\nimport { z } from \"zod\";\n\nconst deleteEventSchema = z.object({\n  eventId: z.coerce.number().int().positive({ message: \"Invalid event ID\" }),\n});\n\nconst duplicateEventSchema = z.object({\n  eventId: z.coerce.number().int().positive({ message: \"Invalid event ID\" }),\n  fail: z.coerce.string().optional(), // For testing failure injection\n});\n\nconst revalidateEventPaths = () => {\n  revalidatePath(\"/admin/events\");\n  revalidatePath(\"/events\");\n};\n\nexport async function createEvent(prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult<{ id: number }>> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const title = formData.get('title') as string;\n    const startTime = formData.get('startTime') as string;\n    const endTime = formData.get('endTime') as string;\n    const description = formData.get('description') as string;\n\n    if (!title || !startTime || !endTime) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { title: !title ? ['Title is required'] : [], startTime: !startTime ? ['Start time is required'] : [], endTime: !endTime ? ['End time is required'] : [] },\n        data: null,\n      };\n    }\n\n    // validate times server-side\n    const start = new Date(startTime);\n    const end = new Date(endTime);\n    if (!(start instanceof Date) || !(end instanceof Date) || Number.isNaN(+start) || Number.isNaN(+end)) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { startTime: ['Invalid date/time'], endTime: ['Invalid date/time'] },\n        data: null,\n      };\n    }\n    if (end <= start) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { endTime: ['End time must be after start time'] },\n        data: null,\n      };\n    }\n\n    const ev = await prisma.event.create({\n      data: { title, startTime: start, endTime: end, description: description || null }\n    });\n    revalidatePath('/admin/events');\n    revalidatePath('/events'); // public list must reflect immediately\n    return {\n      success: true,\n      message: \"Event created successfully.\",\n      fieldErrors: undefined,\n      data: { id: ev.id },\n    };\n  } catch {\n    return {\n      success: false,\n      message: \"Failed to create event.\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function getEvents() {\n  return prisma.event.findMany({\n    orderBy: {\n      startTime: \"asc\",\n    },\n  });\n}\n\nexport async function updateEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const idParsed = shiftIdSchema.safeParse({\n      shiftId: formData.get(\"id\"),\n    });\n\n    if (!idParsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: idParsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    const parsed = eventFormSchema.safeParse({\n      title: formData.get(\"title\"),\n      description: formData.get(\"description\"),\n      startTime: formData.get(\"startTime\"),\n      endTime: formData.get(\"endTime\"),\n      location: formData.get(\"location\"),\n      capacity: formData.get(\"capacity\"),\n    });\n\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    const data = parsed.data;\n    const startTime = new Date(data.startTime);\n    const endTime = new Date(data.endTime);\n\n    // Server-side validation: startTime must be before endTime\n    if (startTime >= endTime) {\n      return {\n        success: false,\n        message: \"Start time must be before end time.\",\n        fieldErrors: { startTime: [\"Start time must be before end time\"] },\n        data: null,\n      };\n    }\n\n    // Server-side validation: forbid past start times\n    if (startTime <= new Date()) {\n      return {\n        success: false,\n        message: \"Cannot update events to start in the past.\",\n        fieldErrors: { startTime: [\"Start time must be in the future\"] },\n        data: null,\n      };\n    }\n\n    await prisma.event.update({\n      where: { id: idParsed.data.shiftId },\n      data: {\n        title: data.title,\n        description: data.description,\n        startTime,\n        endTime: new Date(data.endTime),\n        location: data.location,\n        capacity: data.capacity,\n      },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event updated successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to update event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function duplicateEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = duplicateEventSchema.safeParse({\n      eventId: formData.get(\"eventId\"),\n      fail: formData.get(\"fail\"),\n    });\n\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    // Check if we should inject a failure for testing\n    if (parsed.data.fail === '1') {\n      return {\n        success: false,\n        message: \"Simulated failure for testing optimistic rollback\",\n        fieldErrors: undefined,\n        data: null,\n      };\n    }\n\n    const originalEvent = await prisma.event.findUnique({\n      where: { id: parsed.data.eventId },\n    });\n\n    if (!originalEvent) {\n      return {\n        success: false,\n        message: \"Event not found.\",\n        fieldErrors: { eventId: [\"Event not found\"] },\n        data: null,\n      };\n    }\n\n    // Create duplicate with \"Copy of\" prefix\n    await prisma.event.create({\n      data: {\n        title: `Copy of ${originalEvent.title}`,\n        description: originalEvent.description,\n        startTime: originalEvent.startTime,\n        endTime: originalEvent.endTime,\n        location: originalEvent.location,\n        capacity: originalEvent.capacity,\n      },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event duplicated successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to duplicate event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function deleteEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = deleteEventSchema.safeParse({\n      eventId: formData.get(\"eventId\"),\n    });\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    await prisma.event.delete({\n      where: { id: parsed.data.eventId },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event deleted successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to delete event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IA2FsB,cAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 750, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/event.actions.ts"],"sourcesContent":["\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { prisma } from \"@/lib/prisma\";\nimport { assertRole } from \"@/lib/actions/profile.actions\";\nimport { UserRole } from \"@prisma/client\";\nimport { ActionResult } from \"@/lib/types\";\nimport { eventFormSchema, shiftIdSchema } from \"@/lib/schemas\";\nimport { z } from \"zod\";\n\nconst deleteEventSchema = z.object({\n  eventId: z.coerce.number().int().positive({ message: \"Invalid event ID\" }),\n});\n\nconst duplicateEventSchema = z.object({\n  eventId: z.coerce.number().int().positive({ message: \"Invalid event ID\" }),\n  fail: z.coerce.string().optional(), // For testing failure injection\n});\n\nconst revalidateEventPaths = () => {\n  revalidatePath(\"/admin/events\");\n  revalidatePath(\"/events\");\n};\n\nexport async function createEvent(prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult<{ id: number }>> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const title = formData.get('title') as string;\n    const startTime = formData.get('startTime') as string;\n    const endTime = formData.get('endTime') as string;\n    const description = formData.get('description') as string;\n\n    if (!title || !startTime || !endTime) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { title: !title ? ['Title is required'] : [], startTime: !startTime ? ['Start time is required'] : [], endTime: !endTime ? ['End time is required'] : [] },\n        data: null,\n      };\n    }\n\n    // validate times server-side\n    const start = new Date(startTime);\n    const end = new Date(endTime);\n    if (!(start instanceof Date) || !(end instanceof Date) || Number.isNaN(+start) || Number.isNaN(+end)) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { startTime: ['Invalid date/time'], endTime: ['Invalid date/time'] },\n        data: null,\n      };\n    }\n    if (end <= start) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { endTime: ['End time must be after start time'] },\n        data: null,\n      };\n    }\n\n    const ev = await prisma.event.create({\n      data: { title, startTime: start, endTime: end, description: description || null }\n    });\n    revalidatePath('/admin/events');\n    revalidatePath('/events'); // public list must reflect immediately\n    return {\n      success: true,\n      message: \"Event created successfully.\",\n      fieldErrors: undefined,\n      data: { id: ev.id },\n    };\n  } catch {\n    return {\n      success: false,\n      message: \"Failed to create event.\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function getEvents() {\n  return prisma.event.findMany({\n    orderBy: {\n      startTime: \"asc\",\n    },\n  });\n}\n\nexport async function updateEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const idParsed = shiftIdSchema.safeParse({\n      shiftId: formData.get(\"id\"),\n    });\n\n    if (!idParsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: idParsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    const parsed = eventFormSchema.safeParse({\n      title: formData.get(\"title\"),\n      description: formData.get(\"description\"),\n      startTime: formData.get(\"startTime\"),\n      endTime: formData.get(\"endTime\"),\n      location: formData.get(\"location\"),\n      capacity: formData.get(\"capacity\"),\n    });\n\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    const data = parsed.data;\n    const startTime = new Date(data.startTime);\n    const endTime = new Date(data.endTime);\n\n    // Server-side validation: startTime must be before endTime\n    if (startTime >= endTime) {\n      return {\n        success: false,\n        message: \"Start time must be before end time.\",\n        fieldErrors: { startTime: [\"Start time must be before end time\"] },\n        data: null,\n      };\n    }\n\n    // Server-side validation: forbid past start times\n    if (startTime <= new Date()) {\n      return {\n        success: false,\n        message: \"Cannot update events to start in the past.\",\n        fieldErrors: { startTime: [\"Start time must be in the future\"] },\n        data: null,\n      };\n    }\n\n    await prisma.event.update({\n      where: { id: idParsed.data.shiftId },\n      data: {\n        title: data.title,\n        description: data.description,\n        startTime,\n        endTime: new Date(data.endTime),\n        location: data.location,\n        capacity: data.capacity,\n      },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event updated successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to update event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function duplicateEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = duplicateEventSchema.safeParse({\n      eventId: formData.get(\"eventId\"),\n      fail: formData.get(\"fail\"),\n    });\n\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    // Check if we should inject a failure for testing\n    if (parsed.data.fail === '1') {\n      return {\n        success: false,\n        message: \"Simulated failure for testing optimistic rollback\",\n        fieldErrors: undefined,\n        data: null,\n      };\n    }\n\n    const originalEvent = await prisma.event.findUnique({\n      where: { id: parsed.data.eventId },\n    });\n\n    if (!originalEvent) {\n      return {\n        success: false,\n        message: \"Event not found.\",\n        fieldErrors: { eventId: [\"Event not found\"] },\n        data: null,\n      };\n    }\n\n    // Create duplicate with \"Copy of\" prefix\n    await prisma.event.create({\n      data: {\n        title: `Copy of ${originalEvent.title}`,\n        description: originalEvent.description,\n        startTime: originalEvent.startTime,\n        endTime: originalEvent.endTime,\n        location: originalEvent.location,\n        capacity: originalEvent.capacity,\n      },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event duplicated successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to duplicate event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function deleteEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = deleteEventSchema.safeParse({\n      eventId: formData.get(\"eventId\"),\n    });\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    await prisma.event.delete({\n      where: { id: parsed.data.eventId },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event deleted successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to delete event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IA2PsB,cAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 762, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/event.actions.ts"],"sourcesContent":["\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { prisma } from \"@/lib/prisma\";\nimport { assertRole } from \"@/lib/actions/profile.actions\";\nimport { UserRole } from \"@prisma/client\";\nimport { ActionResult } from \"@/lib/types\";\nimport { eventFormSchema, shiftIdSchema } from \"@/lib/schemas\";\nimport { z } from \"zod\";\n\nconst deleteEventSchema = z.object({\n  eventId: z.coerce.number().int().positive({ message: \"Invalid event ID\" }),\n});\n\nconst duplicateEventSchema = z.object({\n  eventId: z.coerce.number().int().positive({ message: \"Invalid event ID\" }),\n  fail: z.coerce.string().optional(), // For testing failure injection\n});\n\nconst revalidateEventPaths = () => {\n  revalidatePath(\"/admin/events\");\n  revalidatePath(\"/events\");\n};\n\nexport async function createEvent(prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult<{ id: number }>> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const title = formData.get('title') as string;\n    const startTime = formData.get('startTime') as string;\n    const endTime = formData.get('endTime') as string;\n    const description = formData.get('description') as string;\n\n    if (!title || !startTime || !endTime) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { title: !title ? ['Title is required'] : [], startTime: !startTime ? ['Start time is required'] : [], endTime: !endTime ? ['End time is required'] : [] },\n        data: null,\n      };\n    }\n\n    // validate times server-side\n    const start = new Date(startTime);\n    const end = new Date(endTime);\n    if (!(start instanceof Date) || !(end instanceof Date) || Number.isNaN(+start) || Number.isNaN(+end)) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { startTime: ['Invalid date/time'], endTime: ['Invalid date/time'] },\n        data: null,\n      };\n    }\n    if (end <= start) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: { endTime: ['End time must be after start time'] },\n        data: null,\n      };\n    }\n\n    const ev = await prisma.event.create({\n      data: { title, startTime: start, endTime: end, description: description || null }\n    });\n    revalidatePath('/admin/events');\n    revalidatePath('/events'); // public list must reflect immediately\n    return {\n      success: true,\n      message: \"Event created successfully.\",\n      fieldErrors: undefined,\n      data: { id: ev.id },\n    };\n  } catch {\n    return {\n      success: false,\n      message: \"Failed to create event.\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function getEvents() {\n  return prisma.event.findMany({\n    orderBy: {\n      startTime: \"asc\",\n    },\n  });\n}\n\nexport async function updateEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const idParsed = shiftIdSchema.safeParse({\n      shiftId: formData.get(\"id\"),\n    });\n\n    if (!idParsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: idParsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    const parsed = eventFormSchema.safeParse({\n      title: formData.get(\"title\"),\n      description: formData.get(\"description\"),\n      startTime: formData.get(\"startTime\"),\n      endTime: formData.get(\"endTime\"),\n      location: formData.get(\"location\"),\n      capacity: formData.get(\"capacity\"),\n    });\n\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    const data = parsed.data;\n    const startTime = new Date(data.startTime);\n    const endTime = new Date(data.endTime);\n\n    // Server-side validation: startTime must be before endTime\n    if (startTime >= endTime) {\n      return {\n        success: false,\n        message: \"Start time must be before end time.\",\n        fieldErrors: { startTime: [\"Start time must be before end time\"] },\n        data: null,\n      };\n    }\n\n    // Server-side validation: forbid past start times\n    if (startTime <= new Date()) {\n      return {\n        success: false,\n        message: \"Cannot update events to start in the past.\",\n        fieldErrors: { startTime: [\"Start time must be in the future\"] },\n        data: null,\n      };\n    }\n\n    await prisma.event.update({\n      where: { id: idParsed.data.shiftId },\n      data: {\n        title: data.title,\n        description: data.description,\n        startTime,\n        endTime: new Date(data.endTime),\n        location: data.location,\n        capacity: data.capacity,\n      },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event updated successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to update event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function duplicateEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = duplicateEventSchema.safeParse({\n      eventId: formData.get(\"eventId\"),\n      fail: formData.get(\"fail\"),\n    });\n\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    // Check if we should inject a failure for testing\n    if (parsed.data.fail === '1') {\n      return {\n        success: false,\n        message: \"Simulated failure for testing optimistic rollback\",\n        fieldErrors: undefined,\n        data: null,\n      };\n    }\n\n    const originalEvent = await prisma.event.findUnique({\n      where: { id: parsed.data.eventId },\n    });\n\n    if (!originalEvent) {\n      return {\n        success: false,\n        message: \"Event not found.\",\n        fieldErrors: { eventId: [\"Event not found\"] },\n        data: null,\n      };\n    }\n\n    // Create duplicate with \"Copy of\" prefix\n    await prisma.event.create({\n      data: {\n        title: `Copy of ${originalEvent.title}`,\n        description: originalEvent.description,\n        startTime: originalEvent.startTime,\n        endTime: originalEvent.endTime,\n        location: originalEvent.location,\n        capacity: originalEvent.capacity,\n      },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event duplicated successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to duplicate event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function deleteEvent(_prevState: ActionResult | undefined, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = deleteEventSchema.safeParse({\n      eventId: formData.get(\"eventId\"),\n    });\n    if (!parsed.success) {\n      return {\n        success: false,\n        message: \"Validation failed.\",\n        fieldErrors: parsed.error.flatten().fieldErrors,\n        data: null,\n      };\n    }\n\n    await prisma.event.delete({\n      where: { id: parsed.data.eventId },\n    });\n\n    revalidateEventPaths();\n\n    return {\n      success: true,\n      message: \"Event deleted successfully!\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : \"Failed to delete event\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IAoLsB,iBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 774, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/utils/date.ts"],"sourcesContent":["/**\n * Convert a Date object to a datetime-local input value\n * @param date Date to convert\n * @returns String in YYYY-MM-DDTHH:MM format\n */\nexport const toDateTimeLocal = (date: Date): string => {\n  const pad = (value: number) => String(value).padStart(2, \"0\");\n  const year = date.getFullYear();\n  const month = pad(date.getMonth() + 1);\n  const day = pad(date.getDate());\n  const hours = pad(date.getHours());\n  const minutes = pad(date.getMinutes());\n  return `${year}-${month}-${day}T${hours}:${minutes}`;\n};\n\n/**\n * Format a date for display with timezone\n * @param date Date to format\n * @returns Formatted date string with timezone\n */\nexport const formatDateTimeWithTimezone = (date: Date): string => {\n  return date.toLocaleString(undefined, {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    timeZoneName: 'short'\n  });\n};\n\n/**\n * Check if a date is in the past\n * @param date Date to check\n * @returns True if the date is before now\n */\nexport const isPastDate = (date: Date): boolean => {\n  return date < new Date();\n};\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;;;AACM,MAAM,kBAAkB,CAAC;IAC9B,MAAM,MAAM,CAAC,QAAkB,OAAO,OAAO,QAAQ,CAAC,GAAG;IACzD,MAAM,OAAO,KAAK,WAAW;IAC7B,MAAM,QAAQ,IAAI,KAAK,QAAQ,KAAK;IACpC,MAAM,MAAM,IAAI,KAAK,OAAO;IAC5B,MAAM,QAAQ,IAAI,KAAK,QAAQ;IAC/B,MAAM,UAAU,IAAI,KAAK,UAAU;IACnC,OAAO,GAAG,KAAK,CAAC,EAAE,MAAM,CAAC,EAAE,IAAI,CAAC,EAAE,MAAM,CAAC,EAAE,SAAS;AACtD;AAOO,MAAM,6BAA6B,CAAC;IACzC,OAAO,KAAK,cAAc,CAAC,WAAW;QACpC,MAAM;QACN,OAAO;QACP,KAAK;QACL,MAAM;QACN,QAAQ;QACR,cAAc;IAChB;AACF;AAOO,MAAM,aAAa,CAAC;IACzB,OAAO,OAAO,IAAI;AACpB","debugId":null}},
    {"offset": {"line": 812, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-xl border bg-card text-card-foreground shadow\",\n      className,\n    )}\n    {...props}\n  />\n));\nCard.displayName = \"Card\";\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n));\nCardHeader.displayName = \"CardHeader\";\n\nconst CardTitle = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"font-semibold leading-none tracking-tight\", className)}\n    {...props}\n  />\n));\nCardTitle.displayName = \"CardTitle\";\n\nconst CardDescription = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n));\nCardDescription.displayName = \"CardDescription\";\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n));\nCardContent.displayName = \"CardContent\";\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n));\nCardFooter.displayName = \"CardFooter\";\n\nexport {\n  Card,\n  CardHeader,\n  CardFooter,\n  CardTitle,\n  CardDescription,\n  CardContent,\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,mNAAgB,CAG3B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,IAAA,kIAAE,EACX,yDACA;QAED,GAAG,KAAK;;;;;;AAGb,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,mNAAgB,CAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,IAAA,kIAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,mNAAgB,CAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,IAAA,kIAAE,EAAC,6CAA6C;QAC1D,GAAG,KAAK;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,mNAAgB,CAGtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,IAAA,kIAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,mNAAgB,CAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,kIAAE,EAAC,YAAY;QAAa,GAAG,KAAK;;;;;;AAEhE,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,mNAAgB,CAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,IAAA,kIAAE,EAAC,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGb,WAAW,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 897, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/badge.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  },\n);\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  );\n}\n\nexport { Badge, badgeVariants };\n"],"names":[],"mappings":";;;;;;;AACA;AAEA;;;;AAEA,MAAM,gBAAgB,IAAA,uKAAG,EACvB,wKACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,WACE;YACF,aACE;YACF,SAAS;QACX;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAOF,SAAS,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAmB;IACzD,qBACE,8OAAC;QAAI,WAAW,IAAA,kIAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QAAa,GAAG,KAAK;;;;;;AAExE","debugId":null}},
    {"offset": {"line": 939, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/alert-dialog.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nfunction AlertDialog({\n  ...props\n}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {\n  return <AlertDialogPrimitive.Root data-slot=\"alert-dialog\" {...props} />\n}\n\nfunction AlertDialogTrigger({\n  ...props\n}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {\n  return (\n    <AlertDialogPrimitive.Trigger data-slot=\"alert-dialog-trigger\" {...props} />\n  )\n}\n\nfunction AlertDialogPortal({\n  ...props\n}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {\n  return (\n    <AlertDialogPrimitive.Portal data-slot=\"alert-dialog-portal\" {...props} />\n  )\n}\n\nfunction AlertDialogOverlay({\n  className,\n  ...props\n}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {\n  return (\n    <AlertDialogPrimitive.Overlay\n      data-slot=\"alert-dialog-overlay\"\n      className={cn(\n        \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction AlertDialogContent({\n  className,\n  ...props\n}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {\n  return (\n    <AlertDialogPortal>\n      <AlertDialogOverlay />\n      <AlertDialogPrimitive.Content\n        data-slot=\"alert-dialog-content\"\n        className={cn(\n          \"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg\",\n          className\n        )}\n        {...props}\n      />\n    </AlertDialogPortal>\n  )\n}\n\nfunction AlertDialogHeader({\n  className,\n  ...props\n}: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"alert-dialog-header\"\n      className={cn(\"flex flex-col gap-2 text-center sm:text-left\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction AlertDialogFooter({\n  className,\n  ...props\n}: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"alert-dialog-footer\"\n      className={cn(\n        \"flex flex-col-reverse gap-2 sm:flex-row sm:justify-end\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction AlertDialogTitle({\n  className,\n  ...props\n}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {\n  return (\n    <AlertDialogPrimitive.Title\n      data-slot=\"alert-dialog-title\"\n      className={cn(\"text-lg font-semibold\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction AlertDialogDescription({\n  className,\n  ...props\n}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {\n  return (\n    <AlertDialogPrimitive.Description\n      data-slot=\"alert-dialog-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction AlertDialogAction({\n  className,\n  ...props\n}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {\n  return (\n    <AlertDialogPrimitive.Action\n      className={cn(buttonVariants(), className)}\n      {...props}\n    />\n  )\n}\n\nfunction AlertDialogCancel({\n  className,\n  ...props\n}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {\n  return (\n    <AlertDialogPrimitive.Cancel\n      className={cn(buttonVariants({ variant: \"outline\" }), className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAEA;AACA;AANA;;;;;AAQA,SAAS,YAAY,EACnB,GAAG,OACoD;IACvD,qBAAO,8OAAC,mLAAyB;QAAC,aAAU;QAAgB,GAAG,KAAK;;;;;;AACtE;AAEA,SAAS,mBAAmB,EAC1B,GAAG,OACuD;IAC1D,qBACE,8OAAC,sLAA4B;QAAC,aAAU;QAAwB,GAAG,KAAK;;;;;;AAE5E;AAEA,SAAS,kBAAkB,EACzB,GAAG,OACsD;IACzD,qBACE,8OAAC,qLAA2B;QAAC,aAAU;QAAuB,GAAG,KAAK;;;;;;AAE1E;AAEA,SAAS,mBAAmB,EAC1B,SAAS,EACT,GAAG,OACuD;IAC1D,qBACE,8OAAC,sLAA4B;QAC3B,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,0JACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,mBAAmB,EAC1B,SAAS,EACT,GAAG,OACuD;IAC1D,qBACE,8OAAC;;0BACC,8OAAC;;;;;0BACD,8OAAC,sLAA4B;gBAC3B,aAAU;gBACV,WAAW,IAAA,kIAAE,EACX,+WACA;gBAED,GAAG,KAAK;;;;;;;;;;;;AAIjB;AAEA,SAAS,kBAAkB,EACzB,SAAS,EACT,GAAG,OACyB;IAC5B,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,gDAAgD;QAC7D,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,kBAAkB,EACzB,SAAS,EACT,GAAG,OACyB;IAC5B,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,0DACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,iBAAiB,EACxB,SAAS,EACT,GAAG,OACqD;IACxD,qBACE,8OAAC,oLAA0B;QACzB,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,yBAAyB;QACtC,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,uBAAuB,EAC9B,SAAS,EACT,GAAG,OAC2D;IAC9D,qBACE,8OAAC,0LAAgC;QAC/B,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,kBAAkB,EACzB,SAAS,EACT,GAAG,OACsD;IACzD,qBACE,8OAAC,qLAA2B;QAC1B,WAAW,IAAA,kIAAE,EAAC,IAAA,6IAAc,KAAI;QAC/B,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,kBAAkB,EACzB,SAAS,EACT,GAAG,OACsD;IACzD,qBACE,8OAAC,qLAA2B;QAC1B,WAAW,IAAA,kIAAE,EAAC,IAAA,6IAAc,EAAC;YAAE,SAAS;QAAU,IAAI;QACrD,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 1108, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/components/ui/dialog.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { XIcon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Dialog({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Root>) {\n  return <DialogPrimitive.Root data-slot=\"dialog\" {...props} />\n}\n\nfunction DialogTrigger({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {\n  return <DialogPrimitive.Trigger data-slot=\"dialog-trigger\" {...props} />\n}\n\nfunction DialogPortal({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Portal>) {\n  return <DialogPrimitive.Portal data-slot=\"dialog-portal\" {...props} />\n}\n\nfunction DialogClose({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Close>) {\n  return <DialogPrimitive.Close data-slot=\"dialog-close\" {...props} />\n}\n\nfunction DialogOverlay({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {\n  return (\n    <DialogPrimitive.Overlay\n      data-slot=\"dialog-overlay\"\n      className={cn(\n        \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DialogContent({\n  className,\n  children,\n  showCloseButton = true,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Content> & {\n  showCloseButton?: boolean\n}) {\n  return (\n    <DialogPortal data-slot=\"dialog-portal\">\n      <DialogOverlay />\n      <DialogPrimitive.Content\n        data-slot=\"dialog-content\"\n        className={cn(\n          \"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n        {showCloseButton && (\n          <DialogPrimitive.Close\n            data-slot=\"dialog-close\"\n            className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\"\n          >\n            <XIcon />\n            <span className=\"sr-only\">Close</span>\n          </DialogPrimitive.Close>\n        )}\n      </DialogPrimitive.Content>\n    </DialogPortal>\n  )\n}\n\nfunction DialogHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"dialog-header\"\n      className={cn(\"flex flex-col gap-2 text-center sm:text-left\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction DialogFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"dialog-footer\"\n      className={cn(\n        \"flex flex-col-reverse gap-2 sm:flex-row sm:justify-end\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DialogTitle({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Title>) {\n  return (\n    <DialogPrimitive.Title\n      data-slot=\"dialog-title\"\n      className={cn(\"text-lg leading-none font-semibold\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction DialogDescription({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Description>) {\n  return (\n    <DialogPrimitive.Description\n      data-slot=\"dialog-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogOverlay,\n  DialogPortal,\n  DialogTitle,\n  DialogTrigger,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AAEA;AANA;;;;;AAQA,SAAS,OAAO,EACd,GAAG,OAC+C;IAClD,qBAAO,8OAAC,0KAAoB;QAAC,aAAU;QAAU,GAAG,KAAK;;;;;;AAC3D;AAEA,SAAS,cAAc,EACrB,GAAG,OACkD;IACrD,qBAAO,8OAAC,6KAAuB;QAAC,aAAU;QAAkB,GAAG,KAAK;;;;;;AACtE;AAEA,SAAS,aAAa,EACpB,GAAG,OACiD;IACpD,qBAAO,8OAAC,4KAAsB;QAAC,aAAU;QAAiB,GAAG,KAAK;;;;;;AACpE;AAEA,SAAS,YAAY,EACnB,GAAG,OACgD;IACnD,qBAAO,8OAAC,2KAAqB;QAAC,aAAU;QAAgB,GAAG,KAAK;;;;;;AAClE;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,GAAG,OACkD;IACrD,qBACE,8OAAC,6KAAuB;QACtB,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,0JACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,QAAQ,EACR,kBAAkB,IAAI,EACtB,GAAG,OAGJ;IACC,qBACE,8OAAC;QAAa,aAAU;;0BACtB,8OAAC;;;;;0BACD,8OAAC,6KAAuB;gBACtB,aAAU;gBACV,WAAW,IAAA,kIAAE,EACX,+WACA;gBAED,GAAG,KAAK;;oBAER;oBACA,iCACC,8OAAC,2KAAqB;wBACpB,aAAU;wBACV,WAAU;;0CAEV,8OAAC,yMAAK;;;;;0CACN,8OAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;AAMtC;AAEA,SAAS,aAAa,EAAE,SAAS,EAAE,GAAG,OAAoC;IACxE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,gDAAgD;QAC7D,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,aAAa,EAAE,SAAS,EAAE,GAAG,OAAoC;IACxE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kIAAE,EACX,0DACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACgD;IACnD,qBACE,8OAAC,2KAAqB;QACpB,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,sCAAsC;QACnD,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,kBAAkB,EACzB,SAAS,EACT,GAAG,OACsD;IACzD,qBACE,8OAAC,iLAA2B;QAC1B,aAAU;QACV,WAAW,IAAA,kIAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 1290, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/events/_components/EventCard.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState } from \"react\";\nimport { Event } from \"@prisma/client\";\nimport { formatDateTimeWithTimezone, isPastDate } from \"@/lib/utils/date\";\nimport { Calendar, MapPin, Edit, Trash2, Copy } from \"lucide-react\";\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Badge } from \"@/components/ui/badge\";\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from \"@/components/ui/alert-dialog\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport EventForm from \"./EventForm\";\n\ninterface EventCardProps {\n  event: Event;\n  onUpdate?: (formData: FormData) => Promise<void>;\n  onDelete?: (formData: FormData) => Promise<void>;\n  onDuplicate?: (formData: FormData) => Promise<void>;\n}\n\nexport default function EventCard({ event, onUpdate, onDelete, onDuplicate }: EventCardProps) {\n  const [isDeleting, setIsDeleting] = useState(false);\n  const [showDeleteDialog, setShowDeleteDialog] = useState(false);\n  const [showEditDialog, setShowEditDialog] = useState(false);\n  const [isSaving, setIsSaving] = useState(false);\n\n  const handleUpdate = async (formData: FormData) => {\n    if (!onUpdate) {\n      return;\n    }\n\n    setIsSaving(true);\n    try {\n      await onUpdate(formData);\n      setShowEditDialog(false);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const handleDelete = async () => {\n    if (!onDelete) return;\n\n    const formData = new FormData();\n    formData.append(\"eventId\", event.id.toString());\n\n    setIsDeleting(true);\n    try {\n      await onDelete(formData);\n    } finally {\n      setIsDeleting(false);\n    }\n  };\n\n  const handleDuplicate = async (formData: FormData) => {\n    if (onDuplicate) {\n      await onDuplicate(formData);\n    }\n  };\n\n  const isPast = isPastDate(event.startTime);\n  const isUpcoming = !isPast && new Date(event.startTime).getTime() - Date.now() < 7 * 24 * 60 * 60 * 1000; // Next 7 days\n\n  return (\n    <Card className={`${isPast ? \"opacity-75\" : \"\"}`}>\n      <CardHeader>\n        <div className=\"flex items-start justify-between\">\n          <div className=\"flex-1\">\n            <CardTitle className=\"flex items-center gap-2\">\n              <Calendar className=\"h-4 w-4\" />\n              {event.title}\n            </CardTitle>\n            <CardDescription className=\"flex items-center gap-4 mt-2\">\n              <span>\n                {formatDateTimeWithTimezone(event.startTime)} - {formatDateTimeWithTimezone(event.endTime)}\n              </span>\n              {isPast && <Badge variant=\"secondary\">Past</Badge>}\n              {isUpcoming && !isPast && <Badge variant=\"default\">Upcoming</Badge>}\n            </CardDescription>\n          </div>\n\n          <div className=\"flex gap-2\">\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={() => setShowEditDialog(true)}\n              className=\"flex items-center gap-1\"\n            >\n              <Edit className=\"h-3 w-3\" />\n              Edit\n            </Button>\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              data-testid=\"duplicate-event\"\n              onClick={() => {\n                const formData = new FormData();\n                formData.append(\"eventId\", event.id.toString());\n                handleDuplicate(formData);\n              }}\n              className=\"flex items-center gap-1\"\n            >\n              <Copy className=\"h-3 w-3\" />\n              Duplicate\n            </Button>\n            <Button\n              variant=\"destructive\"\n              size=\"sm\"\n              data-testid=\"delete-event\"\n              onClick={() => setShowDeleteDialog(true)}\n              disabled={isDeleting}\n              className=\"flex items-center gap-1\"\n            >\n              <Trash2 className=\"h-3 w-3\" />\n              {isDeleting ? \"Deleting...\" : \"Delete\"}\n            </Button>\n          </div>\n        </div>\n      </CardHeader>\n\n      <CardContent>\n        <div className=\"space-y-3\">\n          {event.description && (\n            <p className=\"text-sm text-muted-foreground\">{event.description}</p>\n          )}\n\n          {event.location && (\n            <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n              <MapPin className=\"h-4 w-4\" />\n              <span>{event.location}</span>\n            </div>\n          )}\n\n          <div className=\"text-xs text-muted-foreground\">\n            Created: {formatDateTimeWithTimezone(event.createdAt)}\n            {event.updatedAt.getTime() !== event.createdAt.getTime() && (\n              <> • Updated: {formatDateTimeWithTimezone(event.updatedAt)}</>\n            )}\n          </div>\n        </div>\n      </CardContent>\n\n      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>\n        <AlertDialogContent data-testid=\"confirm-delete-event\">\n          <AlertDialogHeader>\n            <AlertDialogTitle>Delete Event</AlertDialogTitle>\n            <AlertDialogDescription>\n              Are you sure you want to delete &ldquo;{event.title}&rdquo;? This action cannot be undone.\n            </AlertDialogDescription>\n          </AlertDialogHeader>\n          <AlertDialogFooter>\n            <AlertDialogCancel>Cancel</AlertDialogCancel>\n            <AlertDialogAction\n              onClick={handleDelete}\n              className=\"bg-destructive text-destructive-foreground hover:bg-destructive/90\"\n            >\n              Delete\n            </AlertDialogAction>\n          </AlertDialogFooter>\n        </AlertDialogContent>\n      </AlertDialog>\n\n      <Dialog open={showEditDialog} onOpenChange={setShowEditDialog}>\n        <DialogContent className=\"max-w-2xl\">\n          <DialogHeader>\n            <DialogTitle>Edit Event</DialogTitle>\n          </DialogHeader>\n          <EventForm\n            event={event}\n            onSubmit={handleUpdate}\n            onCancel={() => setShowEditDialog(false)}\n            isSubmitting={isSaving}\n          />\n        </DialogContent>\n      </Dialog>\n    </Card>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAUA;AAMA;AAzBA;;;;;;;;;;;AAkCe,SAAS,UAAU,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,WAAW,EAAkB;IAC1F,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,iNAAQ,EAAC;IAC7C,MAAM,CAAC,kBAAkB,oBAAoB,GAAG,IAAA,iNAAQ,EAAC;IACzD,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,iNAAQ,EAAC;IACrD,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,iNAAQ,EAAC;IAEzC,MAAM,eAAe,OAAO;QAC1B,IAAI,CAAC,UAAU;YACb;QACF;QAEA,YAAY;QACZ,IAAI;YACF,MAAM,SAAS;YACf,kBAAkB;QACpB,SAAU;YACR,YAAY;QACd;IACF;IAEA,MAAM,eAAe;QACnB,IAAI,CAAC,UAAU;QAEf,MAAM,WAAW,IAAI;QACrB,SAAS,MAAM,CAAC,WAAW,MAAM,EAAE,CAAC,QAAQ;QAE5C,cAAc;QACd,IAAI;YACF,MAAM,SAAS;QACjB,SAAU;YACR,cAAc;QAChB;IACF;IAEA,MAAM,kBAAkB,OAAO;QAC7B,IAAI,aAAa;YACf,MAAM,YAAY;QACpB;IACF;IAEA,MAAM,SAAS,IAAA,kIAAU,EAAC,MAAM,SAAS;IACzC,MAAM,aAAa,CAAC,UAAU,IAAI,KAAK,MAAM,SAAS,EAAE,OAAO,KAAK,KAAK,GAAG,KAAK,IAAI,KAAK,KAAK,KAAK,MAAM,cAAc;IAExH,qBACE,8OAAC,iIAAI;QAAC,WAAW,GAAG,SAAS,eAAe,IAAI;;0BAC9C,8OAAC,uIAAU;0BACT,cAAA,8OAAC;oBAAI,WAAU;;sCACb,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,sIAAS;oCAAC,WAAU;;sDACnB,8OAAC,sNAAQ;4CAAC,WAAU;;;;;;wCACnB,MAAM,KAAK;;;;;;;8CAEd,8OAAC,4IAAe;oCAAC,WAAU;;sDACzB,8OAAC;;gDACE,IAAA,kJAA0B,EAAC,MAAM,SAAS;gDAAE;gDAAI,IAAA,kJAA0B,EAAC,MAAM,OAAO;;;;;;;wCAE1F,wBAAU,8OAAC,mIAAK;4CAAC,SAAQ;sDAAY;;;;;;wCACrC,cAAc,CAAC,wBAAU,8OAAC,mIAAK;4CAAC,SAAQ;sDAAU;;;;;;;;;;;;;;;;;;sCAIvD,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,qIAAM;oCACL,SAAQ;oCACR,MAAK;oCACL,SAAS,IAAM,kBAAkB;oCACjC,WAAU;;sDAEV,8OAAC,mNAAI;4CAAC,WAAU;;;;;;wCAAY;;;;;;;8CAG9B,8OAAC,qIAAM;oCACL,SAAQ;oCACR,MAAK;oCACL,eAAY;oCACZ,SAAS;wCACP,MAAM,WAAW,IAAI;wCACrB,SAAS,MAAM,CAAC,WAAW,MAAM,EAAE,CAAC,QAAQ;wCAC5C,gBAAgB;oCAClB;oCACA,WAAU;;sDAEV,8OAAC,0MAAI;4CAAC,WAAU;;;;;;wCAAY;;;;;;;8CAG9B,8OAAC,qIAAM;oCACL,SAAQ;oCACR,MAAK;oCACL,eAAY;oCACZ,SAAS,IAAM,oBAAoB;oCACnC,UAAU;oCACV,WAAU;;sDAEV,8OAAC,oNAAM;4CAAC,WAAU;;;;;;wCACjB,aAAa,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;0BAMtC,8OAAC,wIAAW;0BACV,cAAA,8OAAC;oBAAI,WAAU;;wBACZ,MAAM,WAAW,kBAChB,8OAAC;4BAAE,WAAU;sCAAiC,MAAM,WAAW;;;;;;wBAGhE,MAAM,QAAQ,kBACb,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,oNAAM;oCAAC,WAAU;;;;;;8CAClB,8OAAC;8CAAM,MAAM,QAAQ;;;;;;;;;;;;sCAIzB,8OAAC;4BAAI,WAAU;;gCAAgC;gCACnC,IAAA,kJAA0B,EAAC,MAAM,SAAS;gCACnD,MAAM,SAAS,CAAC,OAAO,OAAO,MAAM,SAAS,CAAC,OAAO,oBACpD;;wCAAE;wCAAa,IAAA,kJAA0B,EAAC,MAAM,SAAS;;;;;;;;;;;;;;;;;;;;0BAMjE,8OAAC,mJAAW;gBAAC,MAAM;gBAAkB,cAAc;0BACjD,cAAA,8OAAC,0JAAkB;oBAAC,eAAY;;sCAC9B,8OAAC,yJAAiB;;8CAChB,8OAAC,wJAAgB;8CAAC;;;;;;8CAClB,8OAAC,8JAAsB;;wCAAC;wCACkB,MAAM,KAAK;wCAAC;;;;;;;;;;;;;sCAGxD,8OAAC,yJAAiB;;8CAChB,8OAAC,yJAAiB;8CAAC;;;;;;8CACnB,8OAAC,yJAAiB;oCAChB,SAAS;oCACT,WAAU;8CACX;;;;;;;;;;;;;;;;;;;;;;;0BAOP,8OAAC,qIAAM;gBAAC,MAAM;gBAAgB,cAAc;0BAC1C,cAAA,8OAAC,4IAAa;oBAAC,WAAU;;sCACvB,8OAAC,2IAAY;sCACX,cAAA,8OAAC,0IAAW;0CAAC;;;;;;;;;;;sCAEf,8OAAC,8JAAS;4BACR,OAAO;4BACP,UAAU;4BACV,UAAU,IAAM,kBAAkB;4BAClC,cAAc;;;;;;;;;;;;;;;;;;;;;;;AAM1B","debugId":null}},
    {"offset": {"line": 1691, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/events/_components/EventsList.tsx"],"sourcesContent":["\"use client\";\n\nimport { Event } from \"@prisma/client\";\nimport { useToast } from \"@/components/ui/toast\";\nimport { updateEvent, deleteEvent, duplicateEvent } from \"@/lib/actions/event.actions\";\nimport EventCard from \"./EventCard\";\n\ninterface EventsListProps {\n  events: Event[];\n}\n\nexport default function EventsList({ events }: EventsListProps) {\n  const { showToast } = useToast();\n\n  const handleUpdate = async (formData: FormData) => {\n    const result = await updateEvent(undefined, formData);\n\n    if (result.success) {\n      showToast(result.message || \"Event updated successfully!\", \"success\");\n    } else {\n      showToast(result.message || \"Failed to update event.\", \"error\");\n    }\n  };\n\n  const handleDelete = async (formData: FormData) => {\n    const result = await deleteEvent(undefined, formData);\n\n    if (result.success) {\n      showToast(result.message || \"Event deleted successfully!\", \"success\");\n    } else {\n      showToast(result.message || \"Failed to delete event.\", \"error\");\n    }\n  };\n\n  const handleDuplicate = async (formData: FormData) => {\n    const result = await duplicateEvent(undefined, formData);\n\n    if (result.success) {\n      showToast(result.message || \"Event duplicated successfully!\", \"success\");\n    } else {\n      showToast(result.message || \"Failed to duplicate event.\", \"error\");\n    }\n  };\n\n  // Sort events: upcoming first, then by start time\n  const sortedEvents = [...events].sort((a, b) => {\n    const now = new Date();\n    const aIsUpcoming = a.startTime > now;\n    const bIsUpcoming = b.startTime > now;\n\n    if (aIsUpcoming && !bIsUpcoming) return -1;\n    if (!aIsUpcoming && bIsUpcoming) return 1;\n\n    return a.startTime.getTime() - b.startTime.getTime();\n  });\n\n  return (\n    <div className=\"space-y-4\" data-testid=\"events-table\">\n      {sortedEvents.length === 0 ? (\n        <div className=\"text-center py-8 text-muted-foreground\">\n          No events found. Create your first event above.\n        </div>\n      ) : (\n        sortedEvents.map((event) => (\n          <EventCard\n            key={event.id}\n            event={event}\n            onUpdate={handleUpdate}\n            onDelete={handleDelete}\n            onDuplicate={handleDuplicate}\n          />\n        ))\n      )}\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAGA;AACA;AAAA;AAAA;AACA;AALA;;;;;AAWe,SAAS,WAAW,EAAE,MAAM,EAAmB;IAC5D,MAAM,EAAE,SAAS,EAAE,GAAG,IAAA,sIAAQ;IAE9B,MAAM,eAAe,OAAO;QAC1B,MAAM,SAAS,MAAM,IAAA,qKAAW,EAAC,WAAW;QAE5C,IAAI,OAAO,OAAO,EAAE;YAClB,UAAU,OAAO,OAAO,IAAI,+BAA+B;QAC7D,OAAO;YACL,UAAU,OAAO,OAAO,IAAI,2BAA2B;QACzD;IACF;IAEA,MAAM,eAAe,OAAO;QAC1B,MAAM,SAAS,MAAM,IAAA,qKAAW,EAAC,WAAW;QAE5C,IAAI,OAAO,OAAO,EAAE;YAClB,UAAU,OAAO,OAAO,IAAI,+BAA+B;QAC7D,OAAO;YACL,UAAU,OAAO,OAAO,IAAI,2BAA2B;QACzD;IACF;IAEA,MAAM,kBAAkB,OAAO;QAC7B,MAAM,SAAS,MAAM,IAAA,wKAAc,EAAC,WAAW;QAE/C,IAAI,OAAO,OAAO,EAAE;YAClB,UAAU,OAAO,OAAO,IAAI,kCAAkC;QAChE,OAAO;YACL,UAAU,OAAO,OAAO,IAAI,8BAA8B;QAC5D;IACF;IAEA,kDAAkD;IAClD,MAAM,eAAe;WAAI;KAAO,CAAC,IAAI,CAAC,CAAC,GAAG;QACxC,MAAM,MAAM,IAAI;QAChB,MAAM,cAAc,EAAE,SAAS,GAAG;QAClC,MAAM,cAAc,EAAE,SAAS,GAAG;QAElC,IAAI,eAAe,CAAC,aAAa,OAAO,CAAC;QACzC,IAAI,CAAC,eAAe,aAAa,OAAO;QAExC,OAAO,EAAE,SAAS,CAAC,OAAO,KAAK,EAAE,SAAS,CAAC,OAAO;IACpD;IAEA,qBACE,8OAAC;QAAI,WAAU;QAAY,eAAY;kBACpC,aAAa,MAAM,KAAK,kBACvB,8OAAC;YAAI,WAAU;sBAAyC;;;;;mBAIxD,aAAa,GAAG,CAAC,CAAC,sBAChB,8OAAC,8JAAS;gBAER,OAAO;gBACP,UAAU;gBACV,UAAU;gBACV,aAAa;eAJR,MAAM,EAAE;;;;;;;;;;AAUzB","debugId":null}},
    {"offset": {"line": 1773, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/app/admin/events/EventsClient.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { Event } from \"@prisma/client\";\nimport { createEvent } from \"@/lib/actions/event.actions\";\nimport { RouteReady } from \"@/components/testing/RouteReady\";\nimport { useToast } from \"@/components/ui/toast\";\nimport EventForm from \"./_components/EventForm\";\nimport EventsList from \"./_components/EventsList\";\n\ninterface EventsClientProps {\n  initialEvents: Event[];\n}\n\nexport default function EventsClient({ initialEvents }: EventsClientProps) {\n  const router = useRouter();\n  const { ToastComponent, showToast } = useToast();\n  const [isCreating, setIsCreating] = useState(false);\n\n  const refreshEvents = async () => {\n    router.refresh();\n  };\n\n  const handleCreateEvent = async (formData: FormData) => {\n    setIsCreating(true);\n    try {\n      const result = await createEvent(undefined, formData);\n\n      if (result.success) {\n        showToast(result.message ?? \"Event created successfully!\", \"success\");\n        await refreshEvents();\n        return true;\n      }\n\n      showToast(result.message ?? \"Failed to create event.\", \"error\");\n      return false;\n    } finally {\n      setIsCreating(false);\n    }\n  };\n\n  return (\n    <div className=\"flex-1 w-full flex flex-col items-center p-8\">\n      <ToastComponent />\n      <div className=\"w-full max-w-4xl space-y-8\">\n        <div>\n          <h1 className=\"text-3xl font-bold mb-2\" data-testid=\"page-title\">Event Management</h1>\n          <p className=\"text-muted-foreground\">\n            Create and manage events for the senior dog rescue community.\n          </p>\n        </div>\n\n        <EventForm onSubmit={handleCreateEvent} isSubmitting={isCreating} />\n\n        <div>\n          <h2 className=\"text-xl font-semibold mb-4\">All Events</h2>\n          <EventsList events={initialEvents} />\n        </div>\n\n        {process.env.NEXT_PUBLIC_E2E === \"true\" && (\n          <RouteReady route=\"admin/events\" />\n        )}\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AATA;;;;;;;;;AAee,SAAS,aAAa,EAAE,aAAa,EAAqB;IACvE,MAAM,SAAS,IAAA,+IAAS;IACxB,MAAM,EAAE,cAAc,EAAE,SAAS,EAAE,GAAG,IAAA,sIAAQ;IAC9C,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,iNAAQ,EAAC;IAE7C,MAAM,gBAAgB;QACpB,OAAO,OAAO;IAChB;IAEA,MAAM,oBAAoB,OAAO;QAC/B,cAAc;QACd,IAAI;YACF,MAAM,SAAS,MAAM,IAAA,qKAAW,EAAC,WAAW;YAE5C,IAAI,OAAO,OAAO,EAAE;gBAClB,UAAU,OAAO,OAAO,IAAI,+BAA+B;gBAC3D,MAAM;gBACN,OAAO;YACT;YAEA,UAAU,OAAO,OAAO,IAAI,2BAA2B;YACvD,OAAO;QACT,SAAU;YACR,cAAc;QAChB;IACF;IAEA,qBACE,8OAAC;QAAI,WAAU;;0BACb,8OAAC;;;;;0BACD,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;;0CACC,8OAAC;gCAAG,WAAU;gCAA0B,eAAY;0CAAa;;;;;;0CACjE,8OAAC;gCAAE,WAAU;0CAAwB;;;;;;;;;;;;kCAKvC,8OAAC,8JAAS;wBAAC,UAAU;wBAAmB,cAAc;;;;;;kCAEtD,8OAAC;;0CACC,8OAAC;gCAAG,WAAU;0CAA6B;;;;;;0CAC3C,8OAAC,+JAAU;gCAAC,QAAQ;;;;;;;;;;;;oBAGrB,QAAQ,GAAG,CAAC,eAAe,KAAK,wBAC/B,8OAAC,kJAAU;wBAAC,OAAM;;;;;;;;;;;;;;;;;;AAK5B","debugId":null}}]
}