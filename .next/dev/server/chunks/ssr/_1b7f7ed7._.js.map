{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/zod/applicationSchema.ts"],"sourcesContent":["// lib/schemas/applicationSchema.ts\n\nimport { z } from \"zod\";\n\n// Profile fields (user account data)\nexport const profileSchema = z.object({\n  firstName: z.string().min(1, { message: \"First name is required.\" }),\n  lastName: z.string().min(1, { message: \"Last name is required.\" }),\n  email: z.string().email({ message: \"Please enter a valid email address.\" }),\n});\n\n// Applicant fields (application-specific data - moved from Profile to Application)\nexport const applicantSchema = z.object({\n  // --- Contact Fields ---\n  applicantPhone: z.string().optional(),\n\n  // --- Housing Fields ---\n  address: z.string().min(5, { message: \"Please enter a valid address.\" }),\n  housingType: z.enum([\"OWN_HOME\", \"RENT_HOME\", \"OWN_APT_CONDO\", \"RENT_APT_CONDO\", \"OTHER\"]),\n  hasYard: z.enum([\"YES\", \"NO\", \"SHARED\"]),\n  yardFenced: z.boolean(),\n  otherPets: z.string().optional(), // Description of other pets\n  vetName: z.string().optional(),\n  vetPhone: z.string().optional(),\n\n  // --- Home Environment Field ---\n  homeEnvironmentDescription: z.string().min(1, { message: \"Please describe your home environment.\" })\n});\n\nexport const applicationSchema = z.object({\n  // --- Application-specific Fields ---\n  reason: z.string().min(10, { message: \"Please provide a reason (min 10 characters).\" }),\n\n  // --- Relation IDs ---\n  dogId: z.number().int().positive().optional(),\n\n  // --- Reference Fields (relational data) ---\n  references: z.array(z.object({\n    name: z.string().min(1, \"Reference name is required.\"),\n    phone: z.string().optional(),\n    relationship: z.string().optional()\n  })).optional(),\n}).merge(applicantSchema.partial()); // Merge applicant fields as optional into application schema\n\nexport type ProfileFormData = z.infer<typeof profileSchema>;\nexport type ApplicationFormData = z.infer<typeof applicationSchema>;\nexport type ApplicantFormData = z.infer<typeof applicantSchema>;\n"],"names":[],"mappings":"AAAA,mCAAmC;;;;;;;;;AAEnC;;AAGO,MAAM,gBAAgB,kLAAC,CAAC,MAAM,CAAC;IACpC,WAAW,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAA0B;IAClE,UAAU,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAyB;IAChE,OAAO,kLAAC,CAAC,MAAM,GAAG,KAAK,CAAC;QAAE,SAAS;IAAsC;AAC3E;AAGO,MAAM,kBAAkB,kLAAC,CAAC,MAAM,CAAC;IACtC,yBAAyB;IACzB,gBAAgB,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAEnC,yBAAyB;IACzB,SAAS,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAgC;IACtE,aAAa,kLAAC,CAAC,IAAI,CAAC;QAAC;QAAY;QAAa;QAAiB;QAAkB;KAAQ;IACzF,SAAS,kLAAC,CAAC,IAAI,CAAC;QAAC;QAAO;QAAM;KAAS;IACvC,YAAY,kLAAC,CAAC,OAAO;IACrB,WAAW,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAC9B,SAAS,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAC5B,UAAU,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAE7B,iCAAiC;IACjC,4BAA4B,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAyC;AACpG;AAEO,MAAM,oBAAoB,kLAAC,CAAC,MAAM,CAAC;IACxC,sCAAsC;IACtC,QAAQ,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI;QAAE,SAAS;IAA+C;IAErF,uBAAuB;IACvB,OAAO,kLAAC,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ,GAAG,QAAQ;IAE3C,6CAA6C;IAC7C,YAAY,kLAAC,CAAC,KAAK,CAAC,kLAAC,CAAC,MAAM,CAAC;QAC3B,MAAM,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QACxB,OAAO,kLAAC,CAAC,MAAM,GAAG,QAAQ;QAC1B,cAAc,kLAAC,CAAC,MAAM,GAAG,QAAQ;IACnC,IAAI,QAAQ;AACd,GAAG,KAAK,CAAC,gBAAgB,OAAO,KAAK,6DAA6D","debugId":null}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/schemas/application.schema.ts"],"sourcesContent":["// lib/schemas/application.schema.ts\n\nimport { z } from 'zod';\n\nimport { AppType, HousingType, YardType } from '@prisma/client';\n\n// This is the SINGLE source of truth for application validation.\n\nexport const applicationSchema = z.object({\n  formType: z.nativeEnum(AppType),\n  dogId: z.coerce.number().optional(),\n\n  // ContactInfoSection\n  firstName: z.string().min(2, \"First name is required\"),\n  lastName: z.string().min(2, \"Last name is required\"),\n  // email is on profile, not here\n  applicantPhone: z.string().optional(),\n  address: z.string().min(5, \"Address is required\"),\n  vetName: z.string().optional(),\n  vetPhone: z.string().optional(),\n  // HousingInfoSection\n  housingType: z.nativeEnum(HousingType, { message: \"Housing type is required\" }),\n  hasYard: z.nativeEnum(YardType, { message: \"Yard info is required\" }),\n  yardFenced: z.boolean().optional(),\n  otherPets: z.string().optional(),\n  homeEnvironmentDescription: z.string().min(10, \"Description is required\"),\n  // ReasonSection\n  reason: z.string().min(20, \"Reason must be at least 20 characters\"),\n  // ReferencesSection (example, adjust as needed)\n  references: z.array(z.object({\n    name: z.string().min(2, \"Reference name is required\"),\n    phone: z.string().optional(),\n    relationship: z.string().optional(),\n  })).optional(),\n});\n"],"names":[],"mappings":"AAAA,oCAAoC;;;;;AAEpC;AAEA;;;AAIO,MAAM,oBAAoB,kLAAC,CAAC,MAAM,CAAC;IACxC,UAAU,kLAAC,CAAC,UAAU,CAAC,wIAAO;IAC9B,OAAO,kLAAC,CAAC,MAAM,CAAC,MAAM,GAAG,QAAQ;IAEjC,qBAAqB;IACrB,WAAW,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IAC7B,UAAU,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IAC5B,gCAAgC;IAChC,gBAAgB,kLAAC,CAAC,MAAM,GAAG,QAAQ;IACnC,SAAS,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IAC3B,SAAS,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAC5B,UAAU,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAC7B,qBAAqB;IACrB,aAAa,kLAAC,CAAC,UAAU,CAAC,4IAAW,EAAE;QAAE,SAAS;IAA2B;IAC7E,SAAS,kLAAC,CAAC,UAAU,CAAC,yIAAQ,EAAE;QAAE,SAAS;IAAwB;IACnE,YAAY,kLAAC,CAAC,OAAO,GAAG,QAAQ;IAChC,WAAW,kLAAC,CAAC,MAAM,GAAG,QAAQ;IAC9B,4BAA4B,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI;IAC/C,gBAAgB;IAChB,QAAQ,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI;IAC3B,gDAAgD;IAChD,YAAY,kLAAC,CAAC,KAAK,CAAC,kLAAC,CAAC,MAAM,CAAC;QAC3B,MAAM,kLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QACxB,OAAO,kLAAC,CAAC,MAAM,GAAG,QAAQ;QAC1B,cAAc,kLAAC,CAAC,MAAM,GAAG,QAAQ;IACnC,IAAI,QAAQ;AACd","debugId":null}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/profile.actions.ts"],"sourcesContent":["// lib/actions/profile.actions.ts\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { prisma } from \"@/lib/prisma\";\nimport { UserRole } from \"@prisma/client\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { z } from \"zod\";\nimport { ActionResult } from \"@/lib/types\";\n\nconst createProfileSchema = z.object({\n  name: z.string().optional(),\n});\n\n\n// Add this new function\nexport async function getActingUser(\n  { requireAuth = true }: { requireAuth?: boolean } = {}\n) {\n  // Check for synthetic session headers first (set by middleware)\n  const { headers } = await import('next/headers');\n  const headerData = await headers();\n  const testUserId = headerData.get('x-test-user-id');\n  const testUserRole = headerData.get('x-test-user-role');\n\n  if (testUserId && testUserRole) {\n    // Return a mock/partial User object based on headers\n    return {\n      id: testUserId,\n      email: `test-${testUserRole.toLowerCase()}@example.test`,\n      app_metadata: { role: testUserRole as UserRole },\n    } as {\n      id: string;\n      email: string;\n      app_metadata: { role: UserRole };\n    };\n  }\n\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n\n  if (requireAuth && !user) {\n    redirect(\"/auth/login\");\n  }\n  return user;\n}\n\n// Add this new function\nexport async function requireRole(role: UserRole | UserRole[]) {\n  const user = await getActingUser();\n  if (!user) {\n    // This should be redundant due to getActingUser, but good for type safety\n    throw new Error(\"Authentication required.\");\n  }\n\n  const roles = Array.isArray(role) ? role : [role];\n  const userRole = await getActingUserRole(); // Assumes this queries the DB\n\n  // Role hierarchy: ADMIN can access everything\n  if (userRole === UserRole.ADMIN) {\n    return; // Admin has access to everything\n  }\n\n  if (!roles.includes(userRole)) {\n    throw new Error(\"Unauthorized.\");\n  }\n}\n\n// Defense-in-depth RBAC helper - throws on unauthorized access\nexport async function assertRole(requiredRoles: UserRole | UserRole[]): Promise<void> {\n  const user = await getActingUser();\n  if (!user) {\n    throw new Error(\"Authentication required.\");\n  }\n\n  const userRole = await getActingUserRole();\n  const roles = Array.isArray(requiredRoles) ? requiredRoles : [requiredRoles];\n\n  // ADMIN can access everything\n  if (userRole === UserRole.ADMIN) {\n    return;\n  }\n\n  if (!roles.includes(userRole)) {\n    throw new Error(\"Insufficient permissions.\");\n  }\n}\n\nexport async function createProfile(name: string) {\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) { throw new Error(\"User not authenticated.\"); }\n\n  const parsed = createProfileSchema.safeParse({ name });\n  if (!parsed.success) {\n    throw new Error(parsed.error.issues[0]?.message ?? \"Invalid name\");\n  }\n\n  await prisma.profile.upsert({\n     where: { id: user.id },\n     update: { name: parsed.data.name, email: user.email }, // Update name/email if they exist\n     create: { id: user.id, email: user.email!, name: parsed.data.name },\n  });\n}\n\nexport async function updateUserRole(prevState: ActionResult, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.ADMIN);\n\n    const userId = formData.get('userId') as string;\n    const role = formData.get('role') as UserRole;\n\n    if (!userId || !role) {\n      return {\n        success: false,\n        message: \"Missing required fields\",\n        fieldErrors: undefined,\n        data: null,\n      };\n    }\n\n    // Protect \"last admin\" from demotion\n    const adminCount = await prisma.profile.count({ where: { role: 'ADMIN' } });\n    const user = await prisma.profile.findUnique({ where: { id: userId }, select: { role: true } });\n    if (!user) {\n      return {\n        success: false,\n        message: 'User not found',\n        fieldErrors: { userId: ['User not found'] },\n        data: null,\n      };\n    }\n    if (user.role === 'ADMIN' && role !== 'ADMIN' && adminCount <= 1) {\n      return {\n        success: false,\n        message: 'Cannot demote the last admin',\n        fieldErrors: { role: ['Cannot demote the last admin'] },\n        data: null,\n      };\n    }\n\n    await prisma.profile.update({ where: { id: userId }, data: { role } });\n    revalidatePath('/admin/users');\n    return {\n      success: true,\n      message: 'Role updated successfully',\n      fieldErrors: undefined,\n      data: null,\n    };\n  } catch {\n    return {\n      success: false,\n      message: \"Failed to update user role\",\n      fieldErrors: undefined,\n      data: null,\n    };\n  }\n}\n\nexport async function getAllUsers() {\n  if (process.env.NODE_ENV !== 'test') {\n    await assertRole(UserRole.ADMIN);\n  }\n  return await prisma.profile.findMany({\n    orderBy: { email: \"asc\" },\n    select: {\n      id: true,\n      name: true,\n      email: true,\n      role: true,\n    },\n  });\n}\n\nexport async function getAllStaffUsers() {\n  if (process.env.NODE_ENV !== 'test') {\n    await assertRole(UserRole.STAFF);\n  }\n  return await prisma.profile.findMany({\n    where: {\n      role: {\n        in: [UserRole.STAFF, UserRole.ADMIN],\n      },\n    },\n    orderBy: { email: \"asc\" },\n    select: {\n      id: true,\n      name: true,\n      email: true,\n    },\n  });\n}\n\nexport async function getActingUserRole(): Promise<UserRole> {\n  // Check for synthetic session headers first (set by middleware)\n  const { headers } = await import('next/headers');\n  const headerData = await headers();\n  const testUserRole = headerData.get('x-test-user-role');\n\n  if (testUserRole && ['ADMIN', 'STAFF', 'VOLUNTEER'].includes(testUserRole)) {\n    return testUserRole as UserRole;\n  }\n\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n\n  if (!user) {\n    throw new Error(\"Not authenticated\");\n  }\n\n  const profile = await prisma.profile.findUnique({\n    where: { id: user.id },\n    select: { role: true },\n  });\n\n  if (!profile) {\n    throw new Error(\"Profile not found\");\n  }\n\n  return profile.role;\n}\n\nexport async function getUserProfile(userId: string) {\n  // Ensure user can only view their own profile (skip in test environment)\n  if (process.env.NODE_ENV !== 'test') {\n    const currentUser = await getActingUser();\n    if (!currentUser || currentUser.id !== userId) {\n      throw new Error(\"Unauthorized: Can only view your own profile\");\n    }\n  }\n\n  const parsed = z.object({ userId: z.string() }).safeParse({ userId });\n  if (!parsed.success) {\n    throw new Error(\"Invalid user ID\");\n  }\n\n  const profile = await prisma.profile.findUnique({\n    where: { id: userId },\n    select: {\n      name: true,\n      email: true,\n      role: true,\n      trainingCompleted: true,\n      backgroundCheckCompleted: true,\n      shiftCapacity: true,\n      prefersWeekdays: true,\n      prefersMornings: true,\n    },\n  });\n\n  // Return null if profile doesn't exist\n  return profile;\n}\n\nexport async function getUserSignupIds(userId: string) {\n  // Ensure user can only view their own signup IDs (skip in test environment)\n  if (process.env.NODE_ENV !== 'test') {\n    const currentUser = await getActingUser();\n    if (!currentUser || currentUser.id !== userId) {\n      throw new Error(\"Unauthorized: Can only view your own signups\");\n    }\n  }\n\n  const parsed = z.object({ userId: z.string() }).safeParse({ userId });\n  if (!parsed.success) {\n    throw new Error(\"Invalid user ID\");\n  }\n\n  try {\n    const userSignups = await prisma.volunteerShiftSignup.findMany({\n      where: { volunteerId: userId },\n      select: { shiftId: true }\n    });\n\n    return userSignups.map(signup => signup.shiftId);\n  } catch {\n    // Return empty array on any lookup failure (user doesn't exist, etc.)\n    return [];\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 479, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/types.ts"],"sourcesContent":["// lib/types.ts\n\n/**\n * Result type for server actions - follows Railway-oriented programming pattern\n */\nexport type Result<T, E = Error> = { success: true; data: T } | { success: false; error: E };\n\n/**\n * Canonical action result type for server actions\n */\nexport type ActionResult<T = null> = {\n  data: T | null;\n  success: boolean;\n  message: string | null;\n  fieldErrors?: Record<string, string[]>;\n};\n\n/**\n * Helper constructor for successful ActionResult\n */\nexport function ok<T = null>(data: T, message: string | null = null): ActionResult<T> {\n  return {\n    success: true,\n    message,\n    data,\n    fieldErrors: undefined,\n  };\n}\n\n/**\n * Helper constructor for failed ActionResult\n */\nexport function fail<T = null>(message: string, fieldErrors?: Record<string, string[]>): ActionResult<T> {\n  return {\n    success: false,\n    message,\n    data: null,\n    fieldErrors,\n  } as ActionResult<T>;\n}\n\n/**\n * Helper constructor for ActionResult with default values\n */\nexport function makeActionResult<T>(overrides?: Partial<ActionResult<T>>): ActionResult<T> {\n  return {\n    success: false,\n    message: null,\n    data: null,\n    fieldErrors: undefined,\n    ...overrides,\n  };\n}\n\n/**\n * Canonical dog list item for admin tables and listings\n */\nexport interface DogListItem {\n  id: number;\n  mutt_id: string | null;\n  name: string;\n  breed: string | null;\n  dateOfBirth: Date | null;\n  gender: import(\"@prisma/client\").Gender | null;\n  size: import(\"@prisma/client\").DogSize | null;\n  weight_lbs: number | null;\n  primaryPhotoUrl: string | null;\n  specialNeeds: boolean;\n  bioPublic: string | null;\n  status: import(\"@prisma/client\").DogStatus;\n  fosterProfile?: {\n    name: string | null;\n    email: string;\n  } | null;\n}\n\n/**\n * Public dog list item for adopt page with derived fields\n */\nexport interface PublicDogListItem extends Omit<DogListItem, 'gender' | 'mutt_id'> {\n  gender: import(\"@prisma/client\").Gender;\n  mutt_id: string | null;\n  isSenior: boolean;\n  hasPhotos: boolean;\n}\n\n/**\n * Canonical pagination metadata\n */\nexport interface PaginationMeta {\n  currentPage: number;\n  totalPages: number;\n  totalCount: number;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n}\n"],"names":[],"mappings":"AAAA,eAAe;AAEf;;CAEC;;;;;;;;AAgBM,SAAS,GAAa,IAAO,EAAE,UAAyB,IAAI;IACjE,OAAO;QACL,SAAS;QACT;QACA;QACA,aAAa;IACf;AACF;AAKO,SAAS,KAAe,OAAe,EAAE,WAAsC;IACpF,OAAO;QACL,SAAS;QACT;QACA,MAAM;QACN;IACF;AACF;AAKO,SAAS,iBAAoB,SAAoC;IACtE,OAAO;QACL,SAAS;QACT,SAAS;QACT,MAAM;QACN,aAAa;QACb,GAAG,SAAS;IACd;AACF","debugId":null}},
    {"offset": {"line": 519, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/audit/withAudit.ts"],"sourcesContent":["// lib/audit/withAudit.ts\n\"use server\";\n\nimport type { PrismaClient } from '@prisma/client';\nimport { prisma as defaultClient } from '@/lib/db';\nimport { AuditAction, Prisma } from \"@prisma/client\";\n\nexport interface WithAuditCtx {\n  actorId: string;\n  action: AuditAction;\n  entityType: string;\n  entityId: number;\n  before?: Record<string, unknown>;\n  after?: Record<string, unknown>;\n  note?: string;\n}\n\nexport async function withAudit<T>(\n  operation: (tx: Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$extends'>) => Promise<T>,\n  ctx: WithAuditCtx,\n  client: PrismaClient = defaultClient\n): Promise<T> {\n  return client.$transaction(async (tx) => {\n    const result = await operation(tx);\n\n    await tx.auditLog.create({\n      data: {\n        action: ctx.action,\n        actorId: ctx.actorId,\n        entityType: ctx.entityType,\n        entityId: ctx.entityId,\n        before: ctx.before ? (ctx.before as Prisma.InputJsonValue) : Prisma.JsonNull,\n        after: ctx.after ? (ctx.after as Prisma.InputJsonValue) : Prisma.JsonNull,\n        note: ctx.note || 'Operation completed',\n      },\n    });\n\n    return result;\n  });\n}"],"names":[],"mappings":"AAAA,yBAAyB;;;;;;AAIzB;AACA;;;;;AAYO,eAAe,UACpB,SAAmH,EACnH,GAAiB,EACjB,SAAuB,mHAAa;IAEpC,OAAO,OAAO,YAAY,CAAC,OAAO;QAChC,MAAM,SAAS,MAAM,UAAU;QAE/B,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;YACvB,MAAM;gBACJ,QAAQ,IAAI,MAAM;gBAClB,SAAS,IAAI,OAAO;gBACpB,YAAY,IAAI,UAAU;gBAC1B,UAAU,IAAI,QAAQ;gBACtB,QAAQ,IAAI,MAAM,GAAI,IAAI,MAAM,GAA6B,uIAAM,CAAC,QAAQ;gBAC5E,OAAO,IAAI,KAAK,GAAI,IAAI,KAAK,GAA6B,uIAAM,CAAC,QAAQ;gBACzE,MAAM,IAAI,IAAI,IAAI;YACpB;QACF;QAEA,OAAO;IACT;AACF;;;IAtBsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 557, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/audit.actions.ts"],"sourcesContent":["// lib/actions/audit.actions.ts\n\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { AuditAction, Prisma } from \"@prisma/client\";\nimport { createClient } from \"@/lib/supabase/server\";\n\nexport interface AuditContext {\n  action: AuditAction;\n  entityType: string;\n  entityId: number;\n  actorId: string;\n  before?: Record<string, unknown>;\n  after?: Record<string, unknown>;\n  note?: string;\n}\n\n// Audit wrapper for server actions with retry safety\nexport async function withAudit<T>(\n  actionName: string,\n  userId: string,\n  operation: () => Promise<T>,\n  auditContext?: Partial<AuditContext>\n): Promise<T> {\n  const startTime = Date.now();\n  let attempts = 0;\n  const maxRetries = 3;\n\n  while (attempts < maxRetries) {\n    try {\n      const result = await operation();\n      const duration = Date.now() - startTime;\n\n      // Log successful operation\n      if (auditContext) {\n        try {\n          await prisma.auditLog.create({\n            data: {\n              action: auditContext.action!,\n              actorId: userId,\n              entityType: auditContext.entityType!,\n              entityId: auditContext.entityId!,\n              before: auditContext.before ? (auditContext.before as Prisma.InputJsonValue) : Prisma.JsonNull,\n              after: auditContext.after ? (auditContext.after as Prisma.InputJsonValue) : Prisma.JsonNull,\n              note: auditContext.note || `${actionName} completed in ${duration}ms`,\n            }\n          });\n        } catch {\n          // Silently skip audit logging failures (e.g., in tests without audit table)\n          // Don't log to console to avoid test noise\n        }\n      }\n\n      return result;\n    } catch (error: unknown) {\n      attempts++;\n\n      // Check if error is retryable (transient DB errors)\n      const isRetryable = error && typeof error === 'object' && 'code' in error &&\n                         (error.code === 'P2025' || // Record not found (might be race condition)\n                          error.code === 'P2002' || // Unique constraint violation (might be race condition)\n                          error.code === 'P2034' || // Transaction write conflict\n                          (error && typeof error === 'object' && 'message' in error && typeof error.message === 'string' && error.message.includes('connection')));\n\n      if (!isRetryable || attempts >= maxRetries) {\n        // Log failed operation\n        if (auditContext) {\n          try {\n            await prisma.auditLog.create({\n              data: {\n                action: auditContext.action!,\n                actorId: userId,\n                entityType: auditContext.entityType!,\n                entityId: auditContext.entityId!,\n              before: Prisma.JsonNull,\n              after: Prisma.JsonNull,\n                note: `${actionName} failed after ${attempts} attempts: ${error instanceof Error ? error.message : 'Unknown error'}`,\n              }\n            });\n          } catch {\n            // Silently skip audit logging failures (e.g., in tests without audit table)\n            // Don't log to console to avoid test noise\n          }\n        }\n\n        throw error;\n      }\n\n      // Exponential backoff: wait 100ms * 2^attempt\n      const backoffMs = 100 * Math.pow(2, attempts - 1);\n      console.warn(`${actionName} failed (attempt ${attempts}/${maxRetries}), retrying in ${backoffMs}ms:`, error && typeof error === 'object' && 'message' in error ? error.message : error);\n      await new Promise(resolve => setTimeout(resolve, backoffMs));\n    }\n  }\n\n  throw new Error(`Operation ${actionName} failed after ${maxRetries} attempts`);\n}\n\n// Helper to get current user from session\nexport async function getCurrentUserId(): Promise<string> {\n  const supabase = await createClient();\n  const { data, error } = await supabase.auth.getUser();\n  const user = data?.user;\n\n  if (error || !user) {\n    throw new Error('User not authenticated');\n  }\n\n  return user.id;\n}\n\n// Type-safe audit logging helpers - use these instead of raw AuditLog inserts\nexport async function logDogAudit(\n  dogId: number,\n  action: AuditAction,\n  actorId: string,\n  options: {\n    before?: Record<string, unknown>;\n    after?: Record<string, unknown>;\n    note?: string;\n  } = {}\n) {\n  return prisma.auditLog.create({\n    data: {\n      action,\n      actorId,\n      entityType: 'dog',\n      entityId: dogId,\n      before: options.before ? (options.before as Prisma.InputJsonValue) : Prisma.JsonNull,\n      after: options.after ? (options.after as Prisma.InputJsonValue) : Prisma.JsonNull,\n      note: options.note,\n    }\n  });\n}\n\nexport async function logApplicationAudit(\n  applicationId: number,\n  action: AuditAction,\n  actorId: string,\n  options: {\n    before?: Record<string, unknown>;\n    after?: Record<string, unknown>;\n    note?: string;\n  } = {}\n) {\n  return prisma.auditLog.create({\n    data: {\n      action,\n      actorId,\n      entityType: 'application',\n      entityId: applicationId,\n      before: options.before ? (options.before as Prisma.InputJsonValue) : Prisma.JsonNull,\n      after: options.after ? (options.after as Prisma.InputJsonValue) : Prisma.JsonNull,\n      note: options.note,\n    }\n  });\n}\n\n// Helper to capture before/after state for audit\nexport async function captureAuditState(entityType: string, entityId: number) {\n  switch (entityType) {\n    case 'dog':\n      const dog = await prisma.dog.findUnique({\n        where: { id: entityId },\n        select: {\n          id: true,\n          name: true,\n          status: true,\n          breed: true,\n          breedId: true, // Include new breedId field\n          dateOfBirth: true,\n          bioPublic: true,\n          notesInternal: true,\n          specialNeeds: true,\n          primaryPhotoUrl: true,\n          page_url: true,\n          mutt_id: true,\n          weight_lbs: true,\n          gender: true,\n          size: true,\n          fosterProfileId: true,\n        }\n      });\n      return dog;\n    case 'application':\n      const application = await prisma.application.findUnique({\n        where: { id: entityId },\n        select: {\n          id: true,\n          status: true,\n          statusNotes: true,\n          applicationType: true,\n          reason: true,\n          createdAt: true,\n          updatedAt: true,\n        }\n      });\n      return application;\n    default:\n      return null;\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 743, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/utils/dog-utils.ts"],"sourcesContent":["import { DogSize } from \"@prisma/client\";\n\nexport function calculateAge(dob: Date | null | undefined): number | null {\n  if (!dob) return null;\n\n  const diff = Date.now() - new Date(dob).getTime();\n  const ageDate = new Date(diff);\n\n  return Math.abs(ageDate.getUTCFullYear() - 1970);\n}\n\nexport function isSenior(dob: Date | null | undefined): boolean {\n  const age = calculateAge(dob);\n  // Default to 'true' for seniors if age is unknown, as this is a senior dog rescue.\n  return (age || 8) >= 8;\n}\n\nexport function getSizeFromWeight(weight: number | null | undefined): DogSize {\n  if (!weight) return DogSize.UNKNOWN;\n\n  if (weight < 8) return DogSize.TOY;\n  if (weight < 20) return DogSize.SMALL;\n  if (weight < 45) return DogSize.MEDIUM;\n\n  return DogSize.LARGE;\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEO,SAAS,aAAa,GAA4B;IACvD,IAAI,CAAC,KAAK,OAAO;IAEjB,MAAM,OAAO,KAAK,GAAG,KAAK,IAAI,KAAK,KAAK,OAAO;IAC/C,MAAM,UAAU,IAAI,KAAK;IAEzB,OAAO,KAAK,GAAG,CAAC,QAAQ,cAAc,KAAK;AAC7C;AAEO,SAAS,SAAS,GAA4B;IACnD,MAAM,MAAM,aAAa;IACzB,mFAAmF;IACnF,OAAO,CAAC,OAAO,CAAC,KAAK;AACvB;AAEO,SAAS,kBAAkB,MAAiC;IACjE,IAAI,CAAC,QAAQ,OAAO,wIAAO,CAAC,OAAO;IAEnC,IAAI,SAAS,GAAG,OAAO,wIAAO,CAAC,GAAG;IAClC,IAAI,SAAS,IAAI,OAAO,wIAAO,CAAC,KAAK;IACrC,IAAI,SAAS,IAAI,OAAO,wIAAO,CAAC,MAAM;IAEtC,OAAO,wIAAO,CAAC,KAAK;AACtB","debugId":null}},
    {"offset": {"line": 775, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/format.ts"],"sourcesContent":["/**\n * Formatting utilities for consistent display of missing/null values and dog data formatting\n */\n\nimport { calculateAge } from \"./utils/dog-utils\";\nimport { humanizeEnum } from \"./utils\";\nimport { Gender, DogSize } from \"@prisma/client\";\n\n/**\n * Returns the value if it's truthy and non-empty, otherwise returns the fallback\n */\nexport const missing = (value: string | null | undefined, fallback = 'N/A'): string =>\n  value && value.trim() !== '' ? value : fallback;\n\n/**\n * Format dog age for display\n */\nexport const formatDogAge = (dateOfBirth: Date | null): string => {\n  if (!dateOfBirth) return missing(null);\n  const age = calculateAge(dateOfBirth);\n  return age ? `${age} years` : missing(null);\n};\n\n/**\n * Format dog gender for display\n */\nexport const formatDogGender = (gender: Gender | null): string => {\n  return gender ? humanizeEnum(gender) : missing(null);\n};\n\n/**\n * Format dog size for display\n */\nexport const formatDogSize = (size: DogSize | null): string => {\n  return size ? humanizeEnum(size) : missing(null);\n};\n\n/**\n * Format dog weight for display\n */\nexport const formatDogWeight = (weightLbs: number | null): string => {\n  return weightLbs ? `${weightLbs} lbs` : missing(null);\n};\n\n/**\n * Format date for display (e.g., \"Jan 15, 2024\")\n */\nexport const formatDisplayDate = (date: Date): string => {\n  return new Date(date).toLocaleDateString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric'\n  });\n};\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;;;;;AAED;AACA;AAAA;;;AAMO,MAAM,UAAU,CAAC,OAAkC,WAAW,KAAK,GACxE,SAAS,MAAM,IAAI,OAAO,KAAK,QAAQ;AAKlC,MAAM,eAAe,CAAC;IAC3B,IAAI,CAAC,aAAa,OAAO,QAAQ;IACjC,MAAM,MAAM,IAAA,4IAAY,EAAC;IACzB,OAAO,MAAM,GAAG,IAAI,MAAM,CAAC,GAAG,QAAQ;AACxC;AAKO,MAAM,kBAAkB,CAAC;IAC9B,OAAO,SAAS,IAAA,qIAAY,EAAC,UAAU,QAAQ;AACjD;AAKO,MAAM,gBAAgB,CAAC;IAC5B,OAAO,OAAO,IAAA,qIAAY,EAAC,QAAQ,QAAQ;AAC7C;AAKO,MAAM,kBAAkB,CAAC;IAC9B,OAAO,YAAY,GAAG,UAAU,IAAI,CAAC,GAAG,QAAQ;AAClD;AAKO,MAAM,oBAAoB,CAAC;IAChC,OAAO,IAAI,KAAK,MAAM,kBAAkB,CAAC,SAAS;QAChD,MAAM;QACN,OAAO;QACP,KAAK;IACP;AACF","debugId":null}},
    {"offset": {"line": 822, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/csv.ts"],"sourcesContent":["// lib/csv.ts\n\n/**\n * Sanitizes a value for CSV export, preventing Excel formula injection attacks\n * and handling null/undefined values safely.\n */\nexport const sanitizeCell = (value: unknown): string => {\n  let s = value == null ? '' : String(value);\n  // Prefix with single quote if starts with formula characters to prevent Excel injection\n  if (/^[=+\\-@]/.test(s)) s = `'${s}`;\n  // Escape quotes by doubling them and wrap in quotes\n  return `\"${s.replace(/\"/g, '\"\"')}\"`;\n};\n\n/**\n * Converts an array of objects to CSV format with headers.\n * @param data Array of objects to convert\n * @param headers Optional custom headers. If not provided, uses object keys from first item\n * @returns CSV string with BOM for Excel UTF-8 compatibility\n */\nexport const toCsv = <T extends Record<string, unknown>>(\n  data: T[],\n  headers?: string[]\n): string => {\n  const headerRow = headers || (data.length > 0 ? Object.keys(data[0]) : []);\n  const csvRows = [\n    headerRow.map(sanitizeCell).join(','),\n    ...data.map(row =>\n      headerRow.map(key => sanitizeCell(row[key])).join(',')\n    )\n  ];\n\n  // Prepend BOM for Excel UTF-8 compatibility\n  return '\\uFEFF' + csvRows.join('\\n') + (csvRows.length > 0 ? '\\n' : '');\n};\n\n/**\n * Downloads CSV data as a file with the given filename.\n * @param filename The name of the file to download (without extension)\n * @param data The CSV data as a string\n */\nexport const downloadCsv = (filename: string, data: string): void => {\n  const blob = new Blob([data], { type: 'text/csv;charset=utf-8;' });\n  const url = URL.createObjectURL(blob);\n\n  // Create a temporary link and trigger download\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename.endsWith('.csv') ? filename : `${filename}.csv`;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n\n  // Clean up the URL object\n  URL.revokeObjectURL(url);\n};\n"],"names":[],"mappings":"AAAA,aAAa;AAEb;;;CAGC;;;;;;;;AACM,MAAM,eAAe,CAAC;IAC3B,IAAI,IAAI,SAAS,OAAO,KAAK,OAAO;IACpC,wFAAwF;IACxF,IAAI,WAAW,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,EAAE,GAAG;IACnC,oDAAoD;IACpD,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,MAAM,MAAM,CAAC,CAAC;AACrC;AAQO,MAAM,QAAQ,CACnB,MACA;IAEA,MAAM,YAAY,WAAW,CAAC,KAAK,MAAM,GAAG,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE;IACzE,MAAM,UAAU;QACd,UAAU,GAAG,CAAC,cAAc,IAAI,CAAC;WAC9B,KAAK,GAAG,CAAC,CAAA,MACV,UAAU,GAAG,CAAC,CAAA,MAAO,aAAa,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC;KAErD;IAED,4CAA4C;IAC5C,OAAO,WAAW,QAAQ,IAAI,CAAC,QAAQ,CAAC,QAAQ,MAAM,GAAG,IAAI,OAAO,EAAE;AACxE;AAOO,MAAM,cAAc,CAAC,UAAkB;IAC5C,MAAM,OAAO,IAAI,KAAK;QAAC;KAAK,EAAE;QAAE,MAAM;IAA0B;IAChE,MAAM,MAAM,IAAI,eAAe,CAAC;IAEhC,+CAA+C;IAC/C,MAAM,OAAO,SAAS,aAAa,CAAC;IACpC,KAAK,IAAI,GAAG;IACZ,KAAK,QAAQ,GAAG,SAAS,QAAQ,CAAC,UAAU,WAAW,GAAG,SAAS,IAAI,CAAC;IACxE,SAAS,IAAI,CAAC,WAAW,CAAC;IAC1B,KAAK,KAAK;IACV,SAAS,IAAI,CAAC,WAAW,CAAC;IAE1B,0BAA0B;IAC1B,IAAI,eAAe,CAAC;AACtB","debugId":null}},
    {"offset": {"line": 871, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/url.ts"],"sourcesContent":["// lib/url.ts\n// URL building utilities\n\n/**\n * Build URL query string from search parameters object\n */\nexport function buildQueryString(params: Record<string, string | undefined>): string {\n  const filteredParams = Object.entries(params)\n    .filter(([, value]) => value !== undefined && value !== '')\n    .reduce((acc, [key, value]) => {\n      acc[key] = value!;\n      return acc;\n    }, {} as Record<string, string>);\n\n  return new URLSearchParams(filteredParams).toString();\n}\n\n/**\n * Build full URL with query parameters\n */\nexport function buildUrl(baseUrl: string, params: Record<string, string | undefined>): string {\n  const queryString = buildQueryString(params);\n  return queryString ? `${baseUrl}?${queryString}` : baseUrl;\n}\n\n/**\n * Set or delete a parameter in URLSearchParams\n */\nexport const setParam = (\n  searchParams: URLSearchParams,\n  key: string,\n  value?: string | null,\n) => {\n  if (value && value.length > 0) {\n    searchParams.set(key, value);\n  } else {\n    searchParams.delete(key);\n  }\n};\n"],"names":[],"mappings":"AAAA,aAAa;AACb,yBAAyB;AAEzB;;CAEC;;;;;;;;AACM,SAAS,iBAAiB,MAA0C;IACzE,MAAM,iBAAiB,OAAO,OAAO,CAAC,QACnC,MAAM,CAAC,CAAC,GAAG,MAAM,GAAK,UAAU,aAAa,UAAU,IACvD,MAAM,CAAC,CAAC,KAAK,CAAC,KAAK,MAAM;QACxB,GAAG,CAAC,IAAI,GAAG;QACX,OAAO;IACT,GAAG,CAAC;IAEN,OAAO,IAAI,gBAAgB,gBAAgB,QAAQ;AACrD;AAKO,SAAS,SAAS,OAAe,EAAE,MAA0C;IAClF,MAAM,cAAc,iBAAiB;IACrC,OAAO,cAAc,GAAG,QAAQ,CAAC,EAAE,aAAa,GAAG;AACrD;AAKO,MAAM,WAAW,CACtB,cACA,KACA;IAEA,IAAI,SAAS,MAAM,MAAM,GAAG,GAAG;QAC7B,aAAa,GAAG,CAAC,KAAK;IACxB,OAAO;QACL,aAAa,MAAM,CAAC;IACtB;AACF","debugId":null}},
    {"offset": {"line": 905, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/url-pagination.ts"],"sourcesContent":["/**\n * Shared URL pagination utilities for consistent pagination across the application\n * Server-side utilities only - client-side hooks are in url-pagination-client.ts\n */\n\nimport { buildQueryString } from \"@/lib/url\";\n\nexport const PAGINATION_PARAMS = {\n  PAGE: \"page\",\n} as const;\n\n/**\n * Pagination data structure shared across the application\n */\nexport interface PaginationData {\n  currentPage: number;\n  totalPages: number;\n  totalCount: number;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n}\n\n/**\n * Utility function to parse page from search params with default value\n */\nexport function getCurrentPage(searchParams: URLSearchParams, defaultPage = 1): number {\n  const pageParam = searchParams.get(PAGINATION_PARAMS.PAGE);\n  if (!pageParam) return defaultPage;\n\n  const parsed = parseInt(pageParam, 10);\n  return isNaN(parsed) || parsed < 1 ? defaultPage : parsed;\n}\n\n/**\n * Generic helper for page parsing\n */\nexport function parsePageParam(raw: string | undefined, defaultPage = 1): number {\n  if (!raw) return defaultPage;\n  const parsed = parseInt(raw, 10);\n  return isNaN(parsed) || parsed < 1 ? defaultPage : parsed;\n}\n\n/**\n * Validated parameters for application filtering and pagination\n */\nexport interface ApplicationSearchParams {\n  page: number;\n  limit: number;\n  status?: string;\n  type?: string;\n  search?: string;\n  sortBy: string;\n  sortOrder: 'asc' | 'desc';\n}\n\n/**\n * Parse and validate application search parameters from URL search params\n */\nexport function parseApplicationSearchParams(searchParams: { [key: string]: string | undefined }): ApplicationSearchParams {\n  const validatedParams: ApplicationSearchParams = {\n    page: Math.max(1, parseInt(searchParams?.page || \"1\")),\n    limit: Math.min(100, Math.max(1, parseInt(searchParams?.limit || \"10\"))), // Max 100 per page\n    status: searchParams?.status,\n    type: searchParams?.type,\n    search: searchParams?.search?.trim(),\n    sortBy: searchParams?.sortBy || 'createdAt',\n    sortOrder: (searchParams?.sortOrder === 'asc' ? 'asc' : 'desc') as 'asc' | 'desc',\n  };\n\n  // Validate search term length to prevent abuse\n  if (validatedParams.search && validatedParams.search.length > 100) {\n    throw new Error(\"Search term too long\");\n  }\n\n  return validatedParams;\n}\n\n/**\n * Validated parameters for dog filtering and pagination\n */\nexport interface DogSearchParams {\n  page: number;\n  limit: number;\n  status?: string;\n  fosterProfileId?: string;\n  breed?: string;\n  gender?: string;\n  size?: string;\n  weightMin?: string;\n  weightMax?: string;\n  specialNeeds?: string;\n  hasPhotos?: string;\n  sortField: string;\n  sortDirection: 'asc' | 'desc';\n}\n\n/**\n * Convert Next.js searchParams (Promise) to plain object for dog queries\n * Handles the Promise<{ [key: string]: string | string[] | undefined }> format\n */\nexport function parseDogSearchParams(searchParams: { [key: string]: string | string[] | undefined }): { [key: string]: string } {\n  const result: { [key: string]: string } = {};\n\n  Object.entries(searchParams).forEach(([key, value]) => {\n    if (typeof value === 'string') {\n      result[key] = value;\n    } else if (Array.isArray(value) && value.length > 0) {\n      // Take the first value if it's an array (shouldn't happen for our use case)\n      result[key] = value[0];\n    }\n    // Skip undefined values\n  });\n\n  return result;\n}\n\n/**\n * Build query string for application export with all current filters\n */\nexport function buildApplicationExportQuery(params: ApplicationSearchParams, minimal: boolean): string {\n  const queryParams: Record<string, string | undefined> = {\n    page: params.page.toString(),\n    limit: params.limit.toString(),\n    status: params.status,\n    type: params.type,\n    search: params.search,\n    sortBy: params.sortBy,\n    sortOrder: params.sortOrder,\n  };\n\n  if (minimal) {\n    queryParams.minimal = 'true';\n  }\n\n  return buildQueryString(queryParams);\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;AAED;;AAEO,MAAM,oBAAoB;IAC/B,MAAM;AACR;AAgBO,SAAS,eAAe,YAA6B,EAAE,cAAc,CAAC;IAC3E,MAAM,YAAY,aAAa,GAAG,CAAC,kBAAkB,IAAI;IACzD,IAAI,CAAC,WAAW,OAAO;IAEvB,MAAM,SAAS,SAAS,WAAW;IACnC,OAAO,MAAM,WAAW,SAAS,IAAI,cAAc;AACrD;AAKO,SAAS,eAAe,GAAuB,EAAE,cAAc,CAAC;IACrE,IAAI,CAAC,KAAK,OAAO;IACjB,MAAM,SAAS,SAAS,KAAK;IAC7B,OAAO,MAAM,WAAW,SAAS,IAAI,cAAc;AACrD;AAkBO,SAAS,6BAA6B,YAAmD;IAC9F,MAAM,kBAA2C;QAC/C,MAAM,KAAK,GAAG,CAAC,GAAG,SAAS,cAAc,QAAQ;QACjD,OAAO,KAAK,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,GAAG,SAAS,cAAc,SAAS;QACjE,QAAQ,cAAc;QACtB,MAAM,cAAc;QACpB,QAAQ,cAAc,QAAQ;QAC9B,QAAQ,cAAc,UAAU;QAChC,WAAY,cAAc,cAAc,QAAQ,QAAQ;IAC1D;IAEA,+CAA+C;IAC/C,IAAI,gBAAgB,MAAM,IAAI,gBAAgB,MAAM,CAAC,MAAM,GAAG,KAAK;QACjE,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;AACT;AAyBO,SAAS,qBAAqB,YAA8D;IACjG,MAAM,SAAoC,CAAC;IAE3C,OAAO,OAAO,CAAC,cAAc,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM;QAChD,IAAI,OAAO,UAAU,UAAU;YAC7B,MAAM,CAAC,IAAI,GAAG;QAChB,OAAO,IAAI,MAAM,OAAO,CAAC,UAAU,MAAM,MAAM,GAAG,GAAG;YACnD,4EAA4E;YAC5E,MAAM,CAAC,IAAI,GAAG,KAAK,CAAC,EAAE;QACxB;IACA,wBAAwB;IAC1B;IAEA,OAAO;AACT;AAKO,SAAS,4BAA4B,MAA+B,EAAE,OAAgB;IAC3F,MAAM,cAAkD;QACtD,MAAM,OAAO,IAAI,CAAC,QAAQ;QAC1B,OAAO,OAAO,KAAK,CAAC,QAAQ;QAC5B,QAAQ,OAAO,MAAM;QACrB,MAAM,OAAO,IAAI;QACjB,QAAQ,OAAO,MAAM;QACrB,QAAQ,OAAO,MAAM;QACrB,WAAW,OAAO,SAAS;IAC7B;IAEA,IAAI,SAAS;QACX,YAAY,OAAO,GAAG;IACxB;IAEA,OAAO,IAAA,8HAAgB,EAAC;AAC1B","debugId":null}},
    {"offset": {"line": 986, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/lib/actions/application.actions.ts"],"sourcesContent":["// lib/actions/application.actions.ts\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { notFound, redirect } from \"next/navigation\";\nimport { prisma } from \"@/lib/db\";\nimport { AppStatus, AppType, Prisma, AuditAction } from \"@prisma/client\";\nimport { createClient } from \"@/lib/supabase/server\";\nimport { applicationSchema, profileSchema } from \"@/lib/zod/applicationSchema\"; // Zod schema\nimport { applicationSchema as newApplicationSchema } from \"@/lib/schemas/application.schema\"; // New Zod schema\nimport { z } from \"zod\";\nimport { assertRole } from \"@/lib/actions/profile.actions\";\nimport { UserRole } from \"@prisma/client\";\nimport { ActionResult, ok, fail } from \"@/lib/types\";\nimport { getAllowedStatuses } from \"@/lib/utils\";\nimport { withAudit } from \"@/lib/audit/withAudit\";\nimport { getCurrentUserId } from \"./audit.actions\";\nimport { getSSRUser } from \"@/lib/auth/session.server\";\nimport { missing } from \"@/lib/format\";\nimport { toCsv } from \"@/lib/csv\";\nimport {\n  AdminApplicationDetail,\n  ApplicationListItem,\n  ApplicationHistoryEntry,\n} from \"@/lib/view-models/applications\";\nimport { parseApplicationSearchParams } from \"@/lib/url-pagination\";\n\nconst updateStatusSchema = z.object({\n  appId: z.coerce.number().int().positive({ message: \"Invalid application ID\" }),\n  status: z.nativeEnum(AppStatus, { message: \"Invalid status\" }),\n  statusNotes: z.string().optional(),\n});\n\nfunction parseApplicationIds(formData: FormData): number[] {\n  const raw = formData.get(\"applicationIds\");\n  if (!raw || typeof raw !== \"string\") return [];\n  return raw\n    .split(\",\")\n    .map(s => s.trim())\n    .filter(Boolean)\n    .map(Number)\n    .filter(Number.isFinite);\n}\n\n\nexport async function createApplication(\n  prevState: ActionResult<null>,\n  formData: FormData\n): Promise<ActionResult<null>> {\n\n  const user = await getSSRUser();\n  if (!user) {\n    // This should never happen if middleware is correct, but it's a good guard.\n    return fail(\"Authentication error. Please log in again.\");\n  }\n\n  // Fetch profile data for snapshot\n  const profile = await prisma.profile.findUnique({\n    where: { id: user.id }\n  });\n  if (!profile) {\n    return fail(\"Profile not found. Please contact support.\");\n  }\n\n  const rawData = Object.fromEntries(formData.entries());\n\n  // Coerce form data for validation\n  const coercedData = {\n    ...rawData,\n    formType: rawData.formType,\n    dogId: rawData.dogId ? Number(rawData.dogId) : undefined,\n    yardFenced: rawData.yardFenced ? rawData.yardFenced === 'on' : undefined,\n    // ... add any other coercions (e.g., references)\n  };\n\n  const result = newApplicationSchema.safeParse(coercedData);\n  if (!result.success) {\n    console.warn(\"Application validation failed:\", result.error.flatten().fieldErrors);\n    return fail(\"Validation failed. Please check your entries.\", result.error.flatten().fieldErrors);\n  }\n\n  const { data } = result;\n\n  try {\n    // Use a transaction. It's the only safe way.\n    await prisma.$transaction(async (tx) => {\n\n      await tx.application.create({\n        data: {\n          applicationType: data.formType,\n          status: 'SUBMITTED',\n          reason: data.reason,\n          dogId: data.dogId,\n          profileId: user.id, // <-- Correct\n          submittedAt: new Date(),\n\n          // --- SNAPSHOT COPY FROM PROFILE ---\n          applicantName: profile.name || 'Unknown',\n          applicantEmail: profile.email,\n          // --- FORM DATA (snapshot of what user provided at submission time) ---\n          applicantPhone: data.applicantPhone,\n          address: data.address,\n          housingType: data.housingType,\n          hasYard: data.hasYard,\n          yardFenced: data.yardFenced,\n          otherPets: data.otherPets,\n          vetName: data.vetName,\n          vetPhone: data.vetPhone,\n          homeEnvironmentDescription: data.homeEnvironmentDescription,\n        }\n      });\n\n      // Create references if provided\n      if (data.references && data.references.length > 0) {\n        // Get the application ID we just created - this is tricky in a transaction\n        // We need to create the application first to get the ID\n        // Let me restructure this...\n\n        // Actually, let me get the application ID after creation\n        // For now, let's create references after the transaction\n      }\n    });\n\n    // Handle references outside transaction for simplicity\n    if (data.references && data.references.length > 0) {\n      // Get the application we just created\n      const createdApplication = await prisma.application.findFirst({\n        where: {\n          profileId: user.id,\n          applicationType: data.formType,\n          status: 'SUBMITTED',\n        },\n        orderBy: { createdAt: 'desc' },\n        select: { id: true },\n      });\n\n      if (createdApplication) {\n        await prisma.reference.createMany({\n          data: data.references.map((ref) => ({\n            ...ref,\n            applicationId: createdApplication.id,\n          })),\n        });\n      }\n    }\n  } catch (error) {\n    console.error(\"Application submission error:\", error);\n    return fail(\"A database error occurred. Please try again.\");\n  }\n\n  // Revalidate admin path and redirect user\n  revalidatePath(\"/admin/applications\");\n  const successPath = data.formType === 'ADOPTER' ? '/apply/adopt/success' : '/apply/foster/success';\n  redirect(successPath);\n}\n\nexport async function submitApplication(formData: FormData): Promise<ActionResult<{ applicationId: number }>> {\n  console.log('submitApplication called with formData keys:', Array.from(formData.keys()));\n  const supabase = await createClient();\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) {\n    console.log('submitApplication: user not authenticated');\n    return fail(\"Not authenticated\");\n  }\n  console.log('submitApplication: user authenticated, proceeding with submission');\n\n  try {\n    // Parse form data\n    const formType = formData.get('formType') as AppType;\n    const dogId = formData.get('dogId') ? parseInt(formData.get('dogId') as string) : undefined;\n\n    // Optional: applications can target a specific dog or be general interest applications\n    let validatedDogId: number | undefined;\n    if (dogId !== undefined && dogId !== null) {\n      if (isNaN(dogId) || dogId <= 0) {\n        return fail(\"Invalid dog ID provided.\", { dogId: [\"Must be a valid positive number\"] });\n      }\n      validatedDogId = dogId;\n    }\n\n    // Handle references - parse nested array format from form data\n    const parsedReferences: Array<{ name: string; phone: string; relationship: string }> = [];\n    let index = 0;\n    while (true) {\n      const name = formData.get(`references[${index}][name]`) as string;\n      const phone = formData.get(`references[${index}][phone]`) as string;\n      const relationship = formData.get(`references[${index}][relationship]`) as string;\n\n      if (!name) break; // No more references\n\n      parsedReferences.push({\n        name,\n        phone: phone || '',\n        relationship: relationship || '',\n      });\n      index++;\n    }\n\n    // Extract form fields - separate profile and application data\n    const profileData = {\n      firstName: formData.get('firstName') as string,\n      lastName: formData.get('lastName') as string,\n      email: formData.get('email') as string,\n    };\n\n    const applicantData = {\n      applicantPhone: formData.get('applicantPhone') as string || undefined,\n      address: formData.get('address') as string,\n      housingType: (formData.get('housingType') as 'OWN_HOME' | 'RENT_HOME' | 'OWN_APT_CONDO' | 'RENT_APT_CONDO' | 'OTHER') ?? 'OTHER',\n      hasYard: (formData.get('hasYard') as 'YES' | 'NO' | 'SHARED') ?? 'NO',\n      yardFenced: formData.get('yardFenced') === 'on',\n      otherPets: formData.get('otherPets') as string || undefined,\n      vetName: formData.get('vetName') as string || undefined,\n      vetPhone: formData.get('vetPhone') as string || undefined,\n      homeEnvironmentDescription: formData.get('homeEnvironmentDescription') as string,\n    };\n\n    const applicationData = {\n      reason: formData.get('reason') as string,\n      dogId: validatedDogId,\n      references: parsedReferences,\n      ...applicantData, // Include applicant fields in application data\n    };\n\n    // Validate profile data (only name and email)\n    const validatedProfileData = profileSchema.safeParse(profileData);\n    if (!validatedProfileData.success) {\n      const fieldErrors = validatedProfileData.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // Validate application data (includes applicant fields)\n    const validatedApplicationData = applicationSchema.safeParse(applicationData);\n    if (!validatedApplicationData.success) {\n      const fieldErrors = validatedApplicationData.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // 1. Separate references from the application data.\n    const { references: validatedReferences, ...applicationFields } = validatedApplicationData.data;\n\n    // 2. Use a transaction to ensure data integrity.\n    let app: { id: number } | undefined;\n    await prisma.$transaction(async (tx) => {\n      // 3. Upsert the user's profile with name and email\n      await tx.profile.upsert({\n        where: { id: user.id },\n        update: {\n          name: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n          email: validatedProfileData.data.email,\n        },\n        create: {\n          id: user.id,\n          name: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n          email: validatedProfileData.data.email,\n          role: UserRole.VOLUNTEER, // Default role for new profiles\n        },\n      });\n\n      // 4. Create the application with application-specific data only\n      const applicationData: Prisma.ApplicationCreateInput = {\n        applicationType: formType,\n        profileId: user.id,\n        status: AppStatus.SUBMITTED,\n        submittedAt: new Date(),\n        reason: applicationFields.reason,\n        applicantName: `${validatedProfileData.data.firstName} ${validatedProfileData.data.lastName}`,\n        applicantEmail: validatedProfileData.data.email,\n      };\n\n      // Add optional fields if they exist\n      if (applicationFields.dogId !== undefined) applicationData.dog = { connect: { id: applicationFields.dogId } };\n      if (applicationFields.applicantPhone !== undefined) applicationData.applicantPhone = applicationFields.applicantPhone;\n      if (applicationFields.address !== undefined) applicationData.address = applicationFields.address;\n      if (applicationFields.housingType !== undefined) applicationData.housingType = applicationFields.housingType;\n      if (applicationFields.hasYard !== undefined) applicationData.hasYard = applicationFields.hasYard;\n      if (applicationFields.yardFenced !== undefined) applicationData.yardFenced = applicationFields.yardFenced;\n      if (applicationFields.otherPets !== undefined) applicationData.otherPets = applicationFields.otherPets;\n      if (applicationFields.vetName !== undefined) applicationData.vetName = applicationFields.vetName;\n      if (applicationFields.vetPhone !== undefined) applicationData.vetPhone = applicationFields.vetPhone;\n      if (applicationFields.homeEnvironmentDescription !== undefined) applicationData.homeEnvironmentDescription = applicationFields.homeEnvironmentDescription;\n\n      app = await tx.application.create({\n        data: applicationData,\n      });\n\n      // 5. If references exist, create them and link them.\n      if (validatedReferences && validatedReferences.length > 0) {\n        await tx.reference.createMany({\n          data: validatedReferences.map((ref) => ({\n            ...ref,\n            applicationId: app!.id, // Link to the new application\n          })),\n        });\n      }\n    });\n\n    // 6. Revalidate paths\n    revalidatePath(\"/admin/applications\");\n\n    if (!app) {\n      throw new Error(\"Failed to create application\");\n    }\n\n    console.log('submitApplication: application created successfully with ID:', app.id);\n    return ok({ applicationId: app.id }, 'Application submitted successfully!');\n  } catch (error) {\n    console.error(\"Application submission failed:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to submit application.\");\n  }\n}\n\nexport async function updateApplicationStatus(prevState: ActionResult, formData: FormData): Promise<ActionResult> {\n  try {\n    await assertRole(UserRole.STAFF);\n    const userId = await getCurrentUserId();\n\n    const parsed = updateStatusSchema.safeParse(Object.fromEntries(formData.entries()));\n    if (!parsed.success) {\n      const fieldErrors = parsed.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    const { appId, status, statusNotes } = parsed.data;\n\n    // Get current application to validate status transition\n    const currentApplication = await prisma.application.findUnique({\n      where: { id: appId },\n      select: {\n        status: true,\n        applicationType: true,\n      },\n    });\n\n    if (!currentApplication) {\n      return fail(\"Application not found.\");\n    }\n\n    // Validate that the status transition is allowed (server-side enforcement)\n    const allowedStatuses = getAllowedStatuses(currentApplication.applicationType, currentApplication.status);\n    if (!allowedStatuses.includes(status)) {\n      return fail(\"Invalid status transition for this application type.\");\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED\n    if ((status === AppStatus.APPROVED || status === AppStatus.REJECTED) &&\n        (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required when moving to approved or rejected status.\", { statusNotes: [\"Required for terminal status changes\"] });\n    }\n\n    await withAudit(\n      async (tx) => {\n        const application = await tx.application.update({\n          where: { id: appId },\n          data: {\n            status,\n            statusNotes: statusNotes || null,\n          },\n          select: {\n            applicationType: true,\n            profileId: true,\n          },\n        });\n\n        // Write to append-only ApplicationAudit table\n        await tx.applicationAudit.create({\n          data: {\n            applicationId: appId,\n            actorId: userId,\n            oldStatus: currentApplication.status,\n            newStatus: status,\n            note: statusNotes || `Status changed from ${currentApplication.status} to ${status}`,\n          },\n        });\n\n        if (application.applicationType === AppType.FOSTER && status === AppStatus.APPROVED) {\n          await tx.fosterProfile.upsert({\n            where: { profileId: application.profileId },\n            update: {},\n            create: {\n              profileId: application.profileId,\n            },\n          });\n        }\n\n        return application;\n      },\n      {\n        actorId: userId,\n        action: AuditAction.APPLICATION_STATUS_CHANGE,\n        entityType: 'application',\n        entityId: appId,\n        note: `Status changed from ${currentApplication.status} to ${status}`,\n      },\n      prisma\n    );\n\n    revalidatePath(`/admin/applications/${appId}`);\n    revalidatePath(\"/admin/applications\");\n\n    return ok(null, \"Application status updated successfully!\");\n  } catch (error) {\n    return fail(error instanceof Error ? error.message : \"Failed to update status\");\n  }\n}\n\nexport async function getApplicationById(id: number): Promise<AdminApplicationDetail> {\n  const parsed = z.object({ id: z.coerce.number().int().positive() }).safeParse({ id });\n  if (!parsed.success) {\n    throw new Error(\"Invalid application ID\");\n  }\n\n  const application = await prisma.application.findUnique({\n    where: { id },\n    select: {\n      id: true,\n      createdAt: true,\n      updatedAt: true,\n      applicationType: true,\n      status: true,\n      statusNotes: true,\n      profileId: true,\n      applicantName: true,\n      applicantEmail: true,\n      applicantPhone: true,\n      address: true,\n      housingType: true,\n      hasYard: true,\n      yardFenced: true,\n      otherPets: true,\n      vetName: true,\n      vetPhone: true,\n      homeEnvironmentDescription: true,\n      reason: true,\n      references: true,\n      dog: {\n        select: {\n          id: true,\n          name: true,\n          status: true,\n          bioPublic: true,\n        },\n      },\n    },\n  });\n  if (!application) notFound();\n\n  // 2. DELETE ALL JSON.parse logic. It's not needed.\n  // const formData = JSON.parse(application.formDataJson);\n  // return { ...application, formData };\n\n  // Decrypt PII fields from profile before returning\n\n  return {\n    ...application,\n    housingTypeLabel: application.housingType || \"Not specified\",\n    hasYardLabel:\n      application.hasYard === \"YES\"\n        ? \"Yes\"\n        : application.hasYard === \"NO\"\n        ? \"No\"\n        : application.hasYard === \"SHARED\"\n        ? \"Shared\"\n        : \"Not specified\",\n    yardFencedLabel:\n      application.yardFenced === true\n        ? \"Yes\"\n        : application.yardFenced === false\n        ? \"No\"\n        : \"Not specified\",\n    otherPetsLabel: application.otherPets || \"Not specified\",\n    homeEnvironmentDescriptionLabel: application.homeEnvironmentDescription || \"Not specified\",\n  };\n}\n\nexport async function getAllApplications(searchParams?: { [key: string]: string | undefined }): Promise<{\n    applications: ApplicationListItem[];\n    pagination: {\n        currentPage: number;\n        totalPages: number;\n        totalCount: number;\n        hasNextPage: boolean;\n        hasPreviousPage: boolean;\n    };\n}> {\n    await assertRole(UserRole.STAFF);\n\n    // Parse and validate search parameters using shared helper\n    const validatedParams = parseApplicationSearchParams(searchParams || {});\n\n    // Validate status filter\n    if (validatedParams.status && validatedParams.status !== \"all\") {\n        if (!Object.values(AppStatus).includes(validatedParams.status as AppStatus)) {\n            throw new Error(`Invalid status filter: ${validatedParams.status}`);\n        }\n    }\n\n    // Validate type filter\n    if (validatedParams.type && validatedParams.type !== \"all\") {\n        if (!Object.values(AppType).includes(validatedParams.type as AppType)) {\n            throw new Error(`Invalid type filter: ${validatedParams.type}`);\n        }\n    }\n\n    const offset = (validatedParams.page - 1) * validatedParams.limit;\n\n    // Build where clause for filtering\n    const where: Prisma.ApplicationWhereInput = {};\n\n    if (validatedParams.status && validatedParams.status !== \"all\") {\n        where.status = validatedParams.status as AppStatus;\n    }\n\n    if (validatedParams.type && validatedParams.type !== \"all\") {\n        where.applicationType = validatedParams.type as AppType;\n    }\n\n    if (validatedParams.search) {\n        where.OR = [\n            {\n                applicantName: {\n                    contains: validatedParams.search,\n                    mode: \"insensitive\"\n                }\n            },\n            {\n                applicantEmail: {\n                    contains: validatedParams.search,\n                    mode: \"insensitive\"\n                }\n            }\n        ];\n    }\n\n    const [applications, totalCount] = await Promise.all([\n        prisma.application.findMany({\n            where,\n            select: {\n                id: true,\n                createdAt: true,\n                updatedAt: true,\n                applicationType: true,\n                status: true,\n                applicantName: true,\n                applicantEmail: true,\n                reason: true,\n                dog: {\n                    select: {\n                        id: true,\n                        name: true,\n                        status: true,\n                    },\n                },\n            },\n            orderBy: { [validatedParams.sortBy]: validatedParams.sortOrder },\n            skip: offset,\n            take: validatedParams.limit,\n        }),\n        prisma.application.count({ where }),\n    ]);\n\n    const totalPages = Math.ceil(totalCount / validatedParams.limit);\n\n    return {\n        applications: applications as ApplicationListItem[],\n        pagination: {\n            currentPage: validatedParams.page,\n            totalPages,\n            totalCount,\n            hasNextPage: validatedParams.page < totalPages,\n            hasPreviousPage: validatedParams.page > 1,\n        },\n    };\n}\n\nexport async function getUserApplications(profileId: string) {\n    const parsed = z.object({ profileId: z.string().uuid() }).safeParse({ profileId });\n    if (!parsed.success) {\n        throw new Error(\"Invalid profile ID\");\n    }\n\n    const applications = await prisma.application.findMany({\n        where: { profileId },\n        include: {\n            references: true,\n        },\n        orderBy: { createdAt: 'desc' }\n    });\n\n    return applications;\n}\n\n// Form action wrapper for updateApplicationStatus\nexport async function updateApplicationStatusForm(formData: FormData) {\n  return updateApplicationStatus(ok(null), formData);\n}\n\nconst bulkUpdateSchema = z.object({\n  appIds: z.array(z.coerce.number().int().positive({ message: \"Invalid application ID\" })),\n  status: z.nativeEnum(AppStatus, { message: \"Invalid status\" }),\n  statusNotes: z.string().optional(),\n});\n\nexport async function bulkUpdateApplicationStatus(\n  appIds: number[],\n  status: AppStatus,\n  statusNotes?: string\n): Promise<ActionResult<{ ok: number[]; failed: { id: number; reason: string }[] }>> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const parsed = bulkUpdateSchema.safeParse({ appIds, status, statusNotes });\n    if (!parsed.success) {\n      const fieldErrors = parsed.error.flatten().fieldErrors;\n      return fail(\"Validation failed.\", fieldErrors);\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED/WITHDRAWN\n    const requiresNotes: AppStatus[] = [AppStatus.APPROVED, AppStatus.REJECTED, AppStatus.WITHDRAWN]\n    if (requiresNotes.includes(status) && (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required when moving to approved, rejected, or withdrawn status.\", { statusNotes: [\"Required for terminal status changes\"] });\n    }\n\n    // Get current user for authentication\n    const supabase = await createClient();\n    const { data: { user: updater } } = await supabase.auth.getUser();\n    if (!updater) {\n      return fail(\"Authentication required.\");\n    }\n\n    // Get updater's role from database\n    const updaterProfile = await prisma.profile.findUnique({\n      where: { id: updater.id },\n      select: { role: true },\n    });\n\n    if (!updaterProfile || (updaterProfile.role !== UserRole.ADMIN && updaterProfile.role !== UserRole.STAFF)) {\n      return fail(\"Insufficient permissions.\");\n    }\n\n    // Get current applications to validate status transitions\n    const currentApplications = await prisma.application.findMany({\n      where: { id: { in: appIds } },\n      select: {\n        id: true,\n        status: true,\n        applicationType: true,\n      },\n    });\n\n    const appMap = new Map(currentApplications.map(app => [app.id, app]));\n    const successfulIds: number[] = [];\n    const failed: { id: number; reason: string }[] = [];\n\n    // Validate each transition and collect failures\n    for (const appId of appIds) {\n      const currentApp = appMap.get(appId);\n      if (!currentApp) {\n        failed.push({ id: appId, reason: \"Application not found\" });\n        continue;\n      }\n\n      // Validate that the status transition is allowed\n      const allowedStatuses = getAllowedStatuses(currentApp.applicationType, currentApp.status);\n      if (!allowedStatuses.includes(status)) {\n        failed.push({\n          id: appId,\n          reason: `Invalid status transition from ${currentApp.status} for ${currentApp.applicationType} application`\n        });\n        continue;\n      }\n\n      successfulIds.push(appId);\n    }\n\n    // Update successful applications and write audit records\n    if (successfulIds.length > 0) {\n      await prisma.$transaction(async (tx) => {\n        // Update applications\n        await tx.application.updateMany({\n          where: { id: { in: successfulIds } },\n          data: {\n            status,\n            statusNotes: statusNotes || null,\n          },\n        });\n\n        // Write to append-only ApplicationAudit table for each updated application\n        await tx.applicationAudit.createMany({\n          data: successfulIds.map(appId => {\n            const currentApp = appMap.get(appId)!;\n            return {\n              applicationId: appId,\n              actorId: updater.id,\n              oldStatus: currentApp.status,\n              newStatus: status,\n              note: statusNotes || `Bulk status change from ${currentApp.status} to ${status}`,\n            };\n          }),\n        });\n      });\n\n      // Revalidate on success\n      revalidatePath(\"/admin/applications\");\n    }\n\n    return ok({ ok: successfulIds, failed }, `Updated ${successfulIds.length} application${successfulIds.length !== 1 ? 's' : ''} successfully${failed.length > 0 ? `, ${failed.length} failed` : ''}.`);\n  } catch (error) {\n    return fail(error instanceof Error ? error.message : \"An unexpected error occurred.\");\n  }\n}\n\nexport async function getApplicationHistory(applicationId: number): Promise<ApplicationHistoryEntry[]> {\n  await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n  const history = await prisma.applicationAudit.findMany({\n    where: { applicationId },\n    select: {\n      id: true,\n      applicationId: true,\n      oldStatus: true,\n      newStatus: true,\n      note: true,\n      createdAt: true,\n      actor: {\n        select: {\n          name: true,\n          email: true,\n        },\n      },\n    },\n    orderBy: { createdAt: \"desc\" },\n  });\n\n  return history as ApplicationHistoryEntry[];\n}\n\n// Server actions for useActionState (form-based)\nexport async function bulkAssignApplications(\n  prevState: ActionResult,\n  formData: FormData\n): Promise<ActionResult> {\n  try {\n    await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n    const applicationIds = formData.getAll(\"applicationIds\").map(id => parseInt(id as string));\n    const staffId = formData.get(\"staffId\") as string;\n\n    if (!staffId || applicationIds.length === 0) {\n      return fail(\"Staff member and applications are required\");\n    }\n\n    // Verify staff user exists\n    const staffUser = await prisma.profile.findUnique({\n      where: { id: staffId },\n      select: { id: true, role: true },\n    });\n\n    if (!staffUser || (staffUser.role !== UserRole.STAFF && staffUser.role !== UserRole.ADMIN)) {\n      return fail(\"Invalid staff member selected\");\n    }\n\n    // Perform bulk update\n    const updateResult = await prisma.application.updateMany({\n      where: {\n        id: { in: applicationIds },\n      },\n      data: {\n        assignedToUserId: staffId,\n        updatedAt: new Date(),\n      },\n    });\n\n    revalidatePath(\"/admin/applications\");\n\n    return ok(null, `Successfully assigned ${updateResult.count} application(s)`);\n\n  } catch (error) {\n    console.error(\"Bulk assign error:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to assign applications\");\n  }\n}\n\nexport async function bulkUpdateApplications(\n  prevState: ActionResult<{ failed?: { id: number; reason: string }[] }>,\n  formData: FormData\n): Promise<ActionResult<{ failed?: { id: number; reason: string }[] }>> {\n  try {\n    await assertRole([UserRole.ADMIN, UserRole.STAFF]);\n\n    const applicationIds = parseApplicationIds(formData);\n    const status = formData.get(\"status\") as AppStatus;\n    const statusNotes = formData.get(\"statusNotes\") as string;\n\n    if (applicationIds.length === 0) {\n      return fail(\"No applications selected\");\n    }\n\n    if (!status) {\n      return fail(\"Status is required\");\n    }\n\n    // Business rule: notes required for APPROVED/REJECTED/WITHDRAWN\n    const requiresNotes: AppStatus[] = [AppStatus.APPROVED, AppStatus.REJECTED, AppStatus.WITHDRAWN];\n    if (requiresNotes.includes(status) && (!statusNotes || statusNotes.trim().length === 0)) {\n      return fail(\"Status notes are required for terminal status changes\");\n    }\n\n    const result = await bulkUpdateApplicationStatus(\n      applicationIds,\n      status,\n      statusNotes?.trim() || undefined\n    );\n\n    if (result.success) {\n      const successCount = result.data?.ok.length || 0;\n\n      revalidatePath(\"/admin/applications\");\n\n      return ok({ failed: result.data?.failed }, `Successfully updated ${successCount} application(s)`);\n    } else {\n      return fail(result.message || \"Bulk update failed\");\n    }\n\n  } catch (error) {\n    console.error(\"Bulk update error:\", error);\n    return fail(error instanceof Error ? error.message : \"Failed to update applications\");\n  }\n}\n\nexport async function exportApplicationsCSV(\n  searchParams: { [key: string]: string | undefined },\n  minimal: boolean\n): Promise<{ success: true; csvData: string; filename: string } | { success: false; message: string }> {\n  try {\n    await assertRole(UserRole.STAFF);\n\n    const filters = { ...searchParams };\n    delete filters.minimal; // Remove minimal param from filters\n\n    const appData = await getAllApplications(filters);\n    const applications: ApplicationListItem[] = appData.applications;\n\n    // Guard against exporting insane data sets\n    const MAX_EXPORT_ROWS = 10000;\n    if (applications.length > MAX_EXPORT_ROWS) {\n      return {\n        success: false,\n        message: `Export too large: ${applications.length} applications found, maximum allowed is ${MAX_EXPORT_ROWS}. Please apply filters to reduce the dataset size.`\n      };\n    }\n\n    // Generate CSV data\n    let csvData: Record<string, unknown>[];\n    let csvHeaders: string[];\n\n    if (minimal) {\n      // Minimal export: no PII (phone/address)\n      csvData = applications.map(app => ({\n        id: app.id,\n        submitted_date: app.createdAt.toISOString().split('T')[0],\n        name: missing(app.applicantName, 'Unknown'),\n        email: missing(app.applicantEmail, 'Unknown'),\n        type: app.applicationType,\n        status: app.status,\n        dog_name: app.dog?.name || '',\n        reason: app.reason,\n      }));\n      csvHeaders = [\n        'ID', 'Submitted Date', 'Name', 'Email', 'Type', 'Status',\n        'Dog Name', 'Reason'\n      ];\n    } else {\n      // Full export with available fields\n      csvData = applications.map(app => ({\n        id: app.id,\n        submitted_date: app.createdAt.toISOString().split('T')[0],\n        name: missing(app.applicantName, 'Unknown'),\n        email: missing(app.applicantEmail, 'Unknown'),\n        type: app.applicationType,\n        status: app.status,\n        dog_name: app.dog?.name || '',\n        reason: app.reason,\n      }));\n      csvHeaders = [\n        'ID', 'Submitted Date', 'Name', 'Email', 'Type', 'Status',\n        'Dog Name', 'Reason'\n      ];\n    }\n\n    const csvWithBOM = toCsv(csvData, csvHeaders);\n    const filename = `applications-${new Date().toISOString().split('T')[0]}${minimal ? '-minimal' : ''}.csv`;\n\n    return {\n      success: true,\n      csvData: csvWithBOM,\n      filename\n    };\n  } catch (error) {\n    console.error('CSV export error:', error);\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : 'Failed to generate export'\n    };\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1919, "column": 0}, "map": {"version":3,"sources":["file:///Users/adampeterson/Github/mutts/.next-internal/server/app/admin/applications/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getSSRUser as '000856392be4f7d53ed3e3e3326c2c888c8e2950e9'} from 'ACTIONS_MODULE0'\nexport {getApplicationHistory as '401573de31f80211180e4bb5b293670b9e5de2cac8'} from 'ACTIONS_MODULE1'\nexport {updateApplicationStatusForm as '401795e2db6a0e011a400212430725a0ada20bf1ad'} from 'ACTIONS_MODULE1'\nexport {getApplicationById as '403ad5ef5391b2aca03196163ad596a4fefd38e607'} from 'ACTIONS_MODULE1'\nexport {getAllApplications as '40c08f5bfbcbbf157560ddb0f51d8e40995af7028d'} from 'ACTIONS_MODULE1'\nexport {getUserApplications as '40c2e8066b223132b8b5aa0890c563e4352dd93472'} from 'ACTIONS_MODULE1'\nexport {submitApplication as '40e91884295e284975fcf38d1438572253eb5d958f'} from 'ACTIONS_MODULE1'\nexport {bulkAssignApplications as '60147ead8af5b60d1fc3fb8a6c8d6f3f3c34d57f06'} from 'ACTIONS_MODULE1'\nexport {createApplication as '6028ec7b04b95b518845748dc7dc80ad5e3e43eaaf'} from 'ACTIONS_MODULE1'\nexport {exportApplicationsCSV as '603b922ea1c90a4064f4774c9722a3b402b978e3e1'} from 'ACTIONS_MODULE1'\nexport {updateApplicationStatus as '606d62df0ce2c836357154fd3533068321cbf66dc1'} from 'ACTIONS_MODULE1'\nexport {bulkUpdateApplications as '607bdf719ac6999081505859589fc797257716012a'} from 'ACTIONS_MODULE1'\nexport {bulkUpdateApplicationStatus as '70c7debef77309b094918bec2b57b1714c25488914'} from 'ACTIONS_MODULE1'\nexport {getAllStaffUsers as '0033a4aab8087bee60fa3957be6e412e7a28e6b142'} from 'ACTIONS_MODULE2'\nexport {getAllUsers as '0040745eebb8809dbc98afe0103726da3438000754'} from 'ACTIONS_MODULE2'\nexport {getActingUserRole as '006095df662d1f5454db62806f7d257b4264768061'} from 'ACTIONS_MODULE2'\nexport {getUserProfile as '40103a556ce1c8f26a74594d1623582c17a19007fe'} from 'ACTIONS_MODULE2'\nexport {requireRole as '401918a5b31d808cec1006f2b7ec1ed729ea95edbe'} from 'ACTIONS_MODULE2'\nexport {createProfile as '4029bb82f3e859aa7d1d5c000b17516a82e1704167'} from 'ACTIONS_MODULE2'\nexport {assertRole as '4058e90462fbf4a2c11008bad52cf288efe05a8b32'} from 'ACTIONS_MODULE2'\nexport {getActingUser as '40b6b27014bdc1a8fded8ff3d22be5fda4813317de'} from 'ACTIONS_MODULE2'\nexport {getUserSignupIds as '40c005c7807d025045aa1b80a1ad40fa0d179df6e8'} from 'ACTIONS_MODULE2'\nexport {updateUserRole as '60ceabe90fc8ed1b25017daee808de48043d157a6e'} from 'ACTIONS_MODULE2'\nexport {withAudit as '7034bdf79cc2f006fa55b1369b0944a2475ffc1154'} from 'ACTIONS_MODULE3'\nexport {getCurrentUserId as '00842318b15abb8899f8a126d649c3887e25bc26dd'} from 'ACTIONS_MODULE4'\nexport {captureAuditState as '60e65605f915ad978cc1eff7d71f6bc5ae162e6026'} from 'ACTIONS_MODULE4'\nexport {withAudit as '784b13a691424b9961dce89e697a2618dca525da25'} from 'ACTIONS_MODULE4'\nexport {logDogAudit as '784b3fb4320f38bcac735db6d70fae03d038f392f6'} from 'ACTIONS_MODULE4'\nexport {logApplicationAudit as '78ed9814381cdb54d982538f79494c008b83c58d6f'} from 'ACTIONS_MODULE4'\nexport {exportApplicationsCSV as '603b922ea1c90a4064f4774c9722a3b402b978e3e1'} from 'ACTIONS_MODULE1'\nexport {bulkAssignApplications as '60147ead8af5b60d1fc3fb8a6c8d6f3f3c34d57f06'} from 'ACTIONS_MODULE1'\nexport {getAllStaffUsers as '0033a4aab8087bee60fa3957be6e412e7a28e6b142'} from 'ACTIONS_MODULE2'\nexport {bulkUpdateApplications as '607bdf719ac6999081505859589fc797257716012a'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AACA;AAYA;AAUA;AACA","debugId":null}}]
}