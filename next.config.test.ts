// next.config.test.ts
/** @vitest-environment jsdom */

import { describe, it, expect } from 'vitest';
import fs from 'fs';
import path from 'path';

// Import the config to test it
import config from './next.config';

// Extract remotePatterns for snapshot testing
const remotePatterns = config.images?.remotePatterns || [];

describe('Next.js Image Configuration', () => {
  describe('remotePatterns allowlist', () => {
    it('should have expected domains in allowlist', () => {
      // Extract just the hostnames for easier testing
      const hostnames = remotePatterns.map(pattern => pattern.hostname).sort();

      expect(hostnames).toMatchSnapshot();
    });

    it('should only allow HTTPS protocols', () => {
      const protocols = remotePatterns.map(pattern => pattern.protocol);

      expect(protocols.every(proto => proto === 'https')).toBe(true);
    });

    it('should include required domains', () => {
      const hostnames = remotePatterns.map(pattern => pattern.hostname);

      // Core domains that should always be present
      expect(hostnames).toContain('via.placeholder.com');
      expect(hostnames).toContain('picsum.photos');

      // Supabase should be included when env var is set
      if (process.env.NEXT_PUBLIC_SUPABASE_URL) {
        const supabaseHostname = new URL(process.env.NEXT_PUBLIC_SUPABASE_URL).hostname;
        expect(hostnames).toContain(supabaseHostname);
      }
    });

    it('should have Supabase storage path restriction', () => {
      const supabasePatterns = remotePatterns.filter(pattern =>
        pattern.hostname === 'localhost' || pattern.hostname.includes('supabase')
      );

      // If Supabase patterns exist, they should have the correct storage path restriction
      supabasePatterns.forEach(pattern => {
        expect(pattern.pathname).toBe('/storage/v1/object/public/**');
      });
    });

    it('should not allow new domains without explicit approval', () => {
      const hostnames = remotePatterns.map(pattern => pattern.hostname);

      // Define the exact allowlist - any additions should be explicitly approved
      const approvedDomains = [
        'via.placeholder.com',
        'picsum.photos',
        'scontent.xx.fbcdn.net',
        'external.xx.fbcdn.net',
        'dl5zpyw5k3jeb.cloudfront.net',
        'assets.adoptapet.com',
        'muttville.org',
        // Supabase domain (when set)
        ...(process.env.NEXT_PUBLIC_SUPABASE_URL
          ? [new URL(process.env.NEXT_PUBLIC_SUPABASE_URL).hostname]
          : [])
      ];

      // All hostnames should be in the approved list
      hostnames.forEach(hostname => {
        expect(approvedDomains).toContain(hostname);
      });

      // All approved domains should be present
      approvedDomains.forEach(domain => {
        expect(hostnames).toContain(domain);
      });
    });

    it('should include all hosts from fix-photo-urls.ts output when file exists', () => {
      // Find any photo-url-hosts-*.txt files generated by fix-photo-urls.ts
      const cwd = process.cwd();
      const files = fs.readdirSync(cwd);
      const hostFiles = files
        .filter(file => file.startsWith('photo-url-hosts-') && file.endsWith('.txt'))
        .sort()
        .reverse(); // Most recent first
      
      if (hostFiles.length > 0) {
        // Use the most recent host file
        const latestHostFile = path.join(cwd, hostFiles[0]);
        const hostFileContent = fs.readFileSync(latestHostFile, 'utf-8');
        const discoveredHosts = hostFileContent
          .split('\n')
          .map(line => line.trim())
          .filter(line => line.length > 0);

        const configHostnames = remotePatterns.map(pattern => pattern.hostname);

        // All discovered hosts should be in config
        discoveredHosts.forEach(host => {
          expect(configHostnames).toContain(host);
        });
      }
    });

    it('should not contain overly permissive wildcards', () => {
      const hostnames = remotePatterns.map(pattern => pattern.hostname);

      // Should not contain generic wildcards that could allow malicious domains
      const overlyPermissive = hostnames.filter(hostname =>
        hostname.includes('*.') ||
        hostname === '*' ||
        hostname.includes('**')
      );

      expect(overlyPermissive).toHaveLength(0);
    });
  });

  describe('image optimization settings', () => {
    it('should have minimum cache TTL configured', () => {
      expect(config.images?.minimumCacheTTL).toBe(60);
    });

    it('should enable modern image formats', () => {
      expect(config.images?.formats).toEqual(['image/avif', 'image/webp']);
    });

    it('should use custom loader', () => {
      expect(config.images?.loaderFile).toBe('./lib/image-loader.ts');
    });
  });
});
